---
title: "API Key CRUD + Management UI + Type Extensions"
description: "V1 slice of the Public API epic (#194): api_keys Drizzle schema, CRUD endpoints, management UI at /settings/api-keys, cascade revocation, @repo/types extensions, and audit logging."
parent_spec: specs/194-public-api-developer-platform.mdx
parent_issue: 194
issue: 318
tier: F-lite
complexity: 5
---

## Context

First vertical slice of the Public API & Developer Platform epic (#194). Delivers the foundational data model, management UI, and type system extensions that V2 (auth guard, #319) and all subsequent slices depend on.

**Parent spec:** [specs/194-public-api-developer-platform.mdx](194-public-api-developer-platform.mdx)
**Affordances from parent:** U1-U7, N1-N3, N16, S1

This spec is self-contained for V1 implementation. It resolves ambiguities from the parent spec identified during expert review.

## Goal

Enable org admins to create, list, and revoke API keys through a management UI. Keys are hashed and stored securely. Type extensions unblock V2 (auth guard integration). Cascade revocation ensures keys are invalidated when their owning user or org is soft-deleted.

## Users & Use Cases

### Users with API key permissions

- Navigate to Settings → API Keys
- Create keys with a name, scoped permissions, and optional expiry (keys belong to the active org)
- See the full key **once** after creation (copy to clipboard)
- View their org's keys in a table with status badges
- Revoke compromised or unused keys

## Expected Behavior

### Happy path: Create an API key

1. User navigates to Settings and clicks the "API Keys" tab
2. Clicks "Create API Key"
3. Enters a name (required), selects scopes via checkboxes (filtered to admin's current permissions), optionally picks an expiry date
4. Clicks "Create"
5. Server validates: scopes must be a subset of the user's current permissions in the active org. Rejects with 400 if any scope is invalid or exceeds permissions.
6. Server generates `sk_live_` + 32 cryptographically random characters (base62: `[a-zA-Z0-9]`)
7. Server creates a per-key random salt (16 bytes), hashes the full key with HMAC-SHA-256 using the salt, stores the hash + salt + prefix + last 4 chars
8. Returns the full key to the client **once**
9. UI displays the key in a dialog with a copy button and warning: "This key will not be shown again. Copy it now."
10. User copies the key and closes the dialog
11. Key appears in the list with name, `sk_live_...xxxx` (masked), scopes as badges, created date, "Never" for last used, and a green "Active" status badge

### Happy path: Revoke a key

1. User clicks "Revoke" on a key row
2. `DestructiveConfirmDialog` appears: "Revoke API key '{name}'? Any integrations using this key will stop working immediately."
3. User confirms
4. Server sets `revokedAt` timestamp on the key
5. Key row updates in-place: status badge changes to red "Revoked", revoke button becomes disabled
6. Audit log entry created: `api_key.revoked`

### Happy path: List keys

1. User visits the API Keys tab
2. **Empty state (no keys):** Message "No API keys yet" with a "Create your first API key" CTA button
3. **With keys:** Table columns: Name, Key (masked), Scopes, Created, Last Used, Status, Actions
4. Status badges: "Active" (green), "Expired" (yellow, when `expiresAt < now`), "Revoked" (red, when `revokedAt` is set)
5. "Last Used" shows "Never" when `lastUsedAt` is null (populated by V2 auth guard)

### Edge cases

| Scenario | Behavior |
|----------|----------|
| Scope request exceeds user's permissions | 400 error: "Requested scopes exceed your current permissions" |
| Key created with empty scopes | Allowed. Key authenticates (V2) but has no permissions. |
| User soft-deleted | All user's API keys get `revokedAt` set immediately via event listener |
| Org soft-deleted | All org's API keys get `revokedAt` set immediately via event listener |
| Duplicate key name in same org | Allowed. Names are labels, not unique identifiers. |
| Max keys per org | No limit in V1. |
| Expiry date in the past | 400 error: "Expiry date must be in the future" |
| User hard-purged (after 30-day grace) | `ON DELETE CASCADE` on `user_id` FK removes key rows. Audit trail preserved via `api_key_id SET NULL` on `audit_logs`. |
| Revoke already-revoked key | 200 (idempotent). No duplicate audit log entry. |
| Key that is both revoked and expired | Status shows "Revoked" (revoked takes priority). |

## Schema

### `api_keys` table

New file: `apps/api/src/database/schema/api-key.schema.ts`

| Column | Type | Nullable | Default | Notes |
|--------|------|----------|---------|-------|
| `id` | `text` PK | No | `crypto.randomUUID()` | Standard `genId` pattern |
| `tenant_id` | `text` FK → `organizations.id` | No | — | `...tenantColumn` (ON DELETE CASCADE) |
| `user_id` | `text` FK → `users.id` ON DELETE CASCADE | No | — | Creator of the key. Cascade ensures purge flow succeeds. |
| `name` | `text` | No | — | Human-readable label |
| `key_prefix` | `text` | No | — | Always `sk_live_` |
| `key_hash` | `text` UNIQUE | No | — | HMAC-SHA-256 of full key using `key_salt` |
| `key_salt` | `text` | No | — | 16-byte random salt, hex-encoded |
| `last_four` | `text` | No | — | Last 4 chars of the key for display |
| `scopes` | `text[]` | No | `[]` | RBAC permission strings subset |
| `rate_limit_tier` | `text` | No | `'standard'` | Reserved for V4. Only `'standard'` in V1. |
| `expires_at` | `timestamptz` | Yes | — | Optional expiry |
| `last_used_at` | `timestamptz` | Yes | — | Updated by V2 auth guard (fire-and-forget) |
| `revoked_at` | `timestamptz` | Yes | — | Set on revocation |
| `created_at` | `timestamptz` | No | `now()` | `...timestamps` |
| `updated_at` | `timestamptz` | No | `now()` | `...timestamps` |

**Indexes:**

| Name | Columns | Purpose |
|------|---------|---------|
| `idx_api_keys_key_hash` | `key_hash` | Fast lookup during auth (V2). Declared in V1 schema. |
| `idx_api_keys_tenant` | `tenant_id` | RLS + list queries |
| `idx_api_keys_user` | `user_id` | Cascade revocation on user deletion |

**Drizzle definition:**

```typescript
const genId = () => crypto.randomUUID()

export const apiKeys = pgTable(
  'api_keys',
  {
    id: text('id').primaryKey().$defaultFn(genId),
    ...tenantColumn,
    userId: text('user_id').notNull().references(() => users.id, { onDelete: 'cascade' }),
    name: text('name').notNull(),
    keyPrefix: text('key_prefix').notNull(),
    keyHash: text('key_hash').notNull().unique(),
    keySalt: text('key_salt').notNull(),
    lastFour: text('last_four').notNull(),
    scopes: text('scopes').array().notNull().default([]),
    rateLimitTier: text('rate_limit_tier').notNull().default('standard'),
    expiresAt: timestamp('expires_at', { withTimezone: true }),
    lastUsedAt: timestamp('last_used_at', { withTimezone: true }),
    revokedAt: timestamp('revoked_at', { withTimezone: true }),
    ...timestamps,
  },
  (table) => [
    index('idx_api_keys_key_hash').on(table.keyHash),
    index('idx_api_keys_tenant').on(table.tenantId),
    index('idx_api_keys_user').on(table.userId),
  ]
)
```

**RLS:** After migration, call `SELECT create_tenant_rls_policy('api_keys')`.

**Schema export:** Add `export * from './api-key.schema.js'` to `apps/api/src/database/schema/index.ts`.

**Array default note:** If the Drizzle version requires `sql\`'{}'\`` for array defaults instead of `[]`, adjust accordingly. Verify by checking if any other `array()` column exists in the schema or testing the migration output.

### `audit_logs` table extension

Add an optional `api_key_id` column to the existing `audit_logs` table:

| Column | Type | Nullable | FK | ON DELETE |
|--------|------|----------|----|----------|
| `api_key_id` | `text` | Yes | `api_keys.id` | `SET NULL` |

**Rationale:** `ON DELETE SET NULL` preserves the audit trail even if a key row is eventually hard-deleted during purge. The `actorId` column (FK to `users.id`) continues to identify _who_ performed the action; `apiKeyId` identifies _which key_ was used or affected.

## Type Extensions

### `@repo/types` — `packages/types/src/audit.ts`

**Current `AuditActorType`:**
```typescript
export type AuditActorType = 'user' | 'system' | 'impersonation'
```

**V1 addition:**
```typescript
export type AuditActorType = 'user' | 'system' | 'impersonation' | 'api_key'
```

**Current `AuditAction`** (excerpt):
```typescript
export type AuditAction =
  | 'user.created'
  // ... existing actions
  | 'impersonation.ended'
```

**V1 additions:**
```typescript
  | 'api_key.created'
  | 'api_key.revoked'
```

Note: `api_key.rotated` is excluded from V1. Rotation is a non-goal (create-then-revoke pattern). Add it in a future slice if an atomic rotation endpoint is built.

**`AuditLogEntry` interface update:**
```typescript
export interface AuditLogEntry {
  // ... existing fields
  apiKeyId: string | null  // New — traceability for API key events
}
```

### `apps/api/src/auth/types.ts` — `AuthenticatedSession`

The `AuthenticatedSession` type stays in `apps/api` (not moved to `@repo/types`). V1 adds optional fields that V2 will populate at runtime.

**Current:**
```typescript
export type AuthenticatedSession = {
  user: { id: string; role?: Role }
  session: { id: string; activeOrganizationId?: string | null }
  permissions: string[]
}
```

**V1 additions:**
```typescript
export type AuthenticatedSession = {
  user: { id: string; role?: Role }
  session: { id: string; activeOrganizationId?: string | null }
  permissions: string[]
  actorType?: 'user' | 'api_key'    // New — undefined = 'user' (backward compat)
  apiKeyId?: string                  // New — set when actorType = 'api_key'
}
```

**Why optional:** All existing code that constructs `AuthenticatedSession` (e.g., `AuthService.getSession()`) continues to work without setting `actorType`. V2 (auth guard extension) will set both fields when authenticating via Bearer token. The `checkPermissions()` superadmin bypass in V2 will check `actorType !== 'api_key'` before early-returning.

## API Endpoints

All three endpoints are **session-authenticated** (the management UI uses cookie sessions, not API keys). They are internal admin endpoints, not public API routes.

### N1: `POST /api/api-keys`

Creates an API key for the current org.

**Auth:** Session + `@RequireOrg()` + `@Permissions('api_keys:write')`

Note: The `api_keys:write` permission must be added to the default org permissions during V1 implementation. This requires adding `api_keys:read` and `api_keys:write` to the RBAC seed.

**Request body:**
```typescript
{
  name: string               // Required, 1-100 chars
  scopes: string[]           // Required, subset of user's current permissions
  expiresAt?: string | null  // Optional, ISO 8601 datetime, must be in the future
}
```

**Validation:**
- `scopes` may be empty (key with no permissions — authenticates in V2 but all `@Permissions()` checks fail)
- Each scope string must exist in the user's current permissions for this org
- `expiresAt`, if provided, must be a valid future date

**Response (201):**
```typescript
{
  id: string
  name: string
  key: string              // Full key — shown ONCE. Never returned again.
  keyPrefix: string        // "sk_live_"
  lastFour: string
  scopes: string[]
  expiresAt: string | null
  createdAt: string
}
```

**Audit:** Log `api_key.created` with `resourceId: apiKey.id`, `actorId: session.user.id`, `apiKeyId: apiKey.id`.

### N2: `GET /api/api-keys`

Lists API keys for the current org.

**Auth:** Session + `@RequireOrg()` + `@Permissions('api_keys:read')`

**Response (200):**
```typescript
{
  data: Array<{
    id: string
    name: string
    keyPrefix: string
    lastFour: string
    scopes: string[]
    rateLimitTier: string
    expiresAt: string | null
    lastUsedAt: string | null
    revokedAt: string | null
    createdAt: string
  }>
}
```

Note: The full key and hash/salt are **never** returned in list responses.

### N3: `DELETE /api/api-keys/:id`

Revokes an API key (soft-delete via `revokedAt`).

**Auth:** Session + `@RequireOrg()` + `@Permissions('api_keys:write')`

**Validation:**
- Key must exist in the current org
- Key must not already be revoked (idempotent: return 200 if already revoked)

**Response (200):**
```typescript
{
  id: string
  revokedAt: string
}
```

**Audit:** Log `api_key.revoked` with `resourceId: apiKey.id`, `actorId: session.user.id`, `apiKeyId: apiKey.id`.

## UI Affordances

### U1: "API Keys" tab in personal settings

Add an "API Keys" tab to the personal settings navigation alongside "Profile" and "Account". Route: `/settings/api-keys`.

**Rationale:** API keys are created by and belong to a user, even though they're scoped to the active org. This follows the convention used by GitHub (PATs in user settings), Vercel (tokens in account settings), and Stripe (API keys in user-level dashboard). Users manage their own keys, not other members' keys.

**Org context:** The page shows keys for the user's currently active organization. If no org is active, show a message prompting the user to select an organization first.

**Permission gate:** The "API Keys" tab is only visible when the user has `api_keys:read` permission in their active org. Users without it who navigate directly to `/settings/api-keys` see an "insufficient permissions" message.

### U2: "Create API Key" button

Positioned at the top-right of the key list (or within the empty state). Standard primary button.

### U3: Create key form

Modal dialog (or slide-over) with:
- **Name** — text input, required, max 100 chars
- **Scopes** — checkbox group. Options are the user's current permissions for this org (fetched from session). Grouped by resource if possible (e.g., "Members: Read, Write", "Roles: Read, Write").
- **Expiry** — optional date picker. If omitted, key does not expire.

### U4: One-time key display

Post-creation dialog showing:
- The full key in a monospace `<code>` block
- A "Copy" button that copies to clipboard
- Warning text: "This key will not be shown again. Copy it now."
- A "Done" / "Close" button
- Closing the dialog removes the full key from memory and view

### U5: Key list table

| Column | Content |
|--------|---------|
| Name | Key name |
| Key | `sk_live_...xxxx` (prefix + last 4, masked middle) |
| Scopes | Permission badges (compact) |
| Created | Relative or absolute date |
| Last Used | Date or "Never" |
| Status | Badge: Active (green) / Expired (yellow) / Revoked (red) |
| Actions | "Revoke" button (disabled if already revoked) |

**Status derivation (evaluated in order — first match wins):**
1. `revokedAt` is set → "Revoked" (red) — revoked always wins, even if also expired
2. `expiresAt` is set and `expiresAt < now` → "Expired" (yellow)
3. Otherwise → "Active" (green)

### U6 + U7: Revoke button + confirmation

"Revoke" button in the actions column. Opens `DestructiveConfirmDialog` with:
- Title: "Revoke API Key"
- Message: "Revoke '{name}'? Any integrations using this key will stop working immediately."
- Confirm button: "Revoke"

After confirmation, the key row updates in-place (status badge → "Revoked", button disabled). No row removal.

## Cascade Revocation (N16)

### Approach: EventEmitter2 events

Add new event emissions to existing services. The `ApiKeyModule` subscribes and sets `revokedAt` on matching keys.

### New events

File: `apps/api/src/common/events/user-soft-deleted.event.ts`
```typescript
export const USER_SOFT_DELETED = 'user.soft-deleted' as const

export class UserSoftDeletedEvent {
  constructor(public readonly userId: string) {}
}
```

File: `apps/api/src/common/events/organization-soft-deleted.event.ts`
```typescript
export const ORGANIZATION_SOFT_DELETED = 'organization.soft-deleted' as const

export class OrganizationSoftDeletedEvent {
  constructor(public readonly organizationId: string) {}
}
```

### Emission points

**Important:** Emit events **after** the transaction commits, not inside it. This prevents the listener from running on a separate DB connection before the outer transaction commits (which could cause partial state if the transaction rolls back). This is consistent with the existing pattern — `ORGANIZATION_CREATED` is emitted outside the transaction in `AuthService`.

**`UserService.softDelete()`** — add after the transaction returns:
```typescript
const updated = await this.db.transaction(async (tx) => {
  // ... existing transaction logic ...
})
// After transaction commits:
await this.eventEmitter.emitAsync(
  USER_SOFT_DELETED,
  new UserSoftDeletedEvent(userId)
)
return updated
```

**`OrganizationService.softDelete()`** — add after the transaction returns:
```typescript
const updated = await this.db.transaction(async (tx) => {
  // ... existing transaction logic ...
})
await this.eventEmitter.emitAsync(
  ORGANIZATION_SOFT_DELETED,
  new OrganizationSoftDeletedEvent(orgId)
)
return updated
```

### Listener

File: `apps/api/src/api-key/api-key.listener.ts`

```typescript
@Injectable()
export class ApiKeyListener {
  @OnEvent(USER_SOFT_DELETED)
  async handleUserSoftDeleted(event: UserSoftDeletedEvent) {
    await this.apiKeyService.revokeAllForUser(event.userId)
  }

  @OnEvent(ORGANIZATION_SOFT_DELETED)
  async handleOrgSoftDeleted(event: OrganizationSoftDeletedEvent) {
    await this.apiKeyService.revokeAllForOrg(event.organizationId)
  }
}
```

Service methods set `revokedAt = now` on all matching active keys (WHERE `revokedAt IS NULL`).

## Audit Integration

API key events use the existing `AuditService` with:
- `actorId` = the session user's ID (valid FK to `users.id`)
- `actorType` = `'user'` (the admin performing the action, not `'api_key'`)
- `apiKeyId` = the affected key's ID (new column)
- `organizationId` = the current org

The `'api_key'` actor type is defined in V1 types but only used as `actorType` in V2 when the auth guard constructs synthetic sessions for API-key-authenticated requests.

**Implementation note:** `AuditService.log()` must be updated to accept and pass through the optional `apiKeyId` field. The `auditLogsRelations` in `audit.schema.ts` must also add an `apiKey` relation for the new FK.

## Technical Decisions

### SHA-256 for key hashing

**Decision:** Use HMAC-SHA-256 with a per-key random salt.

**Rationale:** API keys have ~190 bits of entropy (`sk_live_` + 32 base62 chars). Against a space this large, brute-force is computationally infeasible regardless of hash speed. SHA-256 is the right choice because:
1. High-entropy keys make slow KDFs (bcrypt, argon2) unnecessary
2. Fast hashing avoids adding latency to every authenticated request (V2)
3. Per-key salt prevents precomputed table attacks
4. `crypto.timingSafeEqual` for hash comparison prevents timing attacks

Do **not** substitute bcrypt or argon2 — they would add ~100ms per auth request with no security benefit for high-entropy keys.

**V2 lookup path:** Hash the presented key with the server-side HMAC → query `api_keys` by `key_hash` (UNIQUE index, single-row direct lookup) → `timingSafeEqual` for final comparison. The per-key salt is used during HMAC computation. No iteration over candidates.

### `user_id` ON DELETE CASCADE

**Decision:** The `api_keys.user_id` FK uses `ON DELETE CASCADE`.

**Rationale:** The `PurgeService` hard-deletes user rows after the 30-day grace period. Without cascade, the purge would fail with a FK violation. The cascade revocation event listener already sets `revokedAt` during soft-delete, so by purge time all keys are already revoked. Cascade-deleting the key rows during purge is safe — the `audit_logs.api_key_id` FK uses `ON DELETE SET NULL`, preserving the audit trail even after key rows are removed.

### Session-authenticated management endpoints (not public API)

**Decision:** N1-N3 are standard session-authenticated admin endpoints at `/api/api-keys`, not under the `/api/v1/` public API prefix.

**Rationale:** The management UI uses cookie sessions. The `/api/v1/` prefix and `@RequireApiKey()` decorator are V3 scope. V1 endpoints follow the existing admin pattern. V3 may add `GET /api/v1/api-keys` and `DELETE /api/v1/api-keys/:id` as public API mirrors.

### RBAC permissions for API key management

**Decision:** Add `api_keys:read` and `api_keys:write` to the RBAC permission set. Seed them into the default admin/owner roles.

**Rationale:** API key management is an org-level admin capability, not available to all members. The `owner` and `admin` roles should have both permissions by default. Custom roles can grant them selectively.

**Implementation:** (a) Add `api_keys:read` and `api_keys:write` to the permissions array in the RBAC constants/config, (b) add them to the default `owner` and `admin` role seeds in `RbacService.seedDefaultRoles()`. Check the existing RBAC seed pattern in `apps/api/src/rbac/`.

## Constraints

- **V1 does NOT wire the auth guard.** Keys can be created and managed but cannot authenticate requests until V2 (#319).
- **V1 does NOT implement rate limiting.** The `rateLimitTier` column exists but the throttler integration is V4 (#321).
- **`lastUsedAt` is always null in V1.** The V2 auth guard will update it on each key use (fire-and-forget).
- **`sk_test_` prefix is reserved but not implemented.** `keyPrefix` column always stores `sk_live_` in V1.
- **No key rotation endpoint.** Users rotate by creating a new key and revoking the old one.
- **No usage analytics.** `lastUsedAt` will be populated by V2 but no dashboard in V1.

## Non-goals

- Auth guard integration (V2, #319)
- Public API controllers (V3, #320)
- Per-key rate limiting (V4, #321)
- CLI (V5a/V5b, #322/#323)
- AI assistant (V6, #325-#327)
- Key rotation endpoint
- Usage analytics dashboard
- `sk_test_` sandbox keys
- Key pagination (not needed at <1K keys)

## Acceptance Criteria

### UI & UX
1. **CRUD via UI:** Users can create, list, and revoke API keys at `/settings/api-keys` (scoped to their active org)
2. **Key display:** Keys display `sk_live_...xxxx` (prefix + last 4 chars) in the list. Full key shown once on creation with a copy button and "will not be shown again" warning.
3. **Key creation dialog dismissal:** After closing the creation dialog, the full key is no longer accessible anywhere in the UI
4. **Scope filtering (UI):** Scopes selection UI shows checkboxes filtered to the user's current permissions in the active org
5. **Expiry date (optional):** Create form accepts an optional expiry date. Expired keys display a yellow "Expired" status badge.
6. **Status badges:** Key list shows correct status: "Active" (green), "Expired" (yellow), "Revoked" (red). A key that is both revoked and expired shows "Revoked".
7. **Revocation persistence:** Revoked keys remain visible in the list with "Revoked" badge and disabled revoke button (not removed from list)
8. **Empty state:** API Keys page shows an empty state with a CTA when no keys exist
9. **Permission gate:** "API Keys" settings tab only visible when user has `api_keys:read` in active org. Direct navigation to `/settings/api-keys` without permission shows an insufficient permissions message.

### API & Validation
10. **Scope validation (server):** `POST /api/api-keys` rejects with 400 if any requested scope exceeds the user's current permissions
11. **Expiry validation (server):** `POST /api/api-keys` rejects with 400 if `expiresAt` is in the past
12. **Revocation idempotency:** `DELETE /api/api-keys/:id` on an already-revoked key returns 200 (not an error)

### Data & Events
13. **Cascade revocation (user):** When a user is soft-deleted, all their API keys get `revokedAt` set immediately (event emitted after transaction commits)
14. **Cascade revocation (org):** When an org is soft-deleted, all its API keys get `revokedAt` set immediately (event emitted after transaction commits)
15. **Audit logging:** API key creation and revocation are logged in the audit trail with correct `actorId` (user FK), `actorType: 'user'`, and `apiKeyId`

### Types & Schema
16. **`AuditActorType`:** Extended with `'api_key'` in `packages/types/src/audit.ts`
17. **`AuditAction`:** Extended with `'api_key.created'` and `'api_key.revoked'` in `packages/types/src/audit.ts`
18. **`AuditLogEntry`:** Extended with `apiKeyId: string | null` in `packages/types/src/audit.ts`
19. **Session type:** `AuthenticatedSession` extended with optional `actorType` and `apiKeyId` fields in `apps/api/src/auth/types.ts` (type compiles without errors when fields are omitted — backward compat)
20. **Schema:** `api_keys` table created with all specified columns, indexes (`key_hash`, `tenant_id`, `user_id`), and RLS policy. `audit_logs` table extended with nullable `api_key_id` column (ON DELETE SET NULL). Schema exported from `index.ts`.
21. **RBAC permissions:** `api_keys:read` and `api_keys:write` added to permission constants and seeded into default `owner` and `admin` roles

## Open Questions

- **Empty scopes UX:** The create form allows submitting with zero scopes selected (edge case table says "Allowed"). Should the UI show a warning like "This key will have no permissions" before submission, or silently allow it? Current spec: silently allow. Implementer may add a non-blocking warning if it fits naturally.
