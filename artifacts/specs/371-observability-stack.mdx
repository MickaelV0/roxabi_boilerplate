---
title: "Production Observability & Analytics Stack"
issue: 371
tier: F-full
status: approved
date: 2026-02-26
---

## Context

Promoted from [analysis](../analyses/371-observability-stack.mdx). Shape 1 (Direct Integration) selected — each tool wired directly into the app where it's used, no shared package. Rationale: Vercel serverless deploys apps independently; Pino is backend-only, PostHog frontend-only, Sentry uses completely different SDKs per platform. See analysis §Fit Check.

**Frame:** [observability-stack](../frames/observability-stack.mdx) | **Analysis:** [371-observability-stack](../analyses/371-observability-stack.mdx) | **Issue:** #371

## Goal

Deliver a coherent production observability stack — structured logging, error tracking with alerting, consent-gated analytics with feature flags, performance regression catching in CI, and automatic audit capture — using Pino, Sentry, PostHog, web-vitals, and Lighthouse CI.

## Users

- **Developer:** Views structured logs for debugging, receives Sentry error alerts, evaluates feature flags in code, sees Lighthouse CI checks on PRs. Incident response flow: Slack alert → Sentry dashboard (stack trace + correlationId) → structured logs (full request context) → root cause
- **Product team:** Views PostHog analytics dashboards for feature adoption and user behavior
- **Admin:** Views auto-captured audit logs in admin panel (existing UI)
- **End user:** Benefits from faster bug detection; sees consent banner before analytics tracking

## Expected Behavior

### Local Dev (Zero Config)

A new developer clones the repo, runs `bun run dev`, and all observability tools degrade gracefully. Pino outputs colorized pretty logs. Sentry, PostHog, and Lighthouse CI are inactive — no errors, no network requests. The only observability-related env var needed locally is `LOG_LEVEL` (already in `.env.example`).

### Phase 1 — Structured Logging (Pino)

A developer starts the API in dev mode and sees human-readable, colorized logs via `pino-pretty`. In production (Vercel), logs output as structured JSON with every line containing `correlationId`, `method`, `url`, `statusCode`, and `responseTime` — auto-logged by `nestjs-pino`'s built-in HTTP request logging (`autoLogging: true`). The developer can control verbosity via `LOG_LEVEL=info|debug|warn|error`. All 23 existing `Logger` instances automatically use Pino — no code changes needed per service. The 4 manual `[${correlationId}]` prefixes in `allExceptions.filter.ts` and `consentException.filter.ts` are removed since Pino injects correlationId automatically via CLS.

### Phase 2 — Error Tracking + Alerting (Sentry)

**Backend:** Sentry is initialized via a dedicated `instrument.ts` file loaded before all other modules (using Node's `--import` flag or Bun equivalent). When an unhandled exception occurs, `SentryGlobalFilter` (outermost filter — registered after `AllExceptionsFilter` in the providers array, which NestJS executes in reverse order) captures it with full stack trace, correlationId tag, release tag (`VERCEL_GIT_COMMIT_SHA`), and sanitized request context, then re-throws so `AllExceptionsFilter` formats the user-facing response. The `beforeSend` hook strips Authorization headers, cookies, and request bodies. Source maps are uploaded in CI on main/staging pushes only (skipped on PRs), then deleted post-upload. Two separate upload invocations run — one for `apps/api` using `SENTRY_PROJECT_API`, one for `apps/web` using `SENTRY_PROJECT_WEB`.

**Frontend:** When a React component throws, the existing `react-error-boundary` renders the fallback UI while its `onError` callback sends the error to Sentry. For the Admin boundary (TanStack Router `errorComponent`, not `react-error-boundary`), `Sentry.captureException(error)` is called directly inside the component body since it receives `error` as a prop. This covers all 3 boundaries (root, admin, docs).

**Alerting:** Sentry is configured with alert rules: Rule 1 — first occurrence of new issue → Slack; Rule 2 — error rate > 10x 1hr rolling baseline → Slack + email.

**Graceful degradation:** When `SENTRY_DSN` / `VITE_SENTRY_DSN` is not set (local dev), Sentry is not initialized — no errors, no network requests. Environment field set from `VERCEL_ENV` (production/preview/development) with `NODE_ENV` fallback.

### Phase 3a — Product Analytics + Feature Flags (PostHog)

A user visits the app and sees the existing consent banner. If they grant analytics consent, `PostHogProvider` dynamically imports `posthog-js` and initializes it. `posthog.identify(userId, { email, orgId })` is called on authentication state change (login success). Core events are tracked: `$pageview`, `user_signed_up`, `user_logged_in`, `org_created`. If consent is denied or `VITE_POSTHOG_KEY` is absent, PostHog is never loaded — the chunk exists in the build but is never fetched (zero network requests).

A developer wraps a new feature in `useFeatureFlag('new-dashboard')`. The flag evaluates client-side via PostHog. When PostHog is not loaded (no consent or no key), the hook returns the provided default value. When PostHog is loaded but the API is unreachable, the hook returns the last cached value or the default. SSR pages render the default state and hydrate with the flag value — no server-side PostHog dependency (server-side feature flag evaluation is explicitly out of scope).

**Consent revocation:** When a user revokes analytics consent mid-session, `PostHogProvider` detects the consent change via `useConsentGate('analytics')` in a `useEffect`. It calls `posthog.reset()` to clear user data, then sets the PostHog client to null. Subsequent `usePostHog()` calls return null. On logout, `posthog.reset()` is also called (separate from consent).

### Phase 3b — Performance Monitoring (web-vitals + Lighthouse CI)

When PostHog is initialized (consent-gated), a `useWebVitals()` hook reports CLS, LCP, TTFB, and INP to PostHog as custom events. In dev mode, metrics are also logged to console. (Note: FID is removed in web-vitals v5 — INP replaces it.)

When a deploy preview is triggered (currently `workflow_dispatch` in `deploy-preview.yml`), a Lighthouse CI job runs as a post-deploy step against the preview URL. Since Vercel Deployment Protection may block unauthenticated requests, `lighthouserc.json` includes `x-vercel-protection-bypass` header using `VERCEL_AUTOMATION_BYPASS_SECRET`. Results are posted as a PR status check. Thresholds: performance ≥ 75, accessibility ≥ 90. Median of 3 runs to reduce flakiness. The `deploy-preview.yml` permissions block is updated with `statuses: write`.

### Phase 4 — Audit Auto-Capture (Interceptor)

When an admin performs a mutation (create/update/delete member, role, invitation, etc.), the `@AuditLog({ action: AuditAction.UPDATE_MEMBER, resource: { type: 'member', idParam: 'memberId' } })` decorator on the endpoint handler triggers a NestJS interceptor. The interceptor reads the entity (using the `idParam` from the route params and a generic repository lookup) before the handler runs, lets the handler execute, then reads the entity after — logging both states to the `audit_logs` table. If the pre-read fails (entity not found), the interceptor logs `before: null` and proceeds. If the handler throws, the interceptor does not write an audit entry (failed mutations are not audited).

Existing 4 production call sites (`adminMembers.service.ts`, `adminInvitations.service.ts`, `adminOrganizations.service.ts`, `adminUsers.service.ts`) and their ~9 test assertions are migrated to the decorator pattern. The existing admin audit log UI shows these auto-captured entries without changes — the schema is compatible (same `before`/`after` JSONB columns).

## Breadboard

### Phase 1: Pino Structured Logging

| ID | Affordance | Location | Handler | Data |
|----|-----------|----------|---------|------|
| N1 | LoggerModule.forRootAsync() | `apps/api/src/app.module.ts` | nestjs-pino registers as global NestJS Logger. `autoLogging: true` for HTTP request logs | CLS correlationId, LOG_LEVEL, pino-pretty (dev) / JSON (prod) |
| N2 | FastifyAdapter logger removal | `apps/api/src/index.ts:101-103` | Remove `logger: { level }` from adapter config | nestjs-pino takes over all logging |
| N3 | Manual correlationId cleanup | 4 occurrences in `allExceptions.filter.ts` (lines 84, 131) and `consentException.filter.ts` (lines 27, 33) | Remove `[${correlationId}]` from log template strings | CLS auto-injects — duplicates removed |

### Phase 2: Sentry Error Tracking + Alerting

| ID | Affordance | Location | Handler | Data |
|----|-----------|----------|---------|------|
| N4 | Sentry instrument file | `apps/api/src/instrument.ts` (new) | `Sentry.init()` loaded via `--import` before all other modules | SENTRY_DSN, VERCEL_ENV, VERCEL_GIT_COMMIT_SHA |
| N5 | SentryGlobalFilter (outermost) | `apps/api/src/app.module.ts` | Captures exceptions → Sentry, re-throws | Registered AFTER AllExceptionsFilter in providers array (NestJS reverses execution order → outermost) |
| N6 | beforeSend PII sanitizer | `apps/api/src/instrument.ts` Sentry config | Strips Authorization, cookies, request bodies | Allowlist: correlationId, url, method, statusCode |
| N7 | Sentry.flush() on shutdown | `apps/api/src/index.ts` | Flushes event queue before serverless exit | 2000ms timeout. SentryModule in AppModule for lifecycle hook |
| N8 | Source map upload (CI) | `.github/workflows/ci.yml` build job | Two `@sentry/cli` invocations (API + Web) + delete. Gated to push events (main/staging) | SENTRY_AUTH_TOKEN, SENTRY_ORG, SENTRY_PROJECT_API, SENTRY_PROJECT_WEB |
| N14 | turbo.jsonc cache config | `turbo.jsonc` | Add `SENTRY_AUTH_TOKEN` to `globalPassThroughEnv`; `SENTRY_ORG`, `SENTRY_PROJECT_*` to `build.env` | Cache correctness — prevents skipping uploads after cache hit |
| N15 | Sentry release tagging | `apps/api/src/instrument.ts` + `apps/web/src/lib/sentry/` | `release: VERCEL_GIT_COMMIT_SHA` in both apps. CI upload tagged with same SHA | Release must match between events and source maps |
| U1 | @sentry/react init | `apps/web/src/lib/sentry/` (new) | Initialize browser Sentry | VITE_SENTRY_DSN, VERCEL_ENV, VERCEL_GIT_COMMIT_SHA |
| U2a | Root + Docs ErrorBoundary onError | `__root.tsx`, `DocsErrorBoundary.tsx` | `onError={(error) => Sentry.captureException(error)}` | react-error-boundary `onError` prop |
| U2b | Admin ErrorBoundary (TanStack) | `admin.tsx` | `Sentry.captureException(error)` called directly in component body | TanStack Router `errorComponent` — no `onError` prop |
| S1 | Sentry Alert rules | Sentry dashboard (manual) | Rule 1: first new issue → Slack. Rule 2: error rate >10x 1hr baseline → Slack + email | Screenshot in PR description for verification |
| N16 | CSP connectSrc update | `apps/api/src/index.ts` Helmet config | Add `*.ingest.sentry.io` to `connectSrc` | Required for Sentry browser events to pass CSP |

### Phase 3a: PostHog Analytics + Feature Flags

| ID | Affordance | Location | Handler | Data |
|----|-----------|----------|---------|------|
| U3 | PostHogProvider | `apps/web/src/lib/posthog/PostHogProvider.tsx` (new) | Dynamic import on consent grant via `useEffect` watching `useConsentGate('analytics')`. Teardown: `posthog.reset()` + set client null on revoke | VITE_POSTHOG_KEY, VITE_POSTHOG_HOST |
| U4 | usePostHog() hook | `apps/web/src/lib/posthog/usePostHog.ts` (new) | Returns PostHog client or null (no consent / no key) | For manual `posthog.capture()` calls |
| U5 | useFeatureFlag(key, default) hook | `apps/web/src/lib/posthog/useFeatureFlag.ts` (new) | Evaluates flag client-side. Returns default when PostHog not loaded or API unreachable (uses cached value if available) | boolean or string variant |
| U6 | Core event tracking | `apps/web/src/routes/auth/login.tsx`, `signup.tsx`, `__root.tsx` (pageview), org creation route | `posthog.capture()` calls at key actions | `$pageview`, `user_signed_up`, `user_logged_in`, `org_created` |
| U9 | posthog.identify() | Auth state change (login success) | `posthog.identify(userId, { email, orgId })` | Called on login; `posthog.reset()` on logout |
| U7 | Provider stack placement | `apps/web/src/routes/__root.tsx` | After ConsentProvider, before ErrorBoundary | Reads consent context |
| U10 | CSP connectSrc update | `apps/api/src/index.ts` Helmet config | Add PostHog host (`app.posthog.com` or custom) to `connectSrc` | Required for PostHog events to pass CSP |

### Phase 3b: web-vitals + Lighthouse CI

| ID | Affordance | Location | Handler | Data |
|----|-----------|----------|---------|------|
| U8 | useWebVitals() hook | `apps/web/src/lib/web-vitals/useWebVitals.ts` (new) | `onCLS`, `onLCP`, `onTTFB`, `onINP` → PostHog custom events. Console.log in dev | Metric name + value + rating (no FID — removed in v5) |
| N9 | lighthouserc.json | Root project | Lighthouse CI config: URLs, thresholds, assertions. `extraHeaders: { x-vercel-protection-bypass }` | perf ≥ 75, a11y ≥ 90, 3 runs, VERCEL_AUTOMATION_BYPASS_SECRET |
| N10 | Lighthouse CI job | `.github/workflows/deploy-preview.yml` | Post-deploy step after `deploy-web`. Uses `steps.deploy.outputs.url`. `permissions: statuses: write` | LHCI results → PR status check. Runs on workflow_dispatch (same trigger as deploy) |

### Phase 4: Audit Auto-Capture

| ID | Affordance | Location | Handler | Data |
|----|-----------|----------|---------|------|
| N11 | @AuditLog() decorator | `apps/api/src/audit/audit.decorator.ts` (new) | `@AuditLog({ action: AuditAction.X, resource: { type: 'member', idParam: 'memberId' } })` | action (AuditAction enum), resource type + idParam for entity lookup |
| N12 | AuditInterceptor | `apps/api/src/audit/audit.interceptor.ts` (new) | Before: read entity by idParam. After: read entity. Diff → audit_logs. Pre-read fails → `before: null`. Handler throws → no audit entry | actorId from CLS, before/after JSONB |
| N13 | Manual call migration | `adminMembers.service.ts`, `adminInvitations.service.ts`, `adminOrganizations.service.ts`, `adminUsers.service.ts` + ~9 test assertions | Replace `auditService.log()` with `@AuditLog()` decorator on controller handlers. Update test mocks | 4 production call sites + test rewrites |

## Slices

| # | Slice | Scope (IDs) | Dependencies | Tier | Size |
|---|-------|-------------|-------------|------|------|
| 1 | Pino structured logging | N1, N2, N3 | None | S | S |
| 2 | Sentry backend + CI + alerting | N4, N5, N6, N7, N8, N14, N15, N16, S1 | Slice 1 (recommended, soft — structured log context) | F-lite | M |
| 3 | Sentry frontend | U1, U2a, U2b | Slice 2 (shared SENTRY_ORG/CI config — coordinate to avoid merge conflicts) | S | S |
| 4 | PostHog analytics + feature flags | U3, U4, U5, U6, U7, U9, U10 | None (consent framework exists) | F-lite | M |
| 5 | web-vitals + Lighthouse CI | U8, N9, N10 | Slice 4 (PostHog as metrics destination) | S | S |
| 6 | Audit auto-capture interceptor | N11, N12, N13 | Slice 1 (soft — structured logs for debugging) | F-lite | M |

Slices 2+3 sequential (shared CI touchpoint). Slices 4+5 sequential (5 needs PostHog). Slice 6 independent after Slice 1.

## Success Criteria

### Slice 1 — Pino
- [ ] `nestjs-pino` registered in AppModule; all 23 Logger instances output via Pino
- [ ] Production logs are structured JSON with `correlationId`, `method`, `url`, `statusCode`, `responseTime` (auto-logged by nestjs-pino)
- [ ] Dev logs use `pino-pretty` with colorized, human-readable output
- [ ] `LOG_LEVEL` env var controls verbosity (debug/info/warn/error)
- [ ] 4 manual `[${correlationId}]` prefixes removed (`allExceptions.filter.ts:84,131`, `consentException.filter.ts:27,33`) — verified by grep returning 0 results
- [ ] `FastifyAdapter` logger config removed from `index.ts`
- [ ] Full test suite (`bun run test`) passes — Logger mock updates if needed

### Slice 2 — Sentry Backend
- [ ] `instrument.ts` file created with `Sentry.init()`, loaded via `--import` flag (or Bun equivalent) before all other modules
- [ ] `SentryGlobalFilter` registered as APP_FILTER after `AllExceptionsFilter` in providers array (NestJS reverses execution order → outermost)
- [ ] `SentryModule` (or lifecycle hook) registered in AppModule for shutdown flush
- [ ] Unhandled exceptions appear in Sentry with `correlationId` tag, stack trace, and matching release tag — manually verified via test error in preview deployment
- [ ] `beforeSend` strips Authorization headers, cookies, and request bodies from events
- [ ] Sentry `release` set to `VERCEL_GIT_COMMIT_SHA`; `environment` set from `VERCEL_ENV` with `NODE_ENV` fallback
- [ ] Source map upload gated to push events (main/staging) — skipped on PRs
- [ ] Two separate `@sentry/cli` upload invocations: `SENTRY_PROJECT_API` and `SENTRY_PROJECT_WEB`
- [ ] Source maps deleted from build output after upload
- [ ] `await Sentry.flush(2000)` called before serverless function exit
- [ ] Sentry disabled gracefully when `SENTRY_DSN` not set (no errors, no network requests)
- [ ] Sentry Alert rules configured: screenshot of rules in PR description
- [ ] `SENTRY_DSN` added to `.env.example` (commented, optional)
- [ ] `SENTRY_AUTH_TOKEN`, `SENTRY_ORG`, `SENTRY_PROJECT_API`, `SENTRY_PROJECT_WEB` documented as CI secrets
- [ ] `turbo.jsonc`: `SENTRY_AUTH_TOKEN` in `globalPassThroughEnv`; `SENTRY_ORG`, `SENTRY_PROJECT_API`, `SENTRY_PROJECT_WEB` in `build.env` (note: `VITE_*` already covered by wildcard)
- [ ] CSP `connectSrc` updated with `*.ingest.sentry.io` in Helmet config
- [ ] `SENTRY_AUTH_TOKEN` added to `build` job `env:` block in `ci.yml`

### Slice 3 — Sentry Frontend
- [ ] `@sentry/react` initialized in `apps/web/src/lib/sentry/` when `VITE_SENTRY_DSN` is set
- [ ] Sentry `release` set to `VERCEL_GIT_COMMIT_SHA`; `environment` from `VERCEL_ENV`
- [ ] Root + Docs ErrorBoundaries (`__root.tsx`, `DocsErrorBoundary.tsx`) wire `onError` → `Sentry.captureException()`
- [ ] Admin ErrorBoundary (`admin.tsx`, TanStack Router `errorComponent`) calls `Sentry.captureException(error)` directly in component body
- [ ] Frontend errors appear in Sentry with browser context — manually verified via test error in preview deployment
- [ ] Sentry disabled gracefully when `VITE_SENTRY_DSN` not set
- [ ] `VITE_SENTRY_DSN` and `SENTRY_PROJECT_WEB` added to `.env.example`

### Slice 4 — PostHog Analytics + Feature Flags
- [ ] `PostHogProvider` dynamically imports `posthog-js` only when `useConsentGate('analytics')` returns true (via `useEffect` watching consent state)
- [ ] PostHog chunk not fetched when consent denied (verified via Network tab)
- [ ] PostHog not initialized when `VITE_POSTHOG_KEY` is absent (local dev)
- [ ] `posthog.identify(userId, { email, orgId })` called on login success
- [ ] `posthog.reset()` called on logout (separate from consent revocation)
- [ ] Core events tracked: `$pageview`, `user_signed_up`, `user_logged_in`, `org_created`
- [ ] `usePostHog()` hook returns PostHog client or null
- [ ] `useFeatureFlag(key, defaultValue)` hook returns default when PostHog not loaded; returns cached value when PostHog API unreachable
- [ ] On consent revocation: `posthog.reset()` called, client set to null, subsequent `usePostHog()` returns null
- [ ] SSR pages render default state; flags hydrate client-side (no server-side PostHog)
- [ ] CSP `connectSrc` updated with PostHog host in Helmet config
- [ ] `VITE_POSTHOG_KEY` and `VITE_POSTHOG_HOST` (commented, optional, default shown) added to `.env.example`

### Slice 5 — web-vitals + Lighthouse CI
- [ ] `useWebVitals()` hook reports CLS, LCP, TTFB, INP to PostHog as custom events (no FID — removed in web-vitals v5)
- [ ] web-vitals only reports when PostHog is initialized (consent-gated)
- [ ] Dev mode: metrics also logged to console
- [ ] `lighthouserc.json` with thresholds: performance ≥ 75, accessibility ≥ 90
- [ ] `lighthouserc.json` includes `x-vercel-protection-bypass` header via `VERCEL_AUTOMATION_BYPASS_SECRET`
- [ ] Lighthouse CI runs as post-deploy step in `deploy-preview.yml` using preview URL from deploy output
- [ ] `deploy-preview.yml` permissions includes `statuses: write`
- [ ] Lighthouse results posted as PR status check
- [ ] Lighthouse uses median of 3 runs

### Slice 6 — Audit Auto-Capture
- [ ] `@AuditLog({ action: AuditAction.X, resource: { type, idParam } })` decorator available for controller handlers
- [ ] `AuditInterceptor` reads entity by `idParam` from route params before handler, reads after handler, logs diff to `audit_logs`
- [ ] If pre-read fails (entity not found): interceptor logs `before: null` and proceeds
- [ ] If handler throws: interceptor does not write an audit entry (failed mutations not audited)
- [ ] 4 production call sites migrated from manual `auditService.log()` to `@AuditLog()` decorator
- [ ] ~9 test assertions updated to test interceptor behavior instead of manual audit calls
- [ ] No double-logging: manual calls removed after decorator migration
- [ ] Auto-captured audit entries visible in existing admin audit log UI (schema compatible — same before/after JSONB)
- [ ] Interceptor uses `actorId` from CLS context

## Non-Goals (Explicit)

- Server-side feature flag evaluation (avoids server-side PostHog SDK, cold start latency)
- A/B testing / experimentation framework (feature flags only, not experiments)
- Typed feature flag key registry (free-form strings for now; type safety deferred)
- Automatic `pull_request` trigger for Lighthouse CI (runs on `workflow_dispatch` with deploy preview; auto-PR trigger deferred to avoid expensive deploys on every PR)
