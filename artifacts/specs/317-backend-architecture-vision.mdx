---
title: Backend Architecture Vision — DDD + Hexagonal
issue: 317
status: approved
tier: F-full
date: 2026-02-27
---

## Context

Promoted from analysis `artifacts/analyses/317-backend-architecture-vision.mdx`.
Frame: `artifacts/frames/backend-architecture-vision.mdx`.
Shape selected: **Shape 1 — Unified Vision Document** (decision criteria first, single MDX file).

Pre-spec clarifications resolved:
- **Location:** `docs/architecture/backend-ddd-hexagonal.mdx` (new file in existing `docs/architecture/` directory)
- **Migration guide:** single module — `rbac` — step-by-step (not full-codebase prescription)
- **Code examples:** illustrative TypeScript (compilable but simplified — not extracted from production files)

## Goal

Publish a single architecture vision document (`docs/architecture/backend-ddd-hexagonal.mdx`) that gives Roxabi developers and AI agents clear adoption criteria, target-state patterns, and a step-by-step migration guide for DDD and Hexagonal Architecture.

## Users

- **Primary:** Developers forking Roxabi who encounter a module that has outgrown CRUD and need an upgrade path
- **Secondary:** Claude Code (AI agent) — uses the document as a generative reference to produce architecturally consistent backend code
- **Secondary:** New contributors onboarding to the boilerplate

## Expected Behavior

A developer opens the document and encounters, in this order:

1. **Overview** — A short statement of what the document is and isn't: aspirational target patterns, not a mandate. The current codebase is CRUD-first by design; this doc describes the direction to evolve *when warranted*.

2. **When to Adopt** — A decision criteria table (the dominant section, placed early). Rows map observable module-level signals to recommended pattern levels. Examples: "module has >3 operations with domain pre-conditions → add value objects"; "module calls >1 external service that may be swapped → define a port"; "module owns >2 aggregates with cross-aggregate invariants → define bounded context". The table enables a quick self-assessment: "where is my module on this spectrum?"

3. **Current Baseline** — A brief inventory of DDD/Hexagonal-adjacent patterns that already exist in the boilerplate: `EmailProvider` as a proto-port, 4 domain events in `src/common/events/`, ~40+ domain exception files, `RbacListener` as a cross-module event consumer. These are the anchors — the doc explicitly starts from what exists, not from abstract theory.

4. **DDD Patterns** — Target-state patterns, each with a short description, rationale, and illustrative TypeScript snippet:
   - Branded types / value objects (`UserId`, `RoleSlug` — prevent primitive obsession)
   - Domain entities (thin wrapper around state with identity)
   - Aggregates (`OrganizationAggregate` — root with invariant enforcement)
   - Domain services (stateless operations that span multiple entities)
   - Application Service layer (orchestration tier: validate input → load aggregate via repository port → call domain method → persist via port → publish events; **transaction boundaries belong here**, not in domain methods or aggregates)

5. **Hexagonal Patterns** — Target-state patterns:
   - Concentric ring layer diagram (Domain → Application → Infrastructure — Mermaid)
   - Port definition (interface in domain layer, `Symbol` token, located at `feature/ports/` not inside `feature/`)
   - Adapter definition (implementation in infrastructure layer, `useClass` in module)
   - Repository as port: `UserRepository` port in domain, `DrizzleUserRepository` adapter in infrastructure
   - Anti-Corruption Layer: translating Better Auth session/user models into local domain types at module boundaries
   - Shared Kernel guidance: what belongs in `@repo/types` (cross-BC value types) vs. per-module domain vs. per-BC exceptions. Use the real duplication in the codebase as the motivating example: `admin/exceptions/orgNotFound.exception.ts` and `organization/exceptions/orgNotFound.exception.ts` are semantically identical — this is the problem shared kernel guidance solves.

6. **What Does NOT Belong in the Domain Layer** — An explicit negative-space section. NestJS decorators (`@Injectable`, `@Controller`), HTTP types (`FastifyRequest`), Drizzle ORM types, transaction coordination (`db.transaction()`, `tenantService.query()`) — all infrastructure concerns that must not leak into domain classes.

7. **Unified Architecture** — How DDD + Hexagonal work together in a single flow diagram. Shows: HTTP controller → Application Service → load aggregate via Repository port → aggregate enforces invariant → Application Service persists via port (transaction here) → emit domain event → adapter persists → cross-BC event listener (e.g., `RbacListener`). Example: `CreateRole` use case.

8. **Migration Guide — rbac module** — Step-by-step path from current CRUD to target architecture, using `rbac` as the worked example:
   - Step 1: Add branded types (`RoleId`, `RoleSlug`, `OrganizationId`)
   - Step 2: Domain exceptions — already in place in `rbac/exceptions/`; note the pattern is correct, reinforce why
   - Step 3: Add `RoleRepository` port (interface in `rbac/ports/`) + `DrizzleRoleRepository` adapter (in `rbac/adapters/`)
   - Step 4: Restructure `RbacService` → `RbacApplicationService`: extract Drizzle queries into the repository adapter; the application service orchestrates via the port. **Do not add a new service layer above the current one — restructure it.** Transaction coordination (`tenantService.query()`) stays in the application service, not in the aggregate.
   - Step 5: Introduce new domain events emitted at the aggregate boundary (e.g., `RoleCreated`, `RoleDeleted`). **Note:** the current `rbac` module does not emit events — this is a forward-looking step, not a relocation of existing emissions.
   - Common mistakes to avoid: Drizzle imports in domain classes; calling `tenantService.query()` from aggregates; placing `@Injectable()` or `@Controller()` decorators on domain entities; using HTTP types inside application services.

A Claude Code agent reading this document can answer: "Should I add a value object here?" by consulting the decision table. It can answer: "What does a port look like?" by copying the illustrative snippet. It can answer: "Where does the transaction go?" by reading the not-in-domain-layer section.

## Deliverable File

```
docs/architecture/backend-ddd-hexagonal.mdx    ← primary deliverable (new file)
docs/architecture/meta.json                     ← add "backend-ddd-hexagonal" to pages array (after "index")
docs/architecture/index.mdx                     ← add entry linking to new doc
docs/standards/backend-patterns.mdx             ← add cross-reference in the "Code Organization" section intro
```

**Cross-reference placement guidance:**
- `backend-patterns.mdx` → add a note near the top of section `1.1 Code Organization`: *"For guidance on adopting DDD and Hexagonal patterns as domain complexity grows, see [Backend Architecture Vision](../architecture/backend-ddd-hexagonal)."*
- `docs/architecture/index.mdx` → add a new row or section entry linking to `./backend-ddd-hexagonal`

**Illustrative TypeScript guidance for implementers:**
Code examples must be type-correct TypeScript but are simplified — not extracted from production files. They may omit error handling with a `// error handling omitted for brevity` comment. Use real module names where they exist (`RoleId`, `RoleRepository`, `OrganizationId`); invent minimal examples for patterns not yet implemented. Each snippet should be ≤30 lines; the Application Service snippet may be up to 40 lines given the orchestration complexity.

## Slices

| # | Slice | Sections covered | Independently reviewable? |
|---|-------|-----------------|--------------------------|
| 1 | Decision framework | Overview + When to Adopt | Yes — criteria table is standalone value |
| 2 | Current baseline + DDD patterns | Current Baseline + DDD Patterns (branded types → application service) | Yes — anchored in real code |
| 3 | Hexagonal patterns | Hexagonal Patterns (ring diagram, ports, ACL, shared kernel) + What NOT to put in domain layer | Yes — structural section |
| 4 | Unified flow + migration | Unified Architecture + Migration Guide (rbac) | Depends on slices 2–3 |

## Success Criteria

### Deliverables
- [ ] `docs/architecture/backend-ddd-hexagonal.mdx` exists and is valid MDX (no broken imports, renders without error)
- [ ] `docs/architecture/meta.json` includes `"backend-ddd-hexagonal"` in its `pages` array
- [ ] `docs/architecture/index.mdx` includes an entry linking to `backend-ddd-hexagonal`
- [ ] `docs/standards/backend-patterns.mdx` contains a cross-reference link to the new doc in the Code Organization section

### Structure + Content
- [ ] **When to Adopt** section is positioned as section 2 (immediately after Overview) with a decision criteria table of ≥5 rows covering distinct thresholds (value objects, ports, aggregates, bounded contexts, ACL)
- [ ] Every DDD pattern (branded types, value objects, entities, aggregates, domain services, application service) has an illustrative TypeScript snippet (≤30 lines; application service may be ≤40 lines)
- [ ] Every Hexagonal pattern (port, adapter, repository, ACL, shared kernel) has an illustrative TypeScript snippet ≤30 lines
- [ ] A Mermaid concentric-ring layer diagram (Domain → Application → Infrastructure) is present in the Hexagonal Patterns section
- [ ] A Mermaid flow diagram showing the full CreateRole use case (controller → app service → repository port → adapter → emit event → cross-BC event listener) is present in the Unified Architecture section
- [ ] The Migration Guide uses `rbac` as its primary example with ≥5 numbered steps, including an explicit note that Step 5 (event emission) is forward-looking (new events, not relocated)
- [ ] The "What Does NOT Belong in the Domain Layer" section explicitly lists NestJS decorators, Drizzle ORM types, and HTTP types as prohibited concerns
- [ ] Domain-layer code snippets contain no imports from `drizzle-orm`, `@nestjs/*`, or `fastify`; infrastructure snippets are labelled as such
- [ ] The Shared Kernel section uses the `admin/exceptions/orgNotFound` vs `organization/exceptions/orgNotFound` duplication as the motivating example
- [ ] No `[NEEDS CLARIFICATION]` markers remain in the final deliverable
