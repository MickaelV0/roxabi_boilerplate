---
title: "Atomic Workflow Orchestrator (/dev)"
description: Decompose monolithic skills into atomic steps with a /dev orchestrator that tracks progress via artifact-based state detection.
status: draft
---

## Workflow Diagram

```mermaid
flowchart TD
    START(["/dev #42"]) --> SCAN["üîç Scan artifacts<br/><i>parallel, &lt;3s</i>"]
    SCAN --> PROGRESS["üìä Display progress bar"]
    PROGRESS --> NEXT{"Next step?"}

    %% ‚îÄ‚îÄ‚îÄ FRAME PHASE ‚îÄ‚îÄ‚îÄ
    NEXT --> |"Frame"| TRIAGE

    subgraph FRAME ["üü¶ Frame"]
        direction TB
        TRIAGE["/issue-triage<br/>Create/enrich GitHub issue"]
        TRIAGE --> FRAMING["/frame<br/>Problem ¬∑ Who ¬∑ Constraints ¬∑ Scope"]
        FRAMING --> |"üìÑ artifacts/frames/slug.mdx"| FRAME_GATE{"üö¶ GATE<br/>Approve frame?"}
        FRAME_GATE --> |"‚úÖ Approved"| FRAME_DONE([Frame ‚úì])
        FRAME_GATE --> |"‚úèÔ∏è Revise"| FRAMING
    end

    %% ‚îÄ‚îÄ‚îÄ SHAPE PHASE ‚îÄ‚îÄ‚îÄ
    FRAME_DONE --> TIER_CHECK{"Tier?"}

    subgraph SHAPE ["üü® Shape"]
        direction TB
        ANALYZE["/analyze<br/>Exploration ¬∑ Risks ¬∑ Alternatives"]
        ANALYZE --> |"üìÑ artifacts/analyses/N-slug.mdx"| ANALYZE_DONE([Analysis ‚úì])
        ANALYZE_DONE --> SPEC_STEP
        SPEC_STEP["/spec<br/>Criteria ¬∑ Breadboard ¬∑ Slices"]
        SPEC_STEP --> |"üìÑ artifacts/specs/N-slug.mdx"| SPEC_GATE{"üö¶ GATE<br/>Approve spec?"}
        SPEC_GATE --> |"‚úÖ Approved"| SHAPE_DONE([Shape ‚úì])
        SPEC_GATE --> |"‚úèÔ∏è Revise"| SPEC_STEP
    end

    TIER_CHECK --> |"S-tier"| BUILD_DIRECT["Skip to implement"]
    TIER_CHECK --> |"F-lite"| SPEC_STEP
    TIER_CHECK --> |"F-full"| ANALYZE

    %% ‚îÄ‚îÄ‚îÄ BUILD PHASE ‚îÄ‚îÄ‚îÄ
    SHAPE_DONE --> PLAN_STEP
    BUILD_DIRECT --> IMPLEMENT

    subgraph BUILD ["üü© Build"]
        direction TB
        PLAN_STEP["/plan<br/>Tasks ¬∑ Agents ¬∑ Dependencies"]
        PLAN_STEP --> |"üìÑ artifacts/plans/N-slug.mdx"| PLAN_GATE{"üö¶ GATE<br/>Approve plan?"}
        PLAN_GATE --> |"‚úÖ Approved"| IMPLEMENT
        PLAN_GATE --> |"‚úèÔ∏è Modify"| PLAN_STEP
        IMPLEMENT["/implement<br/>Worktree ¬∑ Agents ¬∑ RED‚ÜíGREEN‚ÜíREFACTOR"]
        IMPLEMENT --> |"üìÅ Code + tests in worktree"| IMPL_DONE([Implement ‚úì])
        IMPL_DONE --> PR_STEP["/pr<br/>Commit ¬∑ Push ¬∑ Create PR"]
        PR_STEP --> |"üîó GitHub PR"| BUILD_DONE([Build ‚úì])
    end

    %% ‚îÄ‚îÄ‚îÄ VERIFY PHASE ‚îÄ‚îÄ‚îÄ
    BUILD_DONE --> VALIDATE

    subgraph VERIFY ["üüß Verify"]
        direction TB
        VALIDATE["/validate<br/>Lint ¬∑ Typecheck ¬∑ Test ¬∑ i18n"]
        VALIDATE --> |"‚úÖ Pass"| REVIEW
        VALIDATE --> |"‚ùå Fail"| FIX_VAL["Fix & re-validate"]
        FIX_VAL --> VALIDATE
        REVIEW["/review<br/>Multi-agent review ¬∑ Findings"]
        REVIEW --> REVIEW_CHECK{"Findings?"}
        REVIEW_CHECK --> |"0 findings"| VERIFY_DONE([Verify ‚úì])
        REVIEW_CHECK --> |"Has findings"| FIX_STEP["/fix<br/>Auto-apply + /1b1 + Fixers"]
        FIX_STEP --> REVALIDATE["/validate<br/>Confirm fixes"]
        REVALIDATE --> VERIFY_DONE
    end

    %% ‚îÄ‚îÄ‚îÄ SHIP PHASE ‚îÄ‚îÄ‚îÄ
    VERIFY_DONE --> PROMOTE

    subgraph SHIP ["üü• Ship"]
        direction TB
        PROMOTE["/promote<br/>Version ¬∑ Changelog ¬∑ Merge"]
        PROMOTE --> |"üè∑Ô∏è Tag + Release"| CLEANUP["/cleanup<br/>Branches ¬∑ Worktrees"]
        CLEANUP --> SHIP_DONE([Ship ‚úì])
    end

    SHIP_DONE --> COMPLETE(["‚úÖ Done"])

    %% ‚îÄ‚îÄ‚îÄ STYLING ‚îÄ‚îÄ‚îÄ
    classDef gate fill:#ff6b6b,stroke:#333,color:#fff
    classDef artifact fill:#4ecdc4,stroke:#333,color:#fff
    classDef skip fill:#95a5a6,stroke:#333,color:#fff
    classDef phase fill:#667eea,stroke:#333,color:#fff

    class FRAME_GATE,SPEC_GATE,PLAN_GATE gate
    class BUILD_DIRECT,TIER_CHECK skip
```

### Legend

| Symbol | Meaning |
|--------|---------|
| üö¶ **GATE** | Pause ‚Äî requires user approval before continuing |
| üìÑ `artifacts/...` | Artifact written to disk (state marker) |
| üìÅ Code + tests | Files created in worktree |
| üîó GitHub PR | External resource created |
| üè∑Ô∏è Tag + Release | Git tag + GitHub release |
| ‚û°Ô∏è No gate | Auto-advance (orchestrator proceeds without pause) |
| Dashed skip | Step skipped based on tier/conditions |

### Skip Rules by Tier

```mermaid
flowchart LR
    subgraph S ["S-tier (‚â§3 files)"]
        S1["triage"] --> S2["implement"] --> S3["pr"] --> S4["validate"] --> S5["review"]
    end

    subgraph FL ["F-lite (clear scope)"]
        FL1["triage"] --> FL2["frame üö¶"] --> FL3["spec üö¶"] --> FL4["plan üö¶"]
        FL4 --> FL5["implement"] --> FL6["pr"] --> FL7["validate"]
        FL7 --> FL8["review"] --> FL9["fix"] --> FL10["promote"]
    end

    subgraph FF ["F-full (complex)"]
        FF1["triage"] --> FF2["frame üö¶"] --> FF3["analyze"] --> FF4["spec üö¶"]
        FF4 --> FF5["plan üö¶"] --> FF6["implement"] --> FF7["pr"]
        FF7 --> FF8["validate"] --> FF9["review"] --> FF10["fix"]
        FF10 --> FF11["validate"] --> FF12["promote"] --> FF13["cleanup"]
    end

    style S fill:#27ae60,color:#fff
    style FL fill:#f39c12,color:#fff
    style FF fill:#e74c3c,color:#fff
```

---

## Context

The current dev workflow chains 4 monolithic skills manually: `/bootstrap` ‚Üí `/scaffold` ‚Üí `/review` ‚Üí `/promote`. Each does too much internally ‚Äî can't resume mid-step, skip unnecessary phases, or reuse steps independently. The developer must remember which skill to call next.

**Promoted from:** [Workflow Orchestrator Analysis](../analyses/workflow-orchestrator-design.mdx)
**Frame:** [Atomic Workflow Orchestrator Frame](../frames/atomic-workflow-orchestrator.mdx)
**GitHub issue:** #364

## Goal

1. Single entry point (`/dev #42`) that shows progress and delegates to the right step
2. Atomic step skills that each produce ONE artifact and can be called independently
3. Artifact-based state detection ‚Äî no state files, resume works by re-scanning
4. Skip logic based on tier and artifact quality
5. Backward-compatible with all existing artifacts

## Artifact Model

| Type | Directory | Question answered | Gate |
|------|-----------|-------------------|------|
| **Frame** | `artifacts/frames/{slug}.mdx` | What's the problem? | User approval |
| **Analysis** | `artifacts/analyses/{N}-{slug}.mdx` | How deep is it? | Expert review (skippable) |
| **Spec** | `artifacts/specs/{N}-{slug}.mdx` | What will we build? | User approval |
| **Plan** | `artifacts/plans/{N}-{slug}.mdx` | How do we build it? | User approval |

---

## Step Skills

### `/frame` (NEW)

**Purpose:** Capture problem statement, constraints, scope boundaries, and complexity tier.

**Input:** Issue #N or free text idea.
**Output:** `artifacts/frames/{slug}.mdx` with frontmatter `{title, issue, status, tier, date}`.
**Sections:** Problem, Who, Constraints, Out of scope, Complexity.

**Behavior:**
1. If `--issue N` ‚Üí fetch issue title/body as seed context
2. If free text ‚Üí use as seed
3. Interview user (3-5 questions max): problem, who, constraints, scope boundaries
4. Auto-detect tier from complexity signals ‚Üí AskUserQuestion to confirm
5. Write frame doc with `status: draft`
6. Present to user ‚Üí AskUserQuestion: Approve | Revise
7. Approved ‚Üí set `status: approved`

**File:** `.claude/skills/frame/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep

---

### `/analyze` (extracted from `/bootstrap` Gate 1)

**Purpose:** Deep technical exploration ‚Äî existing code, dependencies, risks, alternatives.

**Input:** Frame doc path or issue #N (finds frame automatically).
**Output:** `artifacts/analyses/{N}-{slug}.mdx`

**Behavior:**
1. Read frame doc ‚Üí extract problem, constraints
2. Glob + Grep codebase for related files
3. Interview user for technical context (via `/interview` skill)
4. Generate analysis with sections: Source, Problem, Outcome, Appetite, Shapes, Fit Check
5. Expert review (spawn architect, product-lead, doc-writer as needed ‚Äî same logic as current bootstrap Gate 1b)
6. Present to user ‚Üí AskUserQuestion: Approve | Revise

**Extracted from:** Bootstrap Steps 1, 1a, Gate 1 (1a-1c).
**File:** `.claude/skills/analyze/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep, Task

---

### `/spec` (extracted from `/bootstrap` Gate 2)

**Purpose:** Solution design ‚Äî acceptance criteria, breadboard, slices. Buildable blueprint.

**Input:** Analysis doc path or frame doc path (if analysis skipped) or issue #N.
**Output:** `artifacts/specs/{N}-{slug}.mdx`

**Behavior:**
1. Read analysis (or frame if analysis skipped) ‚Üí extract context
2. Ensure GitHub issue exists (create if needed)
3. Generate spec via `/interview --promote` with sections: Context, Goal, Users, Expected Behavior, Breadboard, Slices, Success Criteria
4. Pre-check ("unit tests for English"): testable criteria, no dangling refs, ambiguity budget ‚â§5, slice coverage, edge completeness
5. Expert review (architect always included for specs)
6. Present to user ‚Üí AskUserQuestion: Approve | Revise
7. Optional: smart splitting if |criteria| > 8 or |slices| > 3
8. Update issue status ‚Üí "Specs"

**Extracted from:** Bootstrap Gate 2 (2a-2c), Gate 2.5, Ensure GitHub Issue, Issue Status.
**File:** `.claude/skills/spec/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep, Task

---

### `/plan` (extracted from `/scaffold` Steps 1-4)

**Purpose:** Implementation breakdown ‚Äî tasks, agents, file groups, dependencies.

**Input:** Spec path or issue #N (finds spec automatically).
**Output:** `artifacts/plans/{N}-{slug}.mdx`

**Behavior:**
1. Read spec ‚Üí extract criteria, breadboard, slices
2. Ambiguity check: grep `[NEEDS CLARIFICATION]` ‚Üí block or warn
3. Scope: Glob + Grep ‚Üí files to create/modify
4. Tier confirmation (from frame or re-assess)
5. Agent assignment per path prefix (FE, BE, devops, tester, etc.)
6. Generate micro-tasks with: description, files, agent, dependencies, parallel-safe flag
7. Slice selection if multi-slice: AskUserQuestion
8. Present plan ‚Üí AskUserQuestion: Approve | Modify | Cancel
9. Write plan artifact

**Extracted from:** Scaffold Steps 1, 2 (2a-2f), 4 (4a-4b).
**File:** `.claude/skills/plan/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep, Task

---

### `/implement` (extracted from `/scaffold` Steps 3, 5-7)

**Purpose:** Execute plan ‚Äî setup worktree, spawn agents, write code + tests.

**Input:** Plan path or issue #N (finds plan automatically).
**Output:** Code + tests in worktree. Branch `feat/{N}-{slug}`.

**Behavior:**
1. Read plan ‚Üí extract tasks, agents, tier
2. Setup:
   - Worktree: `git worktree add ../roxabi-{N} -b feat/{N}-{slug} staging`
   - Install: `cp .env.example .env && bun install`
   - DB: `cd apps/api && bun run db:branch:create --force {N}`
3. Context injection per agent (standards docs, ref patterns)
4. Execute:
   - Tier S ‚Üí direct implementation (single session)
   - Tier F ‚Üí RED/GREEN/REFACTOR cycle with tester + domain agents
5. Quality gate: `bun lint && bun typecheck && bun run test` ‚Üí fix loop (max 3)
6. Update issue status ‚Üí "In Progress"

**Does NOT create PR** ‚Äî that's `/pr` (next step).

**Extracted from:** Scaffold Steps 3, 5, partially 6-7.
**File:** `.claude/skills/implement/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep, Task, Skill

---

### `/fix` (extracted from `/review` Phases 5, 7)

**Purpose:** Apply review findings ‚Äî auto-apply high-confidence, 1b1 for the rest.

**Input:** PR #N or review findings from conversation context.
**Output:** Modified files, commit with fixes.

**Behavior:**
1. Gather findings (from PR comments or conversation)
2. Queue split:
   - `Q_auto`: C ‚â• 80, actionable, not security-auditor ‚Üí verify with fresh agent ‚Üí apply
   - `Q_1b1`: everything else ‚Üí invoke `/1b1`
3. Auto-apply serially (rollback on failure)
4. 1b1 walkthrough for remaining
5. Spawn fixer agents per domain for accepted findings
6. Stage + commit + push
7. Post follow-up comment to PR

**Extracted from:** Review Phases 5 (auto-apply) + 7 (1b1 + fixers).
**File:** `.claude/skills/fix/SKILL.md`
**Allowed tools:** Bash, AskUserQuestion, Read, Write, Edit, Glob, Grep, Task, Skill

---

### `/review` (simplified)

**Keep:** Phases 1-4 (gather, spec compliance, multi-domain agents, merge + present), Phase 6 (post to PR), Phase 8 (auto-merge gate).
**Remove:** Phase 5 (auto-apply) ‚Üí now `/fix`. Phase 7 (1b1 + fixers) ‚Üí now `/fix`.

**New behavior:**
1. Gather changes
2. Spec compliance check
3. Multi-domain agent review
4. Merge, dedup, present findings with verdict
5. Post to PR
6. AskUserQuestion: Fix now (`/fix`) | Merge as-is | Stop
7. If merge ‚Üí auto-merge gate (rebase, label, squash)

**File:** `.claude/skills/review/SKILL.md` (modify in place)

---

## `/dev` Orchestrator

### Entry point

```
/dev #42           ‚Üí resume/start from issue
/dev "dark mode"   ‚Üí find or create issue, then start
```

### State detection (parallel, `<3s`)

```python
def scan(issue_num, slug):
    # All in parallel
    issue    = gh_issue_exists(issue_num)
    frame    = glob(f"artifacts/frames/*{slug}*")
    analysis = glob(f"artifacts/analyses/{issue_num}-*") or glob(f"artifacts/analyses/*{slug}*")
    spec     = glob(f"artifacts/specs/{issue_num}-*")
    plan     = glob(f"artifacts/plans/{issue_num}-*")
    worktree = worktree_exists(issue_num)
    branch   = branch_exists(issue_num)
    pr       = gh_pr_for_branch(issue_num)

    return {
        'triage':    issue is not None,
        'frame':     frame and frontmatter(frame).status == 'approved',
        'analyze':   analysis is not None,
        'spec':      spec is not None,
        'plan':      plan is not None,
        'implement': worktree and has_code_changes(worktree),
        'pr':        pr is not None,
        'validate':  None,  # always re-run
        'review':    pr and pr.review_state in ('approved', 'changes_requested'),
        'fix':       pr and no_open_findings(pr),
        'promote':   pr and pr.merged,
        'cleanup':   not worktree_exists(issue_num) and not stale_branch(issue_num),
    }
```

### Step chain (ordered)

```
STEPS = [
    ('Frame',  'triage',    '/issue-triage'),
    ('Frame',  'frame',     '/frame'),
    ('Shape',  'analyze',   '/analyze'),     # skippable
    ('Shape',  'spec',      '/spec'),
    ('Build',  'plan',      '/plan'),
    ('Build',  'implement', '/implement'),
    ('Build',  'pr',        '/pr'),
    ('Verify', 'validate',  '/validate'),
    ('Verify', 'review',    '/review'),
    ('Verify', 'fix',       '/fix'),         # skippable if 0 findings
    ('Ship',   'promote',   '/promote'),
    ('Ship',   'cleanup',   '/cleanup'),
]
```

### Skip logic

```python
def should_skip(step, tier, state):
    if step == 'triage'  and state['triage']:         return True
    if step == 'frame'   and tier == 'S':             return True
    if step == 'analyze' and tier in ('S', 'F-lite'): return True  # frame sufficient
    if step == 'spec'    and tier == 'S':             return True
    if step == 'plan'    and tier == 'S':             return True
    if step == 'fix'     and no_findings():           return True
    if step == 'promote' and not needs_release():     return True
    if step == 'cleanup' and not has_stale():         return True
    return False
```

### Progress display

```
## Dark Mode (#42)  [F-lite]

  Frame    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚úì triage, frame (approved)
  Shape    ‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë    analyze skipped, spec pending
  Build    ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë    ‚Äî
  Verify   ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë    ‚Äî
  Ship     ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë    ‚Äî

‚Üí Next: spec (generate solution spec from frame)
```

### Main loop

```
1. Parse input ‚Üí issue #N + slug
2. scan(N, slug) ‚Üí state
3. Determine tier (frame.tier || issue.size || ask user)
4. Walk STEPS:
   a. Skip completed steps (state[step] == True)
   b. Skip per skip_logic(step, tier, state)
   c. First non-skipped, non-completed = next_step
5. Display progress + next_step
6. AskUserQuestion:
   - Continue    ‚Üí invoke next_step skill
   - Skip to...  ‚Üí jump (warn if deps missing)
   - Stop        ‚Üí exit (artifacts persist)
7. On skill completion ‚Üí goto 2 (re-scan)
```

### Gates (auto-pause)

| After step | Gate behavior |
|-----------|---------------|
| `/frame` | Show frame, require `status: approved` before continuing |
| `/spec` | Show spec, require user approval before continuing |
| `/implement` | Show summary, confirm ready for PR |
| `/review` | Show findings, choose fix/merge/stop |

### Phase calculation for display

```python
def phase_progress(phase_name, steps_in_phase, state):
    done = sum(1 for s in steps_in_phase if state[s] or should_skip(s))
    total = len(steps_in_phase)
    return done, total  # renders as progress bar
```

---

## Deprecated Aliases

### `/bootstrap` ‚Üí `/dev`

```
/bootstrap "idea"     ‚Üí /dev "idea"      (starts at Frame)
/bootstrap --issue N  ‚Üí /dev #N          (starts at Frame)
/bootstrap --spec N   ‚Üí /dev #N --from spec  (starts at Shape.spec)
```

Emit deprecation notice: "‚ö† /bootstrap is deprecated. Use /dev #N instead."

### `/scaffold` ‚Üí `/dev`

```
/scaffold --spec N    ‚Üí /dev #N --from plan   (starts at Build.plan)
/scaffold --issue N   ‚Üí /dev #N --from plan
```

Emit deprecation notice: "‚ö† /scaffold is deprecated. Use /dev #N instead."

---

## Directory Structure

```
.claude/skills/
‚îú‚îÄ‚îÄ dev/               # NEW ‚Äî orchestrator
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ frame/             # NEW ‚Äî problem framing
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ analyze/           # NEW ‚Äî extracted from bootstrap Gate 1
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ spec/              # NEW ‚Äî extracted from bootstrap Gate 2
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ plan/              # NEW ‚Äî extracted from scaffold Steps 1-4
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ implement/         # NEW ‚Äî extracted from scaffold Steps 3,5
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ fix/               # NEW ‚Äî extracted from review Phases 5,7
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ bootstrap/         # DEPRECATED ‚Äî alias to /dev
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md       # Minimal: redirect + deprecation notice
‚îú‚îÄ‚îÄ scaffold/          # DEPRECATED ‚Äî alias to /dev
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md       # Minimal: redirect + deprecation notice
‚îú‚îÄ‚îÄ review/            # MODIFIED ‚Äî simplified (no auto-apply, no 1b1)
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ (unchanged skills) # 1b1, adr, cleanup, interview, issue-triage,
‚îÇ                      # issues, pr, promote, test, validate, etc.
‚îî‚îÄ‚îÄ shared/            # Shared references (keep as-is)
```

```
artifacts/
‚îú‚îÄ‚îÄ frames/            # NEW
‚îÇ   ‚îî‚îÄ‚îÄ {slug}.mdx
‚îú‚îÄ‚îÄ analyses/          # existing (also reads {N}-{slug}.mdx and legacy formats)
‚îú‚îÄ‚îÄ specs/             # existing
‚îî‚îÄ‚îÄ plans/             # existing
```

---

## Acceptance Criteria

### Orchestrator (`/dev`)
- [ ] `/dev #N` shows progress in `<5` seconds
- [ ] Correctly detects all existing artifact types (frames, analyses, specs, plans, worktrees, PRs)
- [ ] Resumes from any point ‚Äî `/dev #N` after session restart picks up correctly
- [ ] Skip logic works: S-tier skips frame/analyze/spec/plan, F-lite skips analyze
- [ ] Pauses at gates (frame approval, spec approval, post-implement, post-review)
- [ ] `--from <step>` allows jumping to a specific step
- [ ] Handles both `#N` and `"text"` input formats

### Step skills
- [ ] `/frame` produces valid frame doc with all sections + frontmatter
- [ ] `/analyze` produces analysis with expert review (same quality as bootstrap Gate 1)
- [ ] `/spec` produces spec with expert review + pre-checks (same quality as bootstrap Gate 2)
- [ ] `/plan` produces plan with tasks, agents, dependencies (same quality as scaffold Step 2+4)
- [ ] `/implement` sets up worktree + executes plan (same behavior as scaffold Steps 3+5)
- [ ] `/fix` handles auto-apply + 1b1 + fixer agents (same behavior as review Phases 5+7)
- [ ] `/review` simplified: no auto-apply, no 1b1, ends with findings + verdict

### Each step skill independently callable
- [ ] `/frame "dark mode"` works without `/dev`
- [ ] `/spec --issue 42` works without `/dev`
- [ ] `/plan --issue 42` works without `/dev`
- [ ] All other step skills work standalone

### Backward compatibility
- [ ] Existing `artifacts/analyses/*.mdx` recognized by state detection (with or without issue prefix)
- [ ] Existing `artifacts/specs/*.mdx` recognized
- [ ] Existing `artifacts/plans/*.mdx` recognized
- [ ] `/bootstrap` and `/scaffold` redirect to `/dev` with deprecation notice

### Docs
- [ ] CLAUDE.md updated with `/dev` workflow, artifact model, phase definitions
- [ ] `dev-process.mdx` updated with new phases and step skill references

---

## Implementation Tasks

### Phase 1 ‚Äî Core (orchestrator + frame)
1. Create `artifacts/frames/` directory (done)
2. Write `/dev` orchestrator SKILL.md
3. Write `/frame` SKILL.md
4. Test: `/dev "test idea"` ‚Üí shows empty progress ‚Üí runs `/frame` ‚Üí shows updated progress

### Phase 2 ‚Äî Extract from bootstrap
5. Write `/analyze` SKILL.md (from bootstrap Gate 1)
6. Write `/spec` SKILL.md (from bootstrap Gate 2)
7. Convert `/bootstrap` to deprecation alias
8. Test: `/dev #N` through full Shape phase

### Phase 3 ‚Äî Extract from scaffold
9. Write `/plan` SKILL.md (from scaffold Steps 1-4)
10. Write `/implement` SKILL.md (from scaffold Steps 3, 5)
11. Convert `/scaffold` to deprecation alias
12. Test: `/dev #N` through full Build phase

### Phase 4 ‚Äî Extract from review + polish
13. Write `/fix` SKILL.md (from review Phases 5, 7)
14. Simplify `/review` SKILL.md (remove Phases 5, 7)
15. Test: `/dev #N` through full Verify phase

### Phase 5 ‚Äî Docs + migration
16. Update CLAUDE.md ‚Äî new workflow, artifact model, phase definitions
17. Update `dev-process.mdx` ‚Äî align with new phases
18. End-to-end test: `/dev #N` from Frame through Ship
