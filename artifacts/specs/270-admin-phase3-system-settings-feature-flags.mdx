---
title: "Admin Panel Phase 3: System Settings + Feature Flags"
description: System configuration and boolean feature flag management for super admins, with shared modules for app-wide consumption.
---

## Context

Issue [#270](https://github.com/roxabi/roxabi_boilerplate/issues/270) — Phase 3 of the Admin Panel ([#25](https://github.com/roxabi/roxabi_boilerplate/issues/25)). Depends on Phase 2 (#269, completed) and #314 (centralized route permission map, closed).

**Promoted from:** [Admin Phase 3 Analysis](../analyses/270-admin-phase3-system-settings-feature-flags.mdx)

**Phase 1 (#268)** delivered: admin layout, sidebar, guards, member management, `AuditService` scaffolding.
**Phase 2 (#269)** delivered: cross-tenant user/org CRUD with cursor pagination, org hierarchy, audit log viewer with diff view.

Phase 3 adds two features for super admins:
1. **System Settings** — global configuration stored as typed key-value pairs, grouped by category, editable via the admin panel.
2. **Feature Flags** — boolean toggles for enabling/disabling application features, with in-memory caching and admin CRUD.

## Goal

Enable super admins to manage global system configuration and boolean feature flags from the admin panel, with shared services that any module can consume for runtime configuration checks.

## Users &amp; Use Cases

### Super Admin (global `superadmin` user role)

- **Manage system settings**: View all settings grouped by category. Edit values with per-card save. Settings catalog is controlled by migrations (no create/delete in UI).
- **Manage feature flags**: View all flags with toggle switches. Create new flags (auto-slugified key, validated unique). Toggle flags on/off. Delete flags with confirmation.

### Application Code (any NestJS module)

- **Read settings**: `SystemSettingsService.getValue&lt;T&gt;(key)` — typed read with runtime validation.
- **Check feature flags**: `FeatureFlagService.isEnabled(key)` — cached boolean lookup.

## Expected Behavior

### Happy path

#### System settings

1. Super admin navigates to `/admin/system-settings` (System nav group).
2. Page shows settings grouped by category in cards: General, Authentication, Organizations, Email, Security. Each card lists its settings with the appropriate input type based on the `type` field:
   - `string` → text input
   - `number` → number input
   - `boolean` → toggle switch
   - `select` → dropdown (options from `metadata.options`)
3. Super admin edits a setting value within a card.
4. Super admin clicks "Save" button on that card → `PATCH /api/admin/settings` with `{ updates: [{ key, value }] }` (all changed settings in the card). Success toast: "Settings saved".
5. Changes are audit logged with before/after values per setting.

#### Feature flags

1. Super admin navigates to `/admin/feature-flags` (System nav group).
2. Page shows all flags in a list: name, key (monospace), description, enabled/disabled toggle switch.
3. Super admin toggles a flag → `PATCH /api/admin/feature-flags/:id` with `{ enabled }` → in-memory cache invalidated on this instance. Success toast: "Flag updated".
4. Super admin clicks "Create Flag" → dialog with fields:
   - Name (required, 1-100 chars)
   - Key (auto-slugified from name, editable, validated: `/^[a-z0-9][a-z0-9_-]*$/`, max 100 chars, unique)
   - Description (optional, max 500 chars)
   Submit → `POST /api/admin/feature-flags` with `{ name, key, description }`.
   Success toast: "Flag created". Dialog closes. Flag appears in list.
5. Super admin clicks "Delete" on a flag → confirmation dialog: "Delete flag '{name}'? Code referencing this flag will get `false` as default." → `DELETE /api/admin/feature-flags/:id`. Success toast: "Flag deleted". Cache entry removed.

### Edge cases

| Scenario | Behavior |
|----------|----------|
| Setting value doesn't match declared type | 400: "Invalid value for setting type '{type}'" |
| Number setting set to negative when not allowed | 400: "Value must be a positive number" |
| Feature flag duplicate key on create | 400: "A flag with this key already exists" |
| Feature flag key with invalid characters | 400: "Key must contain only lowercase letters, numbers, hyphens, and underscores" |
| Feature flag key exceeds 100 chars | 400: "Key must be 100 characters or fewer" |
| `isEnabled()` called for non-existent flag key | Returns `false` (safe default, no error) |
| `getValue()` called for non-existent setting key | Returns `null` (callers must handle) |
| Flag toggled while cached on same instance | Cache entry invalidated immediately before response. Subsequent `isEnabled()` reads from DB |
| Flag toggled on instance A, checked on instance B (serverless) | Instance B serves stale value for up to 60s (TTL). Acceptable for boolean flags at admin-frequency writes |
| Concurrent admin edits to same setting | Last-write-wins. Both changes audit logged independently |
| Setting `metadata.options` is empty array for select type | 400: "Select settings must have at least one option" |
| Non-superadmin accesses settings/flags endpoints | 403 (route guard + backend `@Roles('superadmin')`) |
| Org admin navigates to `/admin/system-settings` or `/admin/feature-flags` | Redirect to `/admin` |

## Breadboard

### UI Affordances

| ID | Element | Location | Trigger |
|----|---------|----------|---------|
| U1 | System settings page | `/admin/system-settings` | Nav click |
| U2 | Category card | Settings page | Renders per category |
| U3 | Setting input (text/number/boolean/select) | Inside category card | User interaction |
| U4 | "Save" button per card | Category card footer | Click → save changed settings in card |
| U5 | Feature flags page | `/admin/feature-flags` | Nav click |
| U6 | Flag list with toggle switches | Flags page | Toggle → PATCH |
| U7 | "Create Flag" button | Flags page header | Click → open dialog |
| U8 | Create flag dialog | Modal overlay | Form submit → POST |
| U9 | "Delete" button per flag | Flag list row | Click → confirmation dialog |
| U10 | Delete confirmation dialog | Modal overlay | Confirm → DELETE |

### Code Affordances

| ID | Handler | Wiring | Logic |
|----|---------|--------|-------|
| N1 | `GET /api/admin/settings` | U1,U2,U3 → N1 → S1 | Return all settings grouped by category. No pagination (bounded dataset, ~12 rows) |
| N2 | `PATCH /api/admin/settings` | U4 → N2 → S1,S3 | Batch update: `{ updates: [{ key, value }] }`. For each: read before-state, validate type, mutate, audit log with `resourceId = key` |
| N3 | `GET /api/admin/feature-flags` | U5,U6 → N3 → S2 | Return all flags ordered by `createdAt DESC`. No pagination (bounded dataset) |
| N4 | `POST /api/admin/feature-flags` | U7,U8 → N4 → S2,S3 | Create flag: validate key format + uniqueness, insert, audit log |
| N5 | `PATCH /api/admin/feature-flags/:id` | U6 → N5 → S2,S3,S4 | Toggle flag: read before-state, update `enabled`, invalidate cache (S4), audit log |
| N6 | `DELETE /api/admin/feature-flags/:id` | U9,U10 → N6 → S2,S3,S4 | Delete flag: read before-state, delete row, remove from cache (S4), audit log |
| N7 | `FeatureFlagService.isEnabled(key)` | Any module → N7 → S4,S2 | Check cache (S4) first. Cache miss → query S2. Cache for 60s. Non-existent key → `false` |
| N8 | `SystemSettingsService.getValue&lt;T&gt;(key)` | Any module → N8 → S1 | Query S1 by key. Validate type cast. Non-existent key → `null` |

### Data Stores

| ID | Store | Type | Accessed by |
|----|-------|------|-------------|
| S1 | `system_settings` table | Persistent (PostgreSQL, Global — no RLS) | N1, N2, N8 |
| S2 | `feature_flags` table | Persistent (PostgreSQL, Global — no RLS) | N3, N4, N5, N6, N7 |
| S3 | `audit_logs` table | Persistent (PostgreSQL) | N2, N4, N5, N6 |
| S4 | In-memory flag cache | Transient (Map&lt;string, { value: boolean, expiresAt: number }&gt;) | N5, N6, N7 |

**Unknowns:** None. All patterns established in Phase 1-2.

## Slices

| Slice | Description | Affordances | Demo |
|-------|-------------|-------------|------|
| V1: Schema + Shared Modules | DB migration (2 tables + indexes + seed data), `SystemSettingsModule` with `SystemSettingsService`, `FeatureFlagsModule` with `FeatureFlagService` (including cache + `isEnabled()`), shared types, `AdminModule` imports | S1, S2, S4, N7, N8 | `db:migrate` creates tables and seeds 12 settings. Unit tests: `isEnabled('nonexistent')` returns `false`, `getValue('app.name')` returns `"Roxabi"`, cache invalidation works |
| V2: System Settings | Settings admin controller (`GET` + `PATCH`), frontend `/admin/system-settings` page with category cards and per-card save, audit logging, enable sidebar nav item | U1-U4, N1, N2 | Super admin can view all settings grouped by category, edit values, save per card, see success toast. Audit log shows `settings.updated` entries |
| V3: Feature Flags | Feature flags admin controller (full CRUD), frontend `/admin/feature-flags` page with toggle switches + create/delete dialogs, key validation, cache invalidation on write, audit logging, enable sidebar nav item | U5-U10, N3-N6 | Super admin can list flags, create a flag (with auto-slug), toggle on/off, delete with confirmation. Duplicate key returns error. Audit log shows `flag.created`, `flag.toggled`, `flag.deleted` entries |

**Slice dependencies:** V1 → V2 → V3 (sequential). V2 depends on V1 (schema + services). V3 depends on V2 (establishes admin controller patterns for Phase 3, reuses sidebar nav enable pattern).

## Constraints

- **Auth foundation**: Uses existing two-tier role system. No new role tiers.
- **Guard strategy**: All Phase 3 endpoints use `@Roles('superadmin')` with `@SkipOrg()`. Direct Drizzle queries without `TenantService`.
- **Global tables**: `system_settings` and `feature_flags` are Global — no `tenant_id`, no RLS, no `TenantService`. Migration must NOT call `SELECT create_tenant_rls_policy()`. Same pattern as `permissions` and `roles` tables.
- **Rate limiting**: Same tier as Phase 1-2: `@Throttle({ global: { ttl: 60_000, limit: 30 } })` on all Phase 3 controllers.
- **UI components**: Use existing Shadcn/UI components from `packages/ui`. No new shared components required.
- **Unique constraints**: Both tables require `UNIQUE` constraint on `key` column.
- **Schema migration + seed migration**: Table creation in one migration, seed data in a companion migration (`INSERT ... ON CONFLICT (key) DO NOTHING`). Implementors must run `cd apps/api && bun run db:generate` and commit the generated SQL files.
- **Dependencies**: Phase 2 (#269) and #314 completed.

## Non-goals

- **Feature flag targeting** (per-org, per-user, percentage rollouts) — global boolean toggles only
- **Settings create/delete UI** — catalog controlled by migrations, admin edits values only
- **Operational wiring** of `auth.sessionTtlHours` / `auth.maxLoginAttempts` to Better Auth — informational in Phase 3
- **External cache** (Redis, Vercel KV) for feature flags — in-memory only
- **Real-time settings/flag updates** across browser tabs — request/response only
- **Mobile-optimized admin UX** — desktop-first with responsive layout
- **Settings history/versioning** — audit log is the change history
- **Settings import/export** — deferred

## Technical Decisions

### Schema

**`system_settings` table (Global, no RLS):**

```
system_settings
  id          text PK (cuid2)
  key         text UNIQUE NOT NULL
  value       jsonb NOT NULL
  type        text NOT NULL ('string' | 'number' | 'boolean' | 'select')
  name        text NOT NULL
  description text
  category    text NOT NULL
  metadata    jsonb          -- { options?: string[] } for select type, extensible
  createdAt   timestamp NOT NULL DEFAULT now()
  updatedAt   timestamp NOT NULL DEFAULT now()
```

**`feature_flags` table (Global, no RLS):**

```
feature_flags
  id          text PK (cuid2)
  key         text UNIQUE NOT NULL
  name        text NOT NULL
  description text
  enabled     boolean NOT NULL DEFAULT false
  createdAt   timestamp NOT NULL DEFAULT now()
  updatedAt   timestamp NOT NULL DEFAULT now()
```

**Indexes:**
- `idx_system_settings_key` UNIQUE on `system_settings.key`
- `idx_system_settings_category` on `system_settings.category`
- `idx_feature_flags_key` UNIQUE on `feature_flags.key`

### Seed migration

Companion migration immediately after table creation. Uses `INSERT ... ON CONFLICT (key) DO NOTHING` for idempotency. Seeds 12 settings:

| Key | Type | Default | Category |
|-----|------|---------|----------|
| `app.name` | string | "Roxabi" | General |
| `app.supportEmail` | string | "" | General |
| `app.maintenanceMode` | boolean | false | General |
| `auth.signupEnabled` | boolean | true | Authentication |
| `auth.sessionTtlHours` | number | 168 | Authentication |
| `auth.maxLoginAttempts` | number | 5 | Authentication |
| `org.maxMembers` | number | 100 | Organizations |
| `org.allowSelfRegistration` | boolean | false | Organizations |
| `email.fromName` | string | "Roxabi" | Email |
| `email.fromAddress` | string | "" | Email |
| `email.footerText` | string | "" | Email |
| `security.passwordMinLength` | number | 8 | Security |

The `db:seed` script should also insert these rows for local dev consistency.

### Module placement

```
apps/api/src/
  system-settings/
    system-settings.module.ts       (new — exports SystemSettingsService)
    system-settings.service.ts      (new — getValue<T>, getAll, getByCategory, update)
    system-settings.service.test.ts (new)
  feature-flags/
    feature-flags.module.ts         (new — exports FeatureFlagService)
    feature-flags.service.ts        (new — isEnabled, getAll, create, update, delete + cache)
    feature-flags.service.test.ts   (new)
  admin/
    admin.module.ts                 (extend — import shared modules, register new controllers)
    admin-settings.controller.ts    (new — GET + PATCH /api/admin/settings)
    admin-settings.controller.test.ts (new)
    admin-feature-flags.controller.ts (new — CRUD /api/admin/feature-flags)
    admin-feature-flags.controller.test.ts (new)
    filters/
      admin-exception.filter.ts     (extend — new exception types)
    exceptions/
      setting-not-found.exception.ts      (new)
      setting-validation.exception.ts     (new)
      flag-not-found.exception.ts         (new)
      flag-key-conflict.exception.ts      (new — 400)
      flag-key-invalid.exception.ts       (new — 400)
```

`AdminModule` imports `SystemSettingsModule` and `FeatureFlagsModule`. Any other module (e.g., billing, notifications) can import `FeatureFlagsModule` or `SystemSettingsModule` to call `isEnabled()` or `getValue()`.

### Frontend file structure

```
apps/web/src/
  routes/admin/
    system-settings.tsx              (new — settings page)
    feature-flags.tsx                (new — flags page)
  components/admin/
    settings-card.tsx                (new — category card with inputs + save)
    flag-list-item.tsx               (new — flag row with toggle + delete)
    create-flag-dialog.tsx           (new — create flag form dialog)
```

### Shared types

Extend `packages/types/src/admin.ts`:

```ts
// System Settings
interface SystemSetting {
  id: string
  key: string
  value: unknown // jsonb
  type: 'string' | 'number' | 'boolean' | 'select'
  name: string
  description: string | null
  category: string
  metadata: { options?: string[] } | null
  createdAt: string
  updatedAt: string
}

interface SettingsUpdatePayload {
  updates: Array<{ key: string; value: unknown }>
}

interface SettingsByCategory {
  [category: string]: SystemSetting[]
}

// Feature Flags
interface FeatureFlag {
  id: string
  key: string
  name: string
  description: string | null
  enabled: boolean
  createdAt: string
  updatedAt: string
}

interface CreateFeatureFlagPayload {
  name: string
  key: string
  description?: string
}
```

### Feature flag caching

`FeatureFlagService` maintains a `Map&lt;string, { value: boolean, expiresAt: number }&gt;`:

- **`isEnabled(key)`**: Check map. If entry exists and `Date.now() &lt; expiresAt`, return cached value. Otherwise, query DB (`SELECT enabled FROM feature_flags WHERE key = ?`). If found, cache with `expiresAt = Date.now() + 60_000`. If not found, return `false` (do not cache non-existent keys — they may be created later).
- **Write-through invalidation**: `update()` and `delete()` call `this.cache.delete(key)` before returning. Next `isEnabled()` call reads from DB.
- **Cross-instance coherence**: Not guaranteed. Other serverless instances serve stale data for up to 60s. Acceptable for MVP.

### Audit logging

All mutations call `AuditService.log()`:

| Action | Resource | resourceId | before/after |
|--------|----------|------------|--------------|
| `settings.updated` | `setting` | setting `key` (e.g., `app.name`) | `{ value: "Old" }` → `{ value: "New" }` |
| `flag.created` | `feature_flag` | flag UUID | `null` → `{ key, name, enabled }` |
| `flag.toggled` | `feature_flag` | flag UUID | `{ enabled: false }` → `{ enabled: true }` |
| `flag.deleted` | `feature_flag` | flag UUID | `{ key, name, enabled }` → `null` |

Settings use the setting `key` as `resourceId` (human-readable in audit viewer). Feature flags use the row UUID (consistent with Phase 2 pattern for entity mutations).

### Settings type validation

`SystemSettingsService.update(key, value)` validates:

| Type | Validation |
|------|-----------|
| `string` | `typeof value === 'string'` |
| `number` | `typeof value === 'number' && !isNaN(value)` |
| `boolean` | `typeof value === 'boolean'` |
| `select` | `typeof value === 'string' && metadata.options.includes(value)` |

Invalid values return 400 with a descriptive message. The service reads the setting's `type` and `metadata` from DB before validating.

### Sidebar nav enablement

The admin sidebar currently has "System Settings" and "Feature Flags" items with `disabled: true`. Phase 3 enables them by:
1. Removing the `disabled: true` flag
2. Adding the route files with `staticData: { permission: 'role:superadmin' }` + `beforeLoad: enforceRoutePermission`

### Batch settings update

`PATCH /api/admin/settings` accepts `{ updates: [{ key, value }] }` — a batch of changed settings from one category card. The controller:
1. Validates all updates (type checks) before writing any
2. For each update: reads before-state, writes new value, logs audit entry
3. All operations within a single DB transaction
4. If any validation fails, the entire batch is rejected (no partial writes)

## Success Criteria

- [ ] `GET /api/admin/settings` returns all 12 seeded settings grouped by category. Non-superadmin requests return 403.
- [ ] `PATCH /api/admin/settings` with `{ updates: [{ key: "app.name", value: "NewName" }] }` updates the setting. Audit log entry created with `resourceId = "app.name"` and before/after values.
- [ ] `PATCH /api/admin/settings` with invalid type (e.g., string value for a number setting) returns 400.
- [ ] `/admin/system-settings` page displays settings in category cards with correct input types. Per-card save works with success toast.
- [ ] `GET /api/admin/feature-flags` returns all flags ordered by `createdAt DESC`.
- [ ] `POST /api/admin/feature-flags` with `{ name: "New Feature", key: "new-feature" }` creates a flag. Duplicate key returns 400.
- [ ] `POST /api/admin/feature-flags` with invalid key format (e.g., `"New Feature!"`) returns 400.
- [ ] `PATCH /api/admin/feature-flags/:id` with `{ enabled: true }` toggles the flag and invalidates the cache entry. Audit log entry created.
- [ ] `DELETE /api/admin/feature-flags/:id` removes the flag and cache entry. Audit log entry created.
- [ ] `FeatureFlagService.isEnabled('existing-flag')` returns correct boolean value. Non-existent key returns `false`.
- [ ] `FeatureFlagService` cache: second call within 60s returns cached value (no DB query). After write, next call reads from DB.
- [ ] `SystemSettingsService.getValue&lt;string&gt;('app.name')` returns `"Roxabi"` (seeded default). Non-existent key returns `null`.
- [ ] Both tables are Global (no RLS). Migration does not create tenant RLS policies.
- [ ] `db:migrate` creates tables and seeds 12 settings in all environments (dev, preview, production).
- [ ] "System Settings" and "Feature Flags" sidebar nav items are enabled and visible to super admins only.
- [ ] All Phase 3 endpoints use `@Roles('superadmin')` with `@SkipOrg()`.
- [ ] All mutations produce audit log entries with correct action vocabulary (`settings.updated`, `flag.created`, `flag.toggled`, `flag.deleted`).

## Open Questions

- **Auth settings operational wiring**: `auth.sessionTtlHours` and `auth.maxLoginAttempts` are informational in Phase 3. A follow-up issue should wire them into Better Auth's runtime config (requires investigating dynamic config reload vs restart).
- **Settings consumption pattern**: Code calling `getValue('app.name')` has no compile-time guarantee the key exists. A follow-up could add a typed constants file of known keys (e.g., `SETTINGS.APP_NAME = 'app.name'`) for ergonomic access without a full registry rewrite.
- **Cache TTL tuning**: 60s is the initial TTL. If operational needs require faster propagation (e.g., maintenance mode toggle), the TTL can be reduced. Monitor and adjust post-launch.
- **Feature flag key immutability enforcement**: Keys are intended to be immutable after creation (the `PATCH` endpoint only accepts `{ enabled }` and optionally `{ name, description }`). The API contract enforces this, but there is no DB-level immutability check. This is acceptable — the admin UI doesn't expose key editing.
