---
title: "Magic Link Authentication Edge Cases"
description: Reject unregistered emails, show specific token verification errors, and warn logged-in users clicking magic links.
---

## Context

Issues #19, #68, and #200 delivered a comprehensive auth system including magic link support. The happy path works: enter email → receive link → click → signed in. Three edge cases remain unhandled, identified during an end-to-end flow review.

**Promoted from:** [Magic Link Edge Cases Analysis](../analyses/magic-link-edge-cases)

**Related:**
- [Spec: #200 Auth Flow Review](./200-auth-flow-review)
- [Analysis: #200 Auth Flow Review](../analyses/200-auth-flow-review)

## Goal

Each magic link edge case produces a specific, actionable response instead of silent failures or generic error messages.

## Users &amp; Use Cases

| User | Scenario | Gap |
|------|----------|-----|
| User with typo in email | Requests magic link for `joh@example.com` instead of `john@example.com` | Gap 1: silently sends to wrong address |
| User clicking expired link | Clicks magic link after 5 minutes | Gap 2: sees generic "invalid or expired" |
| User clicking used link | Clicks same magic link twice | Gap 2: sees generic "invalid or expired" |
| User signed in as Account A | Clicks magic link from email for Account B | Gap 3: silently redirected to dashboard |

## Expected Behavior

### Happy path

No changes — existing flow works correctly:
1. Enter email → `authClient.signIn.magicLink({ email })` → email sent → `/magic-link-sent`
2. Click link → `/magic-link/verify?token=xxx` → `authClient.magicLink.verify()` → session → `/dashboard`

### Gap 1: Reject unregistered emails

1. User enters email on Magic Link tab and submits
2. Frontend calls `authClient.signIn.magicLink({ email })`
3. Backend `sendMagicLink` callback checks if email exists in `users` table
4. Email **not found** → callback throws `APIError('USER_NOT_FOUND')` → propagates to client
5. Frontend receives error → shows "No account found for this email. Check your address or create an account."
6. Email **found** → existing flow (send magic link email)

### Gap 2: Specific verification error messages

1. User clicks magic link → `/magic-link/verify?token=xxx`
2. Frontend calls `authClient.magicLink.verify({ query: { token } })`
3. Better Auth verifies token against `verifications` table
4. **Token not found** (invalid or already used) → Better Auth returns error code `INVALID_TOKEN`
5. **Token expired** → Better Auth returns error code `EXPIRED_TOKEN`
6. Frontend maps error code to specific message:
   - `EXPIRED_TOKEN` → "This link has expired. Request a new one." + "Request new link" button (navigates to `/login` with magic link tab active)
   - `INVALID_TOKEN` → "This link is invalid or has already been used." + "Back to sign in" link
   - No token in URL → "No verification link found." + "Back to sign in" link
   - Any other error → "Something went wrong. Please try again." + "Back to sign in" link

### Gap 3: Block-and-warn logged-in users

1. User is already signed in (has active session)
2. User clicks a magic link → `/magic-link/verify?token=xxx`
3. Page detects session via `authClient.useSession()`
4. Session exists **AND** token present → show warning state:
   - "You're already signed in as {email}."
   - "Sign out to use this link" button → calls `authClient.signOut()` then reloads page (which re-triggers verification as guest)
   - "Go to dashboard" button → navigates to `/dashboard`
5. Session exists **AND** no token → redirect to `/dashboard` (same as current `requireGuest`)
6. No session → proceed with verification (existing flow)

### Edge cases

| Scenario | Behavior |
|----------|----------|
| `sendMagicLink` callback throws for unregistered email | Error propagates to SDK client. Frontend shows specific message. |
| Better Auth `disableSignUp` not set | Default is `false`. We reject in callback before Better Auth can auto-create. |
| Token deleted after first use | Second click → `INVALID_TOKEN` → "invalid or already been used" |
| Token expired + clicked twice | First click → `EXPIRED_TOKEN`. Token deleted. Second click → `INVALID_TOKEN`. Both messages are clear. |
| User signs out via warning state | Page reloads, `useSession` returns null, verification proceeds normally. |
| User clicks "Go to dashboard" from warning | Token is not consumed. It remains valid until expiry (5 min). |
| Magic link with no token param + logged in | Redirect to `/dashboard` (no warning needed — no link to verify). |
| `sendMagicLink` DB lookup fails (database error) | Existing try-catch in callback sends fallback email. No change needed. |
| Error code not recognized by frontend | Falls through to generic "Something went wrong" message. |

## Breadboard

### UI Affordances

| ID | Element | Location | Trigger |
|----|---------|----------|---------|
| U1 | Magic link email form | `/login` (Magic Link tab) | User submits email |
| U2 | "No account found" error | `/login` (Magic Link tab) | `USER_NOT_FOUND` error from backend |
| U3 | Expired token message + "Request new link" button | `/magic-link/verify` | `EXPIRED_TOKEN` error code |
| U4 | Invalid token message | `/magic-link/verify` | `INVALID_TOKEN` error code |
| U5 | Warning state (signed-in user) | `/magic-link/verify` | Session detected + token present |
| U6 | "Sign out to use this link" button | `/magic-link/verify` (warning) | User action |
| U7 | "Go to dashboard" button | `/magic-link/verify` (warning) | User action |

### Code Affordances

| ID | Handler | Wiring | Logic |
|----|---------|--------|-------|
| N1 | `sendMagicLink` callback | U1 → N1 → S1 | Check `users` table. If not found, throw `APIError('USER_NOT_FOUND')`. Else send email. |
| N2 | `handleMagicLink` (frontend) | N1 error → U2 | Parse error. If `USER_NOT_FOUND`, show specific message. |
| N3 | `useVerifyMagicLink` hook | S2 → U3/U4 | Capture error code from `magicLink.verify()`. Expose code + status. |
| N4 | Session check in component | S3 → U5/U6/U7 | `authClient.useSession()`. If session + token, render warning. |
| N5 | Sign out handler | U6 → page reload | `authClient.signOut()` then `window.location.reload()` |

### Data Stores

| ID | Store | Type | Accessed by |
|----|-------|------|-------------|
| S1 | `users` table | Persistent (PostgreSQL) | N1 (email existence check) |
| S2 | `verifications` table | Persistent (PostgreSQL) | Better Auth internals (token lookup) |
| S3 | Session cookie | Transient (HTTP-only) | N4 (via `authClient.useSession()`) |

## Slices

| Slice | Description | Affordances | Demo |
|-------|-------------|-------------|------|
| V1 | Reject unregistered emails | U1, U2, N1, N2, S1 | Enter non-existent email → see "No account found" error |
| V2 | Specific verification errors | U3, U4, N3, S2 | Click expired link → see "This link has expired" with action button |
| V3 | Logged-in user warning | U5, U6, U7, N4, N5, S3 | Click magic link while signed in → see warning with sign-out option |

## Constraints

- **Better Auth plugin API:** `sendMagicLink` callback receives `{ email, url, token }`. Errors thrown in the callback propagate to the client SDK.
- **Better Auth verify error codes:** `INVALID_TOKEN` and `EXPIRED_TOKEN` are the two relevant codes. Verify behavior uses redirects with `?error=` param, but the SDK client wraps this.
- **Paraglide i18n:** All user-facing strings use `m.*` messages. New keys needed for EN + FR.
- **Email enumeration accepted:** Returning "no account found" reveals email registration status. Mitigated by global rate limiter (5 req/60s per IP). See analysis for full security assessment.

## Non-goals

- Per-email rate limiting (user decided: global only)
- Auto-account-creation on magic link verification
- Token reuse tracking / audit logging (known limitation: "already used" and "invalid" are indistinguishable server-side)
- `disableSignUp` configuration for Better Auth magic link plugin
- Changes to the `/magic-link-sent` page
- Changes to email templates

## Technical Decisions

### 1. Error propagation from `sendMagicLink` callback

Better Auth's `sendMagicLink` callback is called without try-catch. Throwing an error propagates it to the HTTP response and then to the SDK client.

**Approach:** Import `APIError` from `better-auth/api` (or throw a plain `Error`) in the callback. The SDK client receives it as `{ error: { status, message, code } }`.

```typescript
// In buildMagicLinkPlugin → sendMagicLink callback
const [userData] = await db
  .select({ locale: users.locale })
  .from(users)
  .where(eq(users.email, email))

if (!userData) {
  throw new APIError('BAD_REQUEST', { message: 'USER_NOT_FOUND' })
}
```

[NEEDS CLARIFICATION: Verify that `APIError` from Better Auth propagates the `message` field to the client SDK as `error.code` or `error.message`. Test during implementation — if the SDK wraps it differently, adjust the frontend error detection.]

### 2. Verify error code extraction

The `useVerifyMagicLink` hook currently discards the error details:

```typescript
const { error } = await authClient.magicLink.verify({ query: { token: t } })
if (error) setStatus('error')  // error details lost
```

**Change:** Store the error object and expose the error code:

```typescript
const { error } = await authClient.magicLink.verify({ query: { token: t } })
if (error) {
  setErrorCode(error.code ?? 'UNKNOWN')
  setStatus('error')
}
```

The `ErrorState` component then receives `errorCode` and renders the appropriate message.

### 3. Session check replaces `requireGuest`

Remove `beforeLoad: requireGuest` from the `/magic-link/verify` route. Replace with component-level session check using `authClient.useSession()`. This allows rendering the warning UI instead of redirecting.

**State machine:**
```
                   ┌─ session + token → WarningState
useSession() ─────┤
                   ├─ session + !token → redirect /dashboard
                   │
                   └─ !session → useVerifyMagicLink(token)
                                    ├─ loading → VerifyingState
                                    ├─ success → SuccessState
                                    └─ error → ErrorState(code)
```

## Implementation Phases

### Phase 1: Backend — Reject unregistered emails (V1)

| Task | File | Details |
|------|------|---------|
| Add user existence check | `apps/api/src/auth/auth.instance.ts` | In `sendMagicLink`, check `userData` before sending. If null, throw error. |

### Phase 2: Frontend — Handle magic link send error (V1)

| Task | File | Details |
|------|------|---------|
| Detect `USER_NOT_FOUND` error | `apps/web/src/routes/-login-handlers.ts` | In `handleMagicLink`, check `mlError.message` or `mlError.code` for user-not-found. |
| Add i18n keys | `apps/web/messages/en.json`, `fr.json` | `auth_magic_link_no_account`: "No account found for this email. Check your address or create an account." |

### Phase 3: Frontend — Specific verify errors (V2)

| Task | File | Details |
|------|------|---------|
| Extend `useVerifyMagicLink` hook | `apps/web/src/routes/magic-link/verify.tsx` | Store error code. Return `{ status, errorCode }`. |
| Update `ErrorState` component | `apps/web/src/routes/magic-link/verify.tsx` | Map `EXPIRED_TOKEN` → expired message + "Request new link". Map `INVALID_TOKEN` → invalid message. Fallback for unknown. |
| Add i18n keys | `apps/web/messages/en.json`, `fr.json` | `auth_magic_link_expired`: "This link has expired. Request a new one." / `auth_magic_link_invalid`: "This link is invalid or has already been used." / `auth_magic_link_request_new`: "Request new link" |

### Phase 4: Frontend — Logged-in user warning (V3)

| Task | File | Details |
|------|------|---------|
| Remove `requireGuest` from route | `apps/web/src/routes/magic-link/verify.tsx` | Remove `beforeLoad: requireGuest`. |
| Add session check in component | `apps/web/src/routes/magic-link/verify.tsx` | Use `authClient.useSession()`. Branch on session + token. |
| Add `WarningState` component | `apps/web/src/routes/magic-link/verify.tsx` | Shows signed-in email, "Sign out" button, "Go to dashboard" button. |
| Handle redirect for session + no token | `apps/web/src/routes/magic-link/verify.tsx` | `useEffect` → navigate to `/dashboard` if session and no token. |
| Add i18n keys | `apps/web/messages/en.json`, `fr.json` | `auth_magic_link_already_signed_in`: "You're already signed in as {email}." / `auth_magic_link_sign_out_first`: "Sign out to use this link" / `auth_magic_link_go_to_dashboard`: "Go to dashboard" |

### Phase 5: Validation

| Task | Details |
|------|---------|
| `bun run lint &amp;&amp; bun run typecheck` | Ensure no regressions |
| `bun run test` | Run existing tests |
| `bun run i18n:validate` | Confirm EN + FR in sync |
| Manual test each slice | V1: unregistered email → error. V2: expired/invalid token → specific message. V3: signed in + click link → warning. |

**Note:** Phases 1-4 can be developed sequentially (Phase 1 → 2 share the same error path, Phase 3-4 both modify `verify.tsx`). Phase 5 runs after all.

## Success Criteria

- [ ] Clicking a valid, unexpired magic link while not signed in successfully creates a session and redirects to dashboard (happy path, no regression)
- [ ] Submitting a magic link for an unregistered email shows "No account found for this email"
- [ ] Submitting a magic link for a registered email still sends the link (no regression)
- [ ] Clicking an expired magic link shows "This link has expired. Request a new one." with a button to go to login
- [ ] Clicking an already-used magic link shows "This link is invalid or has already been used."
- [ ] Visiting `/magic-link/verify` with no token shows "No verification link found."
- [ ] Visiting `/magic-link/verify?token=xxx` while signed in shows "You're already signed in as {email}" with sign-out and dashboard buttons
- [ ] Clicking "Sign out to use this link" signs out and re-verifies the token
- [ ] Visiting `/magic-link/verify` with no token while signed in redirects to `/dashboard`
- [ ] All new strings have EN and FR translations
- [ ] `bun run lint &amp;&amp; bun run typecheck &amp;&amp; bun run test` passes
- [ ] `bun run i18n:validate` shows zero missing keys

## Open Questions

1. **`APIError` propagation:** Does Better Auth's `APIError` thrown in `sendMagicLink` callback propagate the `message` field as `error.code` or `error.message` to the SDK client? Needs testing during implementation. If the SDK wraps it differently, the frontend error detection in `-login-handlers.ts` needs to adjust.

2. **Verify endpoint redirect vs SDK:** Better Auth's verify endpoint uses HTTP redirects with `?error=<code>`. The SDK client wraps this — need to confirm that `error.code` is populated with `INVALID_TOKEN` / `EXPIRED_TOKEN` in the returned error object. If the SDK returns a generic error, we may need to extract from the redirect URL.
