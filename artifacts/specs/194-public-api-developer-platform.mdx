---
title: "Public API & Developer Platform + AI Assistant"
description: API key management, per-key rate limiting, versioned public API controllers, CLI generation, and an end-user AI assistant framework — three interfaces on one API.
---

## Context

Roxabi needs a public API to support external integrations, third-party developers, and AI agents. The platform has strong foundations: Better Auth for session-based auth, a two-tier rate limiting system (Upstash Redis), RBAC with granular permissions, OpenAPI/Swagger docs, and multi-tenant architecture with org-scoped data.

This spec covers the full "Developer Platform" epic (#194) which groups three interface layers sharing one OpenAPI spec:

1. **Public API** — API key CRUD (#318), auth guard (#319), versioned controllers (#320), rate limiting (#321)
2. **CLI** — Generated CLI (#322) with device code auth (#323)
3. **AI Assistant** — Tool registry from OpenAPI (#325), NestJS streaming module (#326), chat UI component (#327)

**Promoted from:** [Public API &amp; Developer Platform Analysis](../analyses/194-public-api-developer-platform.mdx)

**Complexity score:** 8/10 (Tier F-full)

## Goal

Provide a versioned, key-authenticated public API (`/api/v1/`) with per-key rate limiting, a management UI, a build-time-generated CLI, and an end-user AI assistant — three interfaces (REST, CLI, chat) sharing one OpenAPI spec and tool registry, enabling external developers, AI agents, and end users to interact with the Roxabi platform.

## Users &amp; Use Cases

### External developers (integrations)

- **Workflow:** Create an API key in the settings UI → use `Authorization: Bearer sk_live_xxx` to call `/api/v1/*` endpoints → manage team members, orgs, roles programmatically
- **Needs:** Comprehensive OpenAPI docs, clear error messages, predictable rate limits, key rotation support

### AI agents (automation)

- **Workflow:** Receive an API key via env var or CLI login → call endpoints with `--json` output mode → parse structured responses
- **Needs:** Machine-parseable output, deterministic schemas, stable versioning, `--json` flag in CLI

### Org admins (key management)

- **Workflow:** Navigate to `/settings/api-keys` → create keys with scoped permissions → monitor usage → revoke compromised keys
- **Needs:** Clear scope selection UI, one-time key display with copy, usage visibility, easy revocation

### End users (AI assistant)

- **Workflow:** Open the AI assistant panel → ask a natural-language question ("who's on my team?", "invite alice@example.com as editor") → AI executes tools against the API → streams the answer
- **Needs:** Streaming chat UI, tool execution transparency, confirmation for destructive actions, conversation history, RBAC-scoped responses (only see/do what their role allows)

## Expected Behavior

### Happy path

**API key creation:**

1. Org admin navigates to `/settings/api-keys`
2. Clicks "Create API Key"
3. Enters a name, selects scopes (checkboxes filtered to their current permissions), optionally sets an expiry date
4. Clicks "Create" → server generates `sk_live_` + 32 random chars, hashes with per-key salt, stores hash + metadata
5. Full key is displayed **once** with a copy button and warning: "This key will not be shown again"
6. Key appears in the list with name, prefix + last 4 chars, scopes, created date, status

**API key authentication:**

1. Client sends `GET /api/v1/members` with `Authorization: Bearer sk_live_xxx`
2. `AuthGuard.canActivate()` finds no cookie session, detects Bearer token
3. Hashes the token, queries `api_keys` by hash (indexed, timing-safe compare)
4. Verifies: not revoked, not expired, org is active
5. Constructs synthetic `AuthenticatedSession`: `user.id` = key owner, `session.activeOrganizationId` = key's tenant, `permissions` = key scopes ∩ org's current permissions
6. Request proceeds through existing `@Permissions()` decorator pipeline
7. Response includes `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset` headers

**CLI authentication (device code):**

1. User runs `roxabi auth login`
2. CLI calls `POST /api/v1/auth/device-code` → receives `device_code`, `user_code`, `verification_url`
3. CLI opens browser to `/auth/device` (standalone page)
4. User logs in via Better Auth (if needed), enters `user_code`
5. Page displays the requested scopes and key name (`CLI - {hostname}`) before the user clicks "Authorize"
6. Server marks device code as approved, creates an API key with name `CLI - {hostname}` and full user permissions as scopes
7. CLI polls `POST /api/v1/auth/device-token` → receives the API key
8. Key stored in `~/.config/roxabi/credentials.json`
9. All subsequent CLI commands use the stored key

**CLI authentication (direct token):**

1. User runs `roxabi auth login --token sk_live_xxx`
2. CLI validates the key by calling `GET /api/v1/users/me`
3. If valid, key stored in `~/.config/roxabi/credentials.json`
4. Used for CI/CD or environments without a browser

**CLI usage:**

1. `roxabi members list` → fetches `GET /api/v1/members` → displays formatted table
2. `roxabi members list --json` → same request → outputs raw JSON
3. `roxabi orgs get` → fetches `GET /api/v1/organizations` → displays org details

**AI assistant (chat):**

1. User clicks the AI assistant toggle (or presses `Cmd+K`) on any authenticated page
2. Chat panel opens with conversation history sidebar
3. User types "who's on my team?"
4. Frontend calls `POST /api/chat` with the message via `useChat()` (session auth)
5. NestJS AI module resolves the user's RBAC permissions → filters tool registry to permitted tools
6. Vercel AI SDK `streamText()` sends the message + available tools to the configured LLM
7. LLM calls the `list_members` tool → module executes `AdminMembersService.findAll()` with session context
8. Tool result returned to the LLM → LLM streams a natural-language summary
9. Chat UI renders the streaming response with an inline "Members queried" tool card
10. Conversation + messages persisted to Postgres (per-user, per-tenant)

**AI assistant (destructive action):**

1. User asks "remove bob from the team"
2. LLM calls `delete_member` tool (marked `confirm: true`)
3. Instead of executing, the module returns a confirmation request to the frontend
4. Chat UI shows an inline confirm/cancel card: "Remove Bob Smith from Acme Corp?"
5. User clicks "Confirm" → tool executes → member removed → action audit-logged with `actorType: 'ai_assistant'`

### Edge cases

| Scenario | Behavior |
|----------|----------|
| Invalid/unknown API key | 401 with `API_KEY_INVALID` error code |
| Revoked key used | 401 with `API_KEY_REVOKED` error code |
| Expired key used | 401 with `API_KEY_EXPIRED` error code |
| Key scope insufficient for endpoint | 403 with `API_KEY_SCOPE_DENIED` error code |
| Rate limit exceeded | 429 with `API_KEY_RATE_LIMITED` error code + `Retry-After` header |
| User soft-deleted after key creation | Guard skips soft-delete check for `actorType === 'api_key'`; key still works if not revoked |
| User role downgraded after key creation | Runtime intersection: key's effective permissions shrink to (stored scopes ∩ current org permissions) |
| User role upgraded after key creation | Key scopes do NOT expand — they remain as originally granted. Users must create a new key to get new permissions. |
| Org deleted | All org's API keys cascade-revoked automatically |
| User deleted | All user's API keys cascade-revoked automatically |
| Superadmin creates API key | Guard checks `actorType === 'api_key'` **before** the superadmin early-return in `checkPermissions()` — API key auth always enforces scope checks regardless of the owner's role |
| Key created with empty scopes | Key authenticates but has no permissions — all `@Permissions()` checks fail with 403 |
| Session user hits `@RequireApiKey()` route | 401 with `API_KEY_INVALID` error code — session auth is rejected on public-only endpoints |
| Bearer token in wrong format | Ignored — falls through to standard 401 (no cookie session found) |
| Device code expired (CLI) | CLI shows "Code expired, please try again" and restarts the flow |
| Device code not yet approved (CLI polling) | CLI continues polling with exponential backoff, shows "Waiting for authorization..." |
| Device code brute-force attempt | `/auth/device` page rate-limited (5 attempts/min). User codes are single-use and invalidated after entry or expiry. |
| `lastUsedAt` update fails | Fire-and-forget — request proceeds normally, failure logged at WARN level. Usage tracking is best-effort. |
| AI tool call with insufficient permissions | Tool filtered out of available tools before LLM sees it. If somehow called, returns 403 and LLM explains the permission gap. |
| AI tool execution fails | Error returned to LLM as tool result → LLM explains the failure to the user in natural language. |
| AI conversation in deleted/suspended org | Session auth fails before reaching AI module — standard 401/403. |
| AI assistant with no available tools | LLM responds in conversation mode only (no tool calls). Explains it cannot perform actions with the user's current permissions. |
| AI provider API down or rate-limited | Streaming endpoint returns 503 with retry guidance. Chat UI shows "AI temporarily unavailable" with retry button. |
| AI conversation token limit exceeded | Oldest messages summarized automatically to fit context window. User sees full history in UI but LLM operates on windowed context. |

## Breadboard

### UI Affordances

| ID | Element | Location | Trigger |
|----|---------|----------|---------|
| U1 | "API Keys" tab | `/settings` sidebar | Click nav item |
| U2 | "Create API Key" button | `/settings/api-keys` page | Click button |
| U3 | Create key form (name, scopes, expiry) | Modal or inline form | U2 click |
| U4 | Key display (one-time, copy button) | Post-creation dialog | After U3 submit |
| U5 | Key list table | `/settings/api-keys` page | Page load |
| U6 | "Revoke" button per key | Key list row action | Click button |
| U7 | Revoke confirmation dialog | Modal (DestructiveConfirmDialog) | U6 click |
| U8 | Device authorization page | `/auth/device` (standalone) | Browser open from CLI |
| U9 | Code input + "Authorize" button | `/auth/device` page | User enters code |
| U10 | `<AiAssistant />` chat panel | Any authenticated page | Toggle button or `Cmd+K` |
| U11 | Message list + input field | Chat panel | User types + sends |
| U12 | Tool execution cards | Chat message stream | AI calls a tool |
| U13 | Destructive action confirm/cancel | Inline in chat | AI requests destructive tool |
| U14 | Conversation history sidebar | Chat panel left rail | Click history icon |

### Code Affordances

| ID | Handler | Wiring | Logic |
|----|---------|--------|-------|
| N1 | `POST /api/v1/api-keys` | U3 → N1 → S1 | Validate scopes ⊆ user permissions, generate key, hash with salt, store, return full key once |
| N2 | `GET /api/v1/api-keys` | U5 → N2 → S1 | List keys for current org (mask key, show prefix + last 4) |
| N3 | `DELETE /api/v1/api-keys/:id` | U7 → N3 → S1 | Set `revokedAt` timestamp, audit log |
| N4 | `AuthGuard.canActivate()` extension | Bearer token → N4 → S1 | Hash token, lookup, verify, construct synthetic session |
| N5 | `GET /api/v1/organizations` | External client → N5 → S2 | Thin controller calling `OrganizationService` |
| N6 | `GET/POST/PATCH/DELETE /api/v1/members` | External client → N6 → S2 | Thin controller calling `AdminMembersService` |
| N7 | `GET/POST/DELETE /api/v1/invitations` | External client → N7 → S2 | Thin controller calling `AdminInvitationsService` |
| N8 | `GET/POST/PATCH/DELETE /api/v1/roles` | External client → N8 → S2 | Thin controller calling `RbacService` |
| N9 | `GET /api/v1/users/me` | External client → N9 → S2 | Thin controller calling `UserService` |
| N10 | `CustomThrottlerGuard` extension | N4 → N10 → S3 | Detect API key auth → apply `api` tier → track by `apikey:${keyId}` |
| N11 | `POST /api/v1/auth/device-code` | CLI → N11 → S4 | Generate device code + user code, store with TTL |
| N12 | `POST /api/v1/auth/device-token` | CLI polling → N12 → S4, S1 | Check device code status, return API key when approved |
| N13 | Device code confirmation | U9 → N13 → S4 | Verify user code, mark device code as approved |
| N14 | CLI codegen pipeline | Build step → N14 | `openapi-typescript` generates typed client from spec |
| N15 | CLI command modules | User terminal → N15 → N5-N9 | Commander.js commands calling generated client |
| N16 | Cascade revocation trigger | User/org deletion → N16 → S1 | Set `revokedAt` on all keys for the deleted user/org |
| N17 | OpenAPI-to-tools codegen | Build step → N17 | OpenAPI spec → Vercel AI SDK tool definitions (Zod schemas) |
| N18 | Tool registry | N17 → N18 | Maps tools to permissions, filters by user RBAC at runtime |
| N19 | `POST /api/chat` streaming endpoint | U11 → N19 → N18, S5 | Session auth, `streamText()`, tool execution, response streaming |
| N20 | `@AiTool()` decorator | NestJS services → N20 → N18 | Registers custom domain-specific tools with permission + confirm metadata |
| N21 | Tool execution pipeline | N19 → N21 → S2 | Resolves tool call → service method → executes with session context → returns result |
| N22 | Conversation context manager | N19 → N22 → S5 | Message history windowing, summarization, system prompt assembly |

### Data Stores

| ID | Store | Type | Accessed by |
|----|-------|------|-------------|
| S1 | `api_keys` table | Persistent (Postgres) | N1, N2, N3, N4, N10, N12, N16 |
| S2 | Existing service tables (users, organizations, members, roles, invitations) | Persistent (Postgres) | N5, N6, N7, N8, N9 |
| S3 | Upstash Redis (rate limit counters) | Transient (Redis) | N10 |
| S4 | `device_codes` table or in-memory store | Transient (TTL-based) | N11, N12, N13 |
| S5 | `conversations` + `messages` tables | Persistent (Postgres) | N19, N22 |

**Unknowns:**

- **S4 storage**: Device codes are short-lived (5-10 min TTL). Could use a Postgres table with TTL cleanup, or Upstash Redis with `SETEX`. Redis is simpler but adds a dependency for device auth. Decision deferred to CLI slice implementation.

## Slices

| Slice | Description | Affordances | Demo |
|-------|-------------|-------------|------|
| V1 | API key CRUD + management UI + type extensions | U1-U7, N1-N3, N16, S1 | Create an API key in the UI, see it listed (with status badges for active/expired/revoked), copy the key, revoke it. Keys cascade-revoke on user/org deletion. Includes `@repo/types` extensions (`AuditActorType`, `AuditAction`, `AuthenticatedSession`). |
| V2 | Auth guard extension | N4, S1 | Use a created API key as `Authorization: Bearer` header — the guard authenticates the request and constructs a synthetic session. Existing `@Permissions()` checks work. Superadmin scope bypass is blocked for API key auth. Rate limiting not yet active (wired in V4). |
| V3 | Public API controllers + Swagger | N5-N9, S2 | Call `GET /api/v1/members` with a valid API key and receive a JSON response. Public OpenAPI docs at `/api/v1/docs` (separate Swagger instance). 5 resource groups functional (orgs, members, invitations, roles, users/me). API key self-management (N1-N3) was delivered in V1. |
| V4 | Rate limiting tier | N10, S3 | Hit the API repeatedly with an API key — after 100 requests in 60s, receive 429 with `Retry-After` header. `X-RateLimit-*` headers on every response. N10 wires into the N4 pipeline from V2. |
| V5a | CLI package + direct token auth | N14-N15 | Run `roxabi auth login --token sk_live_xxx` → run `roxabi members list` → see formatted output. `--json` flag works. CLI builds from monorepo, npm-only distribution assumed. |
| V5b | Device code auth flow | U8-U9, N11-N13, S4 | Run `roxabi auth login` → complete device code flow in browser → CLI receives API key. Standalone `/auth/device` page with scope display and rate limiting. |
| V6a | AI tool registry + OpenAPI-to-tools codegen | N17-N18 | `packages/ai` generates Vercel AI SDK tool definitions from the V3 OpenAPI spec. Tool registry filters by RBAC permissions. Provider-agnostic (Claude/OpenAI/etc via env var). |
| V6b | NestJS AI module — streaming chat + conversations | N19-N22, S5 | `POST /api/chat` streams AI responses with tool calls. `@AiTool()` decorator for custom tools. Conversations persisted per-user, per-tenant. Destructive tools require confirmation. AI actions audit-logged. |
| V6c | `<AiAssistant />` chat UI component | U10-U14 | `@repo/ui` chat component with `useChat()`, streaming display, tool execution cards, confirmation UI for destructive actions, conversation history sidebar. Responsive + accessible. |

## Constraints

- **Better Auth sessions only** — no OAuth 2.0 authorization server exists. CLI uses device code pattern instead.
- **Existing guard architecture** — `AuthGuard` is a single global `APP_GUARD`. API key auth must integrate as a fallback, not a separate guard.
- **Upstash Redis dependency** — rate limiting already depends on Upstash. The `api` tier reuses the same storage.
- **Drizzle ORM patterns** — new schema must use `tenantColumn`, `timestamps`, inline `genId`, matching existing conventions.
- **`audit_logs.actorId` FK to `users.id`** — API key audit events use the key owner's `userId` as `actorId` (valid FK) plus a new `apiKeyId` column for traceability.
- **`AuditActorType` is a closed union in `@repo/types`** — must be extended with `'api_key'`. Same for `AuditAction` (add `api_key.created`, `api_key.revoked`, `api_key.rotated`).
- **`AuthenticatedSession` type** — `session.id` is populated with the API key's `id` as a synthetic session identifier. Downstream code reading `session.session.id` sees the key ID.
- **Low scale initially** — &lt;1K keys, &lt;100 req/s. No caching layer needed. Standard Postgres indexed queries suffice.
- **Vercel AI SDK** — provider abstraction layer. All LLM calls go through `ai` package. Model configured via `AI_PROVIDER` + `AI_MODEL` + `AI_API_KEY` env vars. Default: Claude.
- **AI assistant uses session auth** — not API keys. The chat endpoint (`POST /api/chat`) authenticates via the existing session cookie, not `@RequireApiKey()`. External AI agents use the CLI/API path with API keys instead.
- **Tool definitions generated from OpenAPI** — same spec that powers V5a CLI codegen also generates AI tool definitions. One source of truth, three interfaces.
- **`conversations` + `messages` tables** — Drizzle schema with `tenantColumn`, `timestamps`, `genId`. Messages store role (`user`/`assistant`/`tool`), content, and optional tool call metadata.

## Non-goals

- **`sk_test_` prefix / sandbox mode** — reserved in the key format but not implemented in V1
- **HATEOAS links** in public API responses
- **Premium rate limit tier** — schema column exists (`rateLimitTier`) but only `'standard'` is implemented
- **Atomic key rotation** — supported via manual create-then-revoke pattern; no single "rotate" endpoint
- **V2 versioning / deprecation policy** — V1 ships without a formal deprecation policy
- **Third-party OAuth app registration** — no OAuth provider for external apps to "Login with Roxabi"
- **Webhook notifications** for API events
- **SDK generation** beyond CLI (e.g., Python/Go client libraries)
- **API usage analytics dashboard** — `lastUsedAt` is tracked but no visualization in V1
- **Auto-revocation by inactivity** — no automatic key revocation based on `lastUsedAt`
- **Developer onboarding / getting-started guide** — `/api/v1/docs` Swagger is the V1 docs story; a dedicated getting-started guide is a follow-up
- **AI agent memory / RAG** — no vector store or document retrieval. AI operates on structured API tools only.
- **AI assistant for unauthenticated users** — chat requires session auth. No public-facing chatbot.
- **AI model fine-tuning** — uses off-the-shelf models via Vercel AI SDK providers.
- **Voice / multimodal input** — text-only chat interface in V6.
- **AI-to-AI orchestration** — the assistant executes single tool calls, not multi-step agent workflows.

## Technical Decisions

### API key auth as AuthGuard fallback

**Decision:** Extend the existing `AuthGuard.canActivate()` with a Bearer token fallback rather than creating a separate `ApiKeyGuard`.

**Rationale:** The guard already handles `@AllowAnonymous`, `@OptionalAuth`, `@Roles`, `@RequireOrg`, and `@Permissions`. A fallback approach reuses all of these decorators without changes. A separate guard would require marking routes explicitly and maintaining two guard patterns.

**New decorator:** `@RequireApiKey()` sets `SetMetadata('REQUIRE_API_KEY', true)`. When present, the guard rejects cookie session auth and only accepts API key auth — preventing session users from accessing public-only endpoints.

**Enforcement strategy:** `@RequireApiKey()` is applied at the **controller level** on all `/api/v1/` controllers (not per-route). This ensures every new route added to a V1 controller automatically requires API key auth — no risk of forgetting the decorator on individual routes.

**Decorator precedence:** `@AllowAnonymous()` does NOT override `@RequireApiKey()` — public V1 routes are not supported. `@Permissions()` works as normal on top of `@RequireApiKey()`. `@Roles()` is bypassed for API key auth (scopes replace role checks).

### Superadmin scope enforcement for API keys

**Decision:** The `checkPermissions()` method's superadmin early-return (`if (session.user.role === 'superadmin') return`) must check `actorType` first. When `actorType === 'api_key'`, scope checks are always enforced regardless of the owner's role.

**Rationale:** Without this, a superadmin-owned API key with empty scopes has full access — a scope leak. The fix is a single guard: `if (session.user.role === 'superadmin' && session.actorType !== 'api_key') return`.

### Cascade revocation mechanism

**Decision:** Cascade revocation fires via an `EventEmitter2` event listener. When the existing user/org deletion logic emits its event, a new listener in the `ApiKeyModule` sets `revokedAt` on all matching keys.

**Rationale:** The codebase already uses `EventEmitter2` for cross-domain side effects. This avoids coupling the deletion services to the API key module directly.

### Public API response DTOs

**Decision:** Public V1 controllers use **purpose-built DTOs** that explicitly define the public contract. These DTOs select specific fields from service results and exclude internal fields (e.g., internal IDs, audit metadata).

**Rationale:** Decouples the public API contract from internal service evolution. Any change to an internal service's return shape does not accidentally become a breaking public API change. The mapping overhead is minimal (one DTO class per resource).

### Scopes as RBAC permission subsets

**Decision:** API key scopes are a subset of existing RBAC permission strings, intersected with the org's current permissions **at runtime**.

**Rationale:** No parallel permission system needed. Runtime intersection prevents stale elevated access if a user's role is downgraded after key creation.

### Build-time CLI codegen (Shape 1)

**Decision:** Use `openapi-typescript` to generate typed client code at build time. CLI wraps the generated client with Commander.js.

**Rationale:** Type safety, offline capability, rich help text, and deterministic behavior. The codegen pipeline doubles as a contract test — breaking API changes fail the build. Version drift is manageable via CI regeneration.

### Device code auth flow for CLI

**Decision:** Use a device code pattern (similar to OAuth 2.0 Device Authorization Grant) instead of building a full OAuth 2.0 authorization server.

**Rationale:** Better Auth provides session auth, not an OAuth 2.0 AS. The device code flow requires only two new API endpoints + one standalone web page, dramatically simpler than standing up an authorization server.

**Security requirements (RFC 8628 §5.4):**
- `/auth/device` page is rate-limited (5 attempts/min per IP)
- User codes are single-use — invalidated after successful entry or expiry (5-10 min TTL)
- The authorization page displays the key name (`CLI - {hostname}`) and requested scopes before the user clicks "Authorize"
- Device codes use cryptographically random values (32 bytes)

**Device-created key defaults:** Name = `CLI - {hostname}` (auto-generated), scopes = all permissions available to the authorizing user. Users can later revoke or modify the key via the management UI.

### AI tool registry from OpenAPI (three interfaces, one spec)

**Decision:** The same OpenAPI spec generated by V3 controllers is used to produce both CLI commands (V5a, via `openapi-typescript`) and AI tool definitions (V6a, via a custom codegen step that outputs Vercel AI SDK `tool()` calls with Zod parameter schemas).

**Rationale:** One source of truth eliminates drift between interfaces. Adding a new public API endpoint automatically gives the CLI a new command and the AI a new tool — zero extra work. The codegen pipeline for AI tools mirrors the CLI pipeline, making both contract-tested against the same spec.

### Vercel AI SDK as provider abstraction

**Decision:** Use the Vercel AI SDK (`ai` package) for all LLM interactions. Provider configured via env vars (`AI_PROVIDER`, `AI_MODEL`, `AI_API_KEY`). Default: `anthropic` / `claude-sonnet-4-5`.

**Rationale:** The project already deploys on Vercel. The AI SDK provides: unified provider interface (swap models without code changes), built-in streaming (`streamText`), tool-use protocol, React hooks (`useChat`), and structured output via Zod. No custom streaming or tool-call parsing needed.

### Session auth for AI assistant (not API keys)

**Decision:** The AI chat endpoint (`POST /api/chat`) uses session cookie auth. It does not require or accept API key auth.

**Rationale:** The AI assistant is for logged-in end users, not external integrations. Session auth gives the AI module direct access to the user's full session context (user, org, permissions) without the indirection of API key scope intersection. External AI agents use the CLI/API path with API keys instead — different interface, same underlying services.

### Destructive tool confirmation

**Decision:** Tools decorated with `@AiTool({ confirm: true })` return a confirmation request to the frontend instead of executing immediately. The frontend renders a confirm/cancel UI. Execution proceeds only after explicit user confirmation.

**Rationale:** AI should never perform irreversible actions (delete member, revoke key, remove org) without human approval. This is consistent with the audit-first philosophy of the platform.

### Error response envelope

**Decision:** Public API errors use a consistent envelope:

```json
{
  "error": {
    "code": "API_KEY_INVALID",
    "message": "Human-readable description.",
    "statusCode": 401
  }
}
```

**Rationale:** Based on the existing `AllExceptionsFilter` format. New error codes: `API_KEY_INVALID`, `API_KEY_REVOKED`, `API_KEY_EXPIRED`, `API_KEY_RATE_LIMITED`, `API_KEY_SCOPE_DENIED`.

### `lastUsedAt` as fire-and-forget

**Decision:** The `lastUsedAt` update on every API key auth is a non-blocking, fire-and-forget async write.

**Rationale:** Adding a synchronous DB write to every authenticated request adds latency. At low scale this is fine async. If the update fails, the request proceeds normally — failure is logged at WARN level. Usage tracking is best-effort. Auto-revocation by inactivity is a non-goal for V1.

### Tracker resolution in throttler

**Decision:** Inside `handleRequest()`, when `throttler.name === 'api'`, short-circuit the normal `getTracker()` call and use `req.apiKey?.id` directly (set on the request by `AuthGuard` during API key auth). The `api` tier is skipped entirely for non-API-key requests.

**Rationale:** `handleRequest()` already uses `throttler.name` to gate tier-specific logic (see `shouldApplyAuthTier` pattern). The `api` tier follows the same approach. A new `'api'` entry must be added to the `throttlers` array in `ThrottlerConfigModule.useFactory`.

### Dual Swagger instances

**Decision:** Two separate `SwaggerModule.setup()` calls: the existing internal Swagger at `/api/docs` (unchanged) and a new public API Swagger at `/api/v1/docs` built from a separate `DocumentBuilder` that only includes V1 controllers via `@ApiTags`.

**Rationale:** Internal and public APIs have different consumers, different auth schemes, and different response shapes. A single Swagger instance mixing both would confuse external developers. The V1 instance uses `addApiKey()` security scheme (not `addBearerAuth()`) to match the API key auth model.

## Success Criteria

- [ ] Organizations can create, list, and revoke API keys via the management UI at `/settings/api-keys`
- [ ] API keys authenticate requests to all `/api/v1/*` routes via `Authorization: Bearer` header
- [ ] `@Permissions()` decorator works identically for session and API key auth
- [ ] Scopes are runtime-intersected with org permissions (no stale elevated access)
- [ ] Rate limiting applies per API key at the `api` tier (100 req/60s default)
- [ ] `X-RateLimit-*` headers present on all API key responses
- [ ] 5 resource groups functional under `/api/v1/` (organizations, members, invitations, roles, users/me) + api-keys self-management
- [ ] Superadmin-owned API keys enforce scope checks (no superadmin bypass for API key auth)
- [ ] Public API docs available at `/api/v1/docs` (separate from internal Swagger)
- [ ] CLI authenticates via device code flow and stores key locally
- [ ] CLI mirrors all V1 endpoints as hierarchical commands with `--json` output mode
- [ ] CLI supports `--token` direct auth for CI/CD environments
- [ ] CLI package builds and runs from the monorepo (`packages/cli`)
- [ ] API key events logged in audit trail with correct `actorId` (user FK) and `apiKeyId`
- [ ] Keys cascade-revoke when owning user or org is deleted
- [ ] Error responses follow the documented envelope format with correct error codes
- [ ] `packages/ai` generates tool definitions from the V3 OpenAPI spec at build time
- [ ] AI tool registry filters available tools by user's RBAC permissions at runtime
- [ ] `POST /api/chat` streams AI responses with tool execution to session-authenticated users
- [ ] `@AiTool()` decorator registers custom tools from any NestJS service method
- [ ] Destructive AI tool calls require explicit user confirmation before execution
- [ ] AI conversations persisted per-user, per-tenant with multi-tenant isolation
- [ ] AI-executed actions logged in audit trail with `actorType: 'ai_assistant'`
- [ ] `<AiAssistant />` component renders streaming chat with tool cards, confirmation UI, and conversation history

## Open Questions

- **Device code storage (S4):** Should device codes use a Postgres table with TTL cleanup or Upstash Redis with `SETEX`? Redis is simpler but adds a new use case for the Redis dependency. Decision deferred to V5b implementation.
- **CLI distribution:** V5a assumes npm-only distribution from the monorepo. GitHub Releases / Homebrew are a follow-up if needed.
- **CLI update mechanism:** Deferred — not in V5a/V5b scope. Can be added post-launch.
- **AI conversation retention policy:** How long are conversations kept? Indefinite with manual delete, or auto-expire after N days? Decision deferred to V6b implementation.
- **AI model default:** Claude Sonnet 4.5 is the default. Should there be a per-tenant model override, or is global config sufficient for V6? Decision deferred.
- **AI system prompt customization:** Should SaaS builders be able to customize the AI assistant's personality/instructions per deployment? Deferred — V6 ships with a sensible default system prompt.
