---
title: "Plan: Backend Architecture Vision — DDD + Hexagonal"
issue: 317
spec: artifacts/specs/317-backend-architecture-vision.mdx
complexity: 5/10
tier: F-full
generated: 2026-02-27
---

## Summary

Documentation-only plan to produce `docs/architecture/backend-ddd-hexagonal.mdx` — a unified DDD + Hexagonal vision doc with decision criteria, target-state patterns, Mermaid diagrams, and an rbac migration guide — plus minor edits to three existing files.

## Bootstrap Context

Codebase audit (#256) confirmed: DDD maturity minimal (4 domain events, ~40+ exception files, no aggregates/value objects), Hexagonal absent (no ports/adapters — except `EmailProvider` as a proto-port). Analysis at `artifacts/analyses/317-backend-architecture-vision.mdx`.

Key real-code anchors for doc-writer:
- `apps/api/src/auth/email/email.provider.ts` — proto-port pattern (type + Symbol token)
- `apps/api/src/common/events/` — 4 domain events
- `apps/api/src/rbac/rbac.listener.ts` — cross-module event consumer
- `apps/api/src/rbac/rbac.service.ts` — current CRUD-style service (migration guide subject)
- `admin/exceptions/orgNotFound.exception.ts` + `organization/exceptions/orgNotFound.exception.ts` — shared kernel motivating example

Ref pattern: `docs/architecture/rbac.mdx` (frontmatter, overview, Mermaid, TypeScript code fences, section structure).

## Agents

| Agent | Task count | Files |
|-------|-----------|-------|
| doc-writer | 16 | `docs/architecture/backend-ddd-hexagonal.mdx` (new), `docs/architecture/meta.json`, `docs/architecture/index.mdx`, `docs/standards/backend-patterns.mdx` |

## Consistency Report

| Metric | Count |
|--------|-------|
| Success criteria covered | 10/10 |
| Uncovered criteria | 0 |
| Untraced micro-tasks | 0 |

## Micro-Tasks

---

### V1 — Decision Framework

> **Slice goal:** Overview + When to Adopt section. Independently reviewable — decision table is standalone value.

---

**MT1** — Write frontmatter + Overview section
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx` (create new)
- **Agent:** doc-writer
- **Snippet:**
  ```mdx
  ---
  title: Backend Architecture Vision — DDD + Hexagonal
  description: Target-state patterns for DDD and Hexagonal Architecture — when to adopt, how to migrate
  ---

  ## Overview

  This document describes the *target architecture* for Roxabi backends when domain complexity warrants it...
  ```
- **Verify:** `ls docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** file exists
- **Time:** 3 min
- **Spec trace:** SC-deliverables-1
- **Slice:** V1
- **Phase:** RED
- **Difficulty:** 1

---

**MT2** — Write When to Adopt decision criteria table (≥5 rows)
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet:**
  ```mdx
  ## When to Adopt

  | Observable signal | Pattern to add |
  |-------------------|---------------|
  | Module has >3 operations that validate pre-conditions on the same entity | Value objects + domain entities |
  | Module calls >1 external service that may be swapped or mocked | Define a port (interface + Symbol token) |
  | Module owns >2 entities with cross-entity invariants | Aggregate root |
  | Two modules reference the same domain concept with different exception classes | Shared kernel |
  | Domain logic needs to be tested without hitting the database | Repository port + in-memory adapter |
  | Better Auth / ORM types leak into business logic | Anti-Corruption Layer |
  ```
- **Verify:** `grep -c "| " docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** ≥6 (header + 5 data rows)
- **Time:** 5 min
- **Spec trace:** SC-structure-1
- **Slice:** V1
- **Phase:** GREEN
- **Difficulty:** 3

---

**RED-GATE V1** — Verify decision table ≥5 rows and file renders

```bash
grep -c "^|" docs/architecture/backend-ddd-hexagonal.mdx   # expect ≥6
head -5 docs/architecture/backend-ddd-hexagonal.mdx         # expect frontmatter
```

---

### V2 — Current Baseline + DDD Patterns

> **Slice goal:** Ground the doc in existing code, then show DDD target patterns with TypeScript snippets.

---

**MT3** — Write Current Baseline section
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** Inventory the real patterns already in the codebase. Reference `EmailProvider` (proto-port), 4 domain events in `src/common/events/`, ~40+ exception files, `RbacListener`. Explain why these are DDD/Hexagonal adjacent but not complete.
- **Verify:** `grep "EmailProvider" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 5 min
- **Spec trace:** SC-structure-2
- **Slice:** V2
- **Phase:** RED
- **Difficulty:** 2

---

**MT4** — Write DDD: branded types + value objects snippets
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet (illustrative — ≤30 lines, no drizzle-orm imports):**
  ```ts
  // Branded type (prevent primitive obsession)
  type UserId = string & { readonly _brand: 'UserId' }
  type RoleSlug = string & { readonly _brand: 'RoleSlug' }

  // Value object (immutable, equality by value)
  class Email {
    private constructor(private readonly value: string) {}
    static create(raw: string): Email {
      if (!raw.includes('@')) throw new Error('Invalid email')
      return new Email(raw.toLowerCase())
    }
    toString() { return this.value }
  }
  ```
- **Verify:** `grep "brand" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 5 min
- **Spec trace:** SC-structure-2
- **Slice:** V2
- **Phase:** GREEN
- **Difficulty:** 3

---

**MT5** — Write DDD: entities + aggregates snippets
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet (illustrative — ≤30 lines):**
  ```ts
  // Domain entity (identity-based equality)
  class Role {
    constructor(
      public readonly id: RoleId,
      private name: string,
      private readonly tenantId: OrganizationId,
    ) {}
    rename(newName: string) { this.name = newName }
  }

  // Aggregate root (enforces invariants across entities)
  class OrganizationRoles {
    private roles: Role[] = []
    addRole(role: Role) {
      if (this.roles.some(r => r.name === role.name))
        throw new RoleSlugConflictException(role.name)
      this.roles.push(role)
    }
  }
  ```
- **Verify:** `grep "Aggregate\|aggregate" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 5 min
- **Spec trace:** SC-structure-2
- **Slice:** V2
- **Phase:** GREEN
- **Difficulty:** 3

---

**MT6** — Write DDD: domain services + Application Service (≤40 lines, tx ownership explicit)
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet (application service — ≤40 lines; transaction coordination belongs here):**
  ```ts
  // Application service — orchestrates: validate → load → domain call → persist → emit
  // Transaction boundary is HERE, not in aggregates or domain services
  class RbacApplicationService {
    constructor(
      private readonly roleRepo: RoleRepository,  // port (interface)
      private readonly events: EventEmitter2,
    ) {}

    async createRole(cmd: CreateRoleCommand): Promise<RoleId> {
      // 1. Load aggregate (via port — no Drizzle here)
      const orgRoles = await this.roleRepo.loadForOrg(cmd.tenantId)
      // 2. Domain call (enforces invariants)
      const role = orgRoles.addRole(cmd.name, cmd.permissions)
      // 3. Persist via port (adapter handles transaction + tenantService.query())
      await this.roleRepo.save(role)
      // 4. Emit event at aggregate boundary (forward-looking — new event)
      await this.events.emitAsync(ROLE_CREATED, new RoleCreatedEvent(role.id))
      return role.id
    }
  }
  ```
- **Verify:** `grep "Application Service\|ApplicationService" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 8 min
- **Spec trace:** SC-structure-2
- **Slice:** V2
- **Phase:** GREEN
- **Difficulty:** 4

---

**RED-GATE V2** — Verify all DDD snippets present, no forbidden imports in domain snippets

```bash
grep "drizzle-orm\|@nestjs\|fastify" docs/architecture/backend-ddd-hexagonal.mdx | grep -v "# infrastructure" | grep -v "adapter\|Adapter" || echo "PASS — no forbidden imports in domain snippets"
grep -E "brand|Aggregate|ApplicationService" docs/architecture/backend-ddd-hexagonal.mdx
```

---

### V3 — Hexagonal Patterns

> **Slice goal:** Ring diagram, port/adapter/repository patterns, ACL, shared kernel, not-domain-layer section.

---

**MT7** — Write Hexagonal: concentric ring Mermaid diagram
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet:**
  ````mdx
  ## Hexagonal Patterns

  ### Layer Model

  ```mermaid
  graph TD
    subgraph Domain["Domain Layer (innermost)"]
      E[Entities / Aggregates]
      VO[Value Objects]
      P[Ports — interfaces]
    end
    subgraph App["Application Layer"]
      AS[Application Services]
    end
    subgraph Infra["Infrastructure Layer (outermost)"]
      A[Adapters — Drizzle, Email, Events]
      C[Controllers — NestJS HTTP]
    end
    App --> Domain
    Infra --> App
  ```
  ````
- **Verify:** `grep "mermaid" docs/architecture/backend-ddd-hexagonal.mdx | wc -l`
- **Expected output:** ≥1
- **Time:** 5 min
- **Spec trace:** SC-structure-3
- **Slice:** V3
- **Phase:** RED
- **Difficulty:** 2

---

**MT8** — Write Hexagonal: port + adapter + repository snippets
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** Port = interface in domain layer with Symbol token. Adapter = class in infrastructure, registered via `useClass`. Repository = port in domain (`RoleRepository`), adapter in infrastructure (`DrizzleRoleRepository`). Use `EmailProvider` as the existing example (proto-port).
- **Snippet (port — domain layer, no Drizzle):**
  ```ts
  // rbac/ports/role.repository.ts  ← domain layer
  export const ROLE_REPOSITORY = Symbol('ROLE_REPOSITORY')
  export interface RoleRepository {
    loadForOrg(tenantId: OrganizationId): Promise<OrganizationRoles>
    save(roles: OrganizationRoles): Promise<void>
  }
  ```
- **Snippet (adapter — infrastructure layer):**
  ```ts
  // rbac/adapters/drizzle-role.repository.ts  ← infrastructure layer
  @Injectable()
  export class DrizzleRoleRepository implements RoleRepository {
    constructor(@Inject(DRIZZLE) private readonly db: DrizzleDB) {}
    async loadForOrg(tenantId: OrganizationId): Promise<OrganizationRoles> { /* Drizzle query here */ }
    async save(roles: OrganizationRoles): Promise<void> { /* Drizzle update here */ }
  }
  ```
- **Verify:** `grep "ROLE_REPOSITORY\|RoleRepository" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 2 matches
- **Time:** 8 min
- **Spec trace:** SC-structure-3
- **Slice:** V3
- **Phase:** GREEN
- **Difficulty:** 4

---

**MT9** — Write Hexagonal: ACL + Shared Kernel (orgNotFound motivating example)
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** ACL section: translate Better Auth user/session models into local domain types at module boundaries. Shared kernel: `admin/exceptions/orgNotFound.exception.ts` and `organization/exceptions/orgNotFound.exception.ts` are semantically identical — this is the problem. Solution: promote the shared exception to `@repo/types` or a shared `common/` package.
- **Verify:** `grep "orgNotFound\|OrgNotFound\|shared kernel\|Shared Kernel" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 6 min
- **Spec trace:** SC-structure-3, SC-content-5
- **Slice:** V3
- **Phase:** GREEN
- **Difficulty:** 3

---

**MT10** — Write "What Does NOT Belong in the Domain Layer" section
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** Explicit negative-space section. List: NestJS decorators (`@Injectable`, `@Controller`), HTTP types (`FastifyRequest`, `Response`), Drizzle ORM types (`DrizzleDB`, `DrizzleTx`, `eq`, `and`), transaction coordination (`db.transaction()`, `tenantService.query()`). Show short "wrong" vs "right" examples.
- **Verify:** `grep "@Injectable\|DrizzleDB\|FastifyRequest" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match (in the negative-space section)
- **Time:** 5 min
- **Spec trace:** SC-structure-4, SC-content-4
- **Slice:** V3
- **Phase:** GREEN
- **Difficulty:** 2

---

**RED-GATE V3** — Verify Mermaid diagram + hexagonal sections + no forbidden imports in domain snippets

```bash
grep "mermaid" docs/architecture/backend-ddd-hexagonal.mdx | wc -l  # expect ≥1
grep "RoleRepository\|Anti-Corruption\|Shared Kernel" docs/architecture/backend-ddd-hexagonal.mdx
grep "orgNotFound\|OrgNotFound" docs/architecture/backend-ddd-hexagonal.mdx  # motivating example
```

---

### V4 — Unified Flow + Migration Guide

> **Slice goal:** Flow diagram showing full CreateRole use case + rbac migration guide (5 steps).

---

**MT11** — Write Unified Architecture: CreateRole Mermaid flow diagram
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Snippet:**
  ````mdx
  ## Unified Architecture

  ```mermaid
  sequenceDiagram
    participant C as Controller
    participant AS as RbacApplicationService
    participant R as RoleRepository (port)
    participant A as DrizzleRoleRepository (adapter)
    participant E as EventEmitter2
    participant L as RbacListener (cross-BC)

    C->>AS: createRole(cmd)
    AS->>R: loadForOrg(tenantId)
    R->>A: loadForOrg(tenantId)
    A-->>AS: OrganizationRoles aggregate
    AS->>AS: orgRoles.addRole(name, perms)
    AS->>R: save(orgRoles)
    R->>A: save(orgRoles) [tx here]
    AS->>E: emit(ROLE_CREATED)
    E->>L: handleRoleCreated(event)
  ```
  ````
- **Verify:** `grep "sequenceDiagram\|RbacListener" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match each
- **Time:** 6 min
- **Spec trace:** SC-structure-5
- **Slice:** V4
- **Phase:** RED
- **Difficulty:** 3

---

**MT12** — Write rbac Migration Guide (5 numbered steps)
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** Use rbac as the worked example. 5 steps: (1) branded types, (2) domain exceptions (already present — reinforce), (3) RoleRepository port + DrizzleRoleRepository adapter, (4) restructure RbacService → RbacApplicationService (not a new layer above — a restructuring), (5) introduce RoleCreated / RoleDeleted events at aggregate boundary (forward-looking, not relocation). Include the forward-looking note for step 5.
- **Verify:** `grep "Step 1\|Step 2\|Step 3\|Step 4\|Step 5" docs/architecture/backend-ddd-hexagonal.mdx | wc -l`
- **Expected output:** 5
- **Time:** 10 min
- **Spec trace:** SC-structure-6
- **Slice:** V4
- **Phase:** GREEN
- **Difficulty:** 4

---

**MT13** — Write Common Mistakes section
- **File:** `docs/architecture/backend-ddd-hexagonal.mdx`
- **Agent:** doc-writer
- **Notes:** List: importing `drizzle-orm` in domain classes; calling `tenantService.query()` from aggregates; placing `@Injectable()` on domain entities; using HTTP types inside application services; creating a new service layer above the current one instead of restructuring it.
- **Verify:** `grep "Common Mistakes\|common mistake" docs/architecture/backend-ddd-hexagonal.mdx`
- **Expected output:** at least 1 match
- **Time:** 4 min
- **Spec trace:** SC-structure-6
- **Slice:** V4
- **Phase:** REFACTOR
- **Difficulty:** 2

---

**RED-GATE V4** — Verify flow diagram + 5 migration steps + no NEEDS CLARIFICATION markers

```bash
grep "sequenceDiagram" docs/architecture/backend-ddd-hexagonal.mdx
grep -c "^### Step [1-5]" docs/architecture/backend-ddd-hexagonal.mdx  # expect 5
grep "\[NEEDS CLARIFICATION" docs/architecture/backend-ddd-hexagonal.mdx | wc -l  # expect 0
```

---

### Supporting Edits [P — parallel, after V4]

---

**MT14** `[P]` — Update `docs/architecture/meta.json`
- **File:** `docs/architecture/meta.json`
- **Agent:** doc-writer
- **Change:** Insert `"backend-ddd-hexagonal"` into the `pages` array after `"index"`:
  ```json
  "pages": [
    "index",
    "backend-ddd-hexagonal",
    "frontend",
    ...
  ]
  ```
- **Verify:** `grep "backend-ddd-hexagonal" docs/architecture/meta.json`
- **Expected output:** 1 match
- **Time:** 2 min
- **Spec trace:** SC-deliverables-2
- **Slice:** V4+
- **Phase:** GREEN
- **Difficulty:** 1

---

**MT15** `[P]` — Update `docs/architecture/index.mdx`
- **File:** `docs/architecture/index.mdx`
- **Agent:** doc-writer
- **Change:** Add a cross-reference sentence to the API section (line ~74), after the existing list of architecture doc links. Text: `"See [Backend Architecture Vision](./backend-ddd-hexagonal) for DDD and Hexagonal adoption criteria and migration strategies."`
- **Verify:** `grep "backend-ddd-hexagonal" docs/architecture/index.mdx`
- **Expected output:** 1 match
- **Time:** 2 min
- **Spec trace:** SC-deliverables-3
- **Slice:** V4+
- **Phase:** GREEN
- **Difficulty:** 1

---

**MT16** `[P]` — Update `docs/standards/backend-patterns.mdx`
- **File:** `docs/standards/backend-patterns.mdx`
- **Agent:** doc-writer
- **Change:** Add cross-reference note at the top of section `1.1 Code Organization` (after the module structure diagram, ~line 40). Text: `"> For guidance on adopting DDD and Hexagonal patterns as domain complexity grows, see [Backend Architecture Vision](../architecture/backend-ddd-hexagonal)."`
- **Verify:** `grep "backend-ddd-hexagonal" docs/standards/backend-patterns.mdx`
- **Expected output:** 1 match
- **Time:** 2 min
- **Spec trace:** SC-deliverables-4
- **Slice:** V4+
- **Phase:** GREEN
- **Difficulty:** 1
