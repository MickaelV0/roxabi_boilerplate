---
title: "Production Observability & Analytics Stack"
issue: 371
status: approved
tier: F-full
date: 2026-02-26
---

## Problem

We have zero production visibility. No structured logs, no error tracking, no product analytics, no performance monitoring. The existing Fastify logger outputs unstructured text with no correlation between requests. Errors in production are discovered by users, not by us. We cannot answer basic questions: "How many users hit this feature?", "What errors are happening right now?", "Is the app getting slower?"

The foundation pieces exist but are disconnected — audit log schema and UI (~60% built), consent framework (100% built), error handling with correlation IDs, and `web-vitals@5.1.0` installed but unused. This epic wires everything together into a coherent observability stack.

**Why now:** We're approaching production readiness. Launching without observability means flying blind — debugging via user reports, no data-driven product decisions, no performance baselines to detect regressions.

## Who

- **Primary:** Development team — needs structured logs for debugging, error alerts for incident response, performance data for optimization
- **Secondary:** Product team — needs analytics for feature adoption, user behavior, and data-driven decisions
- **Tertiary:** End users — benefit from faster bug detection and resolution

## Constraints

- **Vercel serverless**: No persistent processes — rules out Prometheus, Grafana, Elasticsearch without separate infrastructure
- **Budget**: Early-stage SaaS, target $0–50/month using free tiers (Sentry free, PostHog 1M events/mo free, Vercel Analytics built-in)
- **GDPR compliance**: PostHog must be consent-gated (analytics category via existing consent framework). Sentry needs PII sanitization via `beforeSend`. Audit logs are tenant-scoped via RLS
- **Stack compatibility**: Must work with Bun, TurboRepo, TanStack Start (React), NestJS + Fastify, Vercel deployment
- **Existing code**: Must integrate with existing audit log schema/service, consent framework, correlation ID system (`x-correlation-id`), and global exception filter
- **Cold start budget**: Combined SDK init overhead must stay negligible (~20ms max: Pino ~5ms + Sentry ~15ms)

## Out of Scope

- Self-hosted monitoring infrastructure (Grafana, ELK, Prometheus) — Vercel serverless architecture mismatch
- APM / distributed tracing (OpenTelemetry, Jaeger) — single API + web app, not a microservice mesh
- Custom monitoring dashboards — SaaS tool dashboards (Sentry, PostHog, Vercel) are sufficient
- Server-side analytics tracking (PostHog is client-side only for now)
- Log drain setup to Datadog — growth-stage upgrade; Pino structured JSON makes future drain trivial
- A/B testing via PostHog — feature flags in scope, but experimentation framework deferred
- PagerDuty / on-call rotation — basic Sentry alerting (Slack/email) in scope instead

## Chosen Stack

| Layer | Tool | Rationale |
|-------|------|-----------|
| Logging | Pino (`nestjs-pino`) | Fastify-native (same team), 5x faster than Winston, structured JSON |
| Errors | Sentry (`@sentry/node` + `@sentry/react` + `@sentry/nestjs`) | Vercel native integration, OSS, best TS/React support, source maps |
| Analytics + Feature flags | PostHog (`posthog-js`) | 1M events/mo free, includes feature flags, OSS, consent-gatable |
| Alerting | Sentry Alerts | Built-in: error spike / new issue → Slack/email. ~30min config |
| Performance | web-vitals + Lighthouse CI | Client metrics → PostHog, PR gate for regressions |
| Baseline | Vercel Analytics (built-in) | Free, always-on, zero code |
| Audit | PostgreSQL + RLS (existing) | Already built, needs auto-capture interceptor |

## Phased Delivery

| Phase | Scope | Tier | Dependencies |
|-------|-------|------|-------------|
| 1 | Pino structured logging | S | None (foundation) |
| 2a | Audit interceptor + RLS | F-lite | Phase 1 |
| 2b | Sentry (FE + BE + CI + alerting) | F-lite | Phase 1 |
| 3a | PostHog (analytics + feature flags, consent-gated) | S/F-lite | Phase 2b (error context) |
| 3b | web-vitals + Lighthouse CI | S | Phase 2b (metrics destination) |

Phases 2a/2b are parallel. Phases 3a/3b are parallel.

## Complexity

**Tier: F-full** — Multi-domain epic (backend logging, frontend error/analytics SDKs, CI/CD pipelines) spanning 5 phases with new architectural patterns (structured logging, interceptor auto-capture, consent-gated analytics). Each phase is individually S or F-lite, but the epic requires coordination across all layers.

Signals observed:
- Multiple domains: backend (Pino, Sentry, audit), frontend (Sentry, PostHog, web-vitals), CI/CD (source maps, Lighthouse)
- New patterns: structured logging replacing default logger, NestJS interceptor for audit auto-capture, consent-gated SDK initialization
- 5+ implementation phases with dependency ordering
- Integration with 3 existing systems (audit logs, consent framework, correlation IDs)
- GDPR compliance requirements across multiple tools
