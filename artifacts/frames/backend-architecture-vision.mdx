---
title: Phase 2: Backend Architecture Vision (DDD + Hexagonal)
issue: 317
status: approved
tier: F-full
date: 2026-02-27
---

## Problem

The Roxabi Boilerplate backend is well-structured for CRUD workflows — modular NestJS, strong DI, consistent module layout — but it has no documented target architecture for when domain complexity grows. DDD maturity is minimal (Drizzle schema doubles as entity model, no domain entities/value objects/aggregates, one domain event). Hexagonal patterns are entirely absent: services compose Drizzle queries directly, no ports or adapters exist, transactions are embedded in service methods.

This is intentional pragmatism for a boilerplate, not a defect. The problem is the *absence of a documented upgrade path*: when a developer or AI agent encounters a module that has grown beyond simple CRUD, there is no guidance on how to evolve it toward richer patterns — or even when to do so.

The deliverable is an aspirational architecture document that closes this gap: a combined DDD + Hexagonal vision showing the target state, decision criteria for adoption, a migration guide from the current style, and concrete examples drawn from existing modules.

## Who

- **Primary:** Developers building on Roxabi who hit domain complexity and need a clear upgrade path (e.g., "module has >3 aggregates, what do I do?")
- **Secondary:** AI agents (Claude Code) that generate backend code and need explicit pattern guidance to produce architecturally consistent output; new contributors onboarding to the codebase

## Constraints

- **Documentation only** — no code refactoring, no config changes, no CI modifications; target state is described and illustrated but not applied
- **Aspirational scope** — document describes patterns to adopt *when warranted*, not a prescription to refactor the entire codebase
- **Anchored to existing code** — examples must use real modules (auth, rbac, user) so they're concrete and reviewable, not abstract
- **Integrates two sub-issues** — #257 (DDD: entities, branded types, aggregates, bounded contexts) and #310 (Hexagonal: ports, adapters, repositories) are architecturally inseparable and must be treated as a unified document
- **Audience constraint** — must be useful to both humans reading docs and AI agents using it as a generation reference (clear structure, explicit decision criteria, typed code examples)

## Out of Scope

- Code refactoring or actual migration of any module to DDD/Hexagonal patterns
- Applying illustrated patterns to all modules — examples use only auth, rbac, and/or user
- SOLID principles, Turborepo, Biome, or other architecture standards (covered by sibling issues)
- Frontend patterns (React, TanStack) — backend-only scope

## Complexity

**Tier: F-full** — Cross-cutting architecture decision spanning multiple backend domains (DDD + Hexagonal + migration strategy), significant design work to establish decision criteria and migration sequencing, and the need to produce code examples that are both pedagogically clear and consistent with existing module conventions.

Signals observed:
- Two distinct architectural patterns (DDD, Hexagonal) that must be unified into a single coherent vision
- Requires analysis of existing modules to derive concrete examples
- Decision criteria ("when to adopt") requires nuanced judgment — not just documentation
- Output consumed by both humans and AI agents → dual-audience constraint affects structure
- Referenced by codebase audit (#256) which found significant gaps in both pattern areas
