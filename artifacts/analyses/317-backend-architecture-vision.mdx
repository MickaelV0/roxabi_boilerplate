---
title: "Backend Architecture Vision: DDD + Hexagonal (#317)"
description: Analysis of the codebase's current architecture maturity and three shapes for the combined DDD + Hexagonal vision document
---

## Source

Issue #317: Produce a combined Backend Architecture Vision document covering DDD and Hexagonal Architecture as the *target state* for when domain complexity warrants it. Combines sub-issues #257 (DDD) and #310 (Hexagonal). Deliverable is documentation only — no refactoring. Referenced by codebase audit #256.

## Problem

The Roxabi Boilerplate backend has no documented target architecture for domain complexity. When a developer or AI agent encounters a module that has outgrown CRUD patterns, there is no guidance on:
- **Whether** to adopt DDD or Hexagonal patterns (the "when")
- **How** to structure the migration from the current style (the "path")
- **What** the target state looks like in concrete, runnable TypeScript (the "what")

This absence creates inconsistency: each developer or agent encountering complex domain logic will solve it differently, producing divergent patterns across forks of the boilerplate.

## Outcome

A published architecture vision document that:
1. Shows the target state for DDD + Hexagonal patterns with concrete TypeScript examples drawn from real modules
2. Provides explicit decision criteria for when to adopt each pattern level (table: "when X signals appear → adopt Y pattern")
3. Describes a migration path from the current CRUD style to the target architecture
4. Serves as a generative reference for AI agents (Claude Code) — structured so agents can parse adoption criteria before implementation details — and as a learning guide for human developers onboarding to the boilerplate

Success: a developer encountering a complex module can consult the document, identify where they are in the complexity spectrum, and apply the right pattern with a concrete before/after example.

## Appetite

1-week documentation cycle. Deliverable is one or more MDX files in `docs/standards/` (or `docs/architecture/`). No CI, no code changes, no schema migrations.

## Current State — Codebase Findings

Deep exploration of `apps/api/src/` reveals the baseline:

### Already DDD-adjacent

| Signal | Location | Notes |
|--------|----------|-------|
| Domain exceptions (pure TS) | `*/exceptions/*.ts` | ~40+ exception files across 7 modules — zero NestJS imports; strong domain vocabulary encoding |
| 4 domain events | `src/common/events/*.ts` | `OrganizationCreated`, `OrganizationSoftDeleted`, `UserSoftDeleted`, `EmailSendFailed` |
| Event-driven cross-module comms | `RbacListener` ← `OrganizationCreatedEvent` | Bounded context boundary: Auth → RBAC seeding |
| Business rule encapsulation | `UserService.validateSoftDeleteRequest()` | Validates pre-conditions before mutation |
| Rich service decomposition | `UserService.processOrgResolution()` | Private methods model sub-operations |

### Already Hexagonal-adjacent

| Signal | Location | Notes |
|--------|----------|-------|
| **EmailProvider proto-port** | `src/auth/email/email.provider.ts` | Type-only interface + Symbol token — the right shape for a port, though located inside `auth/` subtree (no dedicated ports layer yet) |
| Symbol-based DI tokens | `DRIZZLE`, `EMAIL_PROVIDER` | Infrastructure tokens injectable via interface |
| TenantService (transaction coordinator) | `src/tenant/tenant.service.ts` | `query()` / `queryAs()` wraps RLS context — useful infrastructure encapsulation, but callers still write raw Drizzle queries inside callbacks (not a persistence port) |
| NestJS DI infrastructure | All modules | Constructor injection makes port substitution trivial |

### Current gaps

| Gap | Evidence |
|-----|---------|
| No value objects / branded types | IDs are raw `string`, money/dates not wrapped |
| No aggregate roots | `UserService` operates on Drizzle rows directly — no domain entity layer |
| No application service layer | Controllers call services directly; orchestration logic lives inside NestJS-decorated services |
| No bounded context declarations | Modules exist but no explicit BC definition or anti-corruption layer |
| Exception duplication across BCs | `admin/exceptions/orgNotFound.exception.ts` and `organization/exceptions/orgNotFound.exception.ts` are semantically identical — no shared kernel preventing duplication |
| No repository ports | `TenantService.query()` callbacks contain raw Drizzle queries — no `UserRepository` port separating domain from persistence |
| Drizzle schema = domain model | `users`, `roles`, `members` tables are used directly in service logic |
| Transactions in service methods | `db.transaction()` called directly in `softDelete()`, `createRole()` etc. |
| Events are value carriers only | `OrganizationCreatedEvent` holds IDs only — no behaviour; not emitted by aggregates |

## Shapes

### Shape 1: Unified Vision Document

A single comprehensive doc (`docs/architecture/backend-ddd-hexagonal.mdx`) covering DDD and Hexagonal as a unified narrative. Sections: current baseline → DDD concepts → Hexagonal concepts → unified target architecture → when to adopt → migration guide → examples.

**Trade-offs:**
- Pro: Single document is easier to link, reference, and maintain
- Pro: Reinforces the inseparability of DDD and Hexagonal (as the issue asserts)
- Con: Long document — readers wanting only DDD or only Hexagonal must scroll past both
- Con: Harder to update incrementally as patterns evolve

**Rough scope:** M (5–7 days including code examples, review, and revision)

---

### Shape 2: Layered Cookbook (Decision-tree first)

Restructure the deliverable as a decision guide, not a reference manual. Primary page: "Should I adopt DDD/Hexagonal?" with a decision tree. Appendices: DDD patterns, Hexagonal patterns. Each appendix is standalone but cross-referenced.

**Trade-offs:**
- Pro: Agents and developers land directly on adoption criteria — the most valuable content; AI agents are most likely to execute adoption criteria correctly when they appear before implementation details
- Pro: Appendices can evolve independently
- Con: Three MDX files instead of one — slightly more surface to maintain
- Con: Cross-references require more care to keep consistent

**Rough scope:** M (5–7 days — same effort, different structure)

---

### Shape 3: Two Standalone Docs

Separate `ddd.mdx` and `hexagonal.mdx` in `docs/architecture/`. Each doc is self-contained. An index page links both and contextualizes their relationship.

**Trade-offs:**
- Pro: Maps cleanly to the two original sub-issues (#257 and #310)
- Pro: Team members can adopt one pattern without the other
- Con: Risks duplicating context (e.g., explaining bounded contexts in both)
- Con: The issue explicitly argues DDD + Hexagonal are inseparable — this shape contradicts that
- Con: More cross-reference maintenance

**Rough scope:** M (6–8 days — more coordination overhead)

---

## Fit Check

**Recommended: Shape 1 (Unified Vision Document)** with a prominent "when to adopt" section near the top (borrowing Shape 2's decision-first orientation).

Rationale:
- The issue frames DDD and Hexagonal as architecturally inseparable — a unified doc reinforces this
- For a boilerplate, the primary question is *when to adopt*, not *how to implement in isolation* — place decision criteria at the top, details below
- Single document is easier for AI agents to index and reference
- The `EmailProvider` pattern (already a port) and domain events (already emitted) give the doc concrete anchors in existing code — no need to invent from scratch

**Eliminated shapes:**
- Shape 3: Contradicts the "inseparable" framing and adds maintenance overhead for no user benefit
- Shape 2: Decision-tree structure is better as a section within Shape 1 than a separate top-level page

## Recommended Document Structure

```
docs/architecture/backend-ddd-hexagonal.mdx   (new)
  │
  ├── Overview: What this doc is (and isn't)
  ├── When to Adopt: Decision criteria table (dominant section)
  │     "When X signals appear → adopt Y pattern level"
  │     Example rows:
  │       module has >3 domain operations with pre-conditions → add value objects
  │       module calls >2 external services → add ports
  │       module needs domain rules independent of persistence → add aggregate
  ├── Current Baseline: What the codebase already does
  │     (EmailProvider proto-port, domain events, exception vocabulary — concrete anchors)
  ├── DDD Patterns: Target state
  │     Branded types, value objects, aggregates, domain services
  │     Application Service layer (orchestration: validate input → load aggregate → call domain method → emit event)
  │     Examples: UserId type, Role value object, OrganizationAggregate
  ├── Hexagonal Patterns: Target state
  │     Layer diagram (concentric rings: Domain → Application → Infrastructure)
  │     Ports, adapters, repository pattern (Repository = port defined in domain, adapter in infrastructure)
  │     Anti-Corruption Layer: translating Better Auth models into local domain concepts
  │     Shared Kernel: what lives in @repo/types vs per-module domain vs per-BC exceptions
  │     Examples: EmailProvider (exists), UserRepository port (new)
  ├── What does NOT belong in the domain layer
  │     NestJS decorators, HTTP concerns, Drizzle types, transaction coordination
  ├── Unified Architecture: How they work together
  │     Application service → domain aggregate → port → adapter → DB
  │     Example: full create-role use case flow
  └── Migration Guide: CRUD → target state (single module, e.g., rbac)
        Step 1: add value objects + branded types
        Step 2: add domain exceptions (already done — reinforce pattern)
        Step 3: add repository port + Drizzle adapter
        Step 4: add application service layer
        Step 5: emit events from aggregates
        Common mistakes to avoid during migration
```

## Pre-Spec Clarification Needed

**Directory placement:** Should the doc live in `docs/architecture/` (new directory, architecture-focused) or `docs/standards/` (alongside `backend-patterns.mdx`)? Recommendation: `docs/architecture/` with a cross-reference link added to `docs/standards/backend-patterns.mdx`. Resolve before spec to fix file paths and cross-references.

## Open Questions (resolve during spec)

1. Should the migration guide focus on a single module (e.g., rbac — recommended, less prescriptive) or sketch the full-codebase migration path?
2. Should code examples be "illustrative TypeScript" (stable as modules evolve — recommended) or actual PR-ready code extracted from the modules?
3. Given the scope (8 sections, migration guide, code examples), is 1-week appetite realistic? Spec phase should include a task breakdown to validate the timeline.
