---
title: "Brainstorm: ai-driven-dev/rules Analysis"
description: Analysis of ai-driven-dev/rules for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#209](https://github.com/roxabi/boilerplate/issues/209)
**Repository:** [ai-driven-dev/rules](https://github.com/ai-driven-dev/rules)
**Stars / Activity:** 108 stars, last commit 2025-06-30

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | üü° | Community-curated Cursor rules library ‚Äî different problem space |
| How it works | üü¢ | VSCode extension + structured rule taxonomy is clever distribution |
| Architecture | üî¥ | Flat rules repository, no app architecture to compare |
| File structure | üü¢ | Numbered category taxonomy for rules is very clean |
| Tech stack | üü° | TypeScript + Biome + Lefthook overlap; pnpm/npm vs Bun diverges |
| DX | üü° | Excellent for rule consumers; minimal for contributors |
| Testing | üî¥ | No test suite for the rules themselves; VSCode extension tests only |
| CI/CD | üî¥ | No CI pipeline; only Lefthook pre-commit for extension |
| Documentation | üü¢ | French README with Mermaid workflow diagram; PR template is solid |
| Unique ideas | üü¢ | Semantic compression language, memory-bank, meta-generator rule |

## Detailed Analysis

### 1. What It Does üü°

A community repository for sharing and distributing AI editor rules (primarily Cursor `.mdc` files). The value proposition is a curated, community-validated library of rules organized by category, plus a VSCode/Cursor extension to browse and download rules directly into a project.

Target audience: developers using Cursor or other AI editors who want pre-built, battle-tested rules rather than writing their own from scratch.

Problem solved: rule fragmentation ‚Äî every developer writes their own AI rules in isolation; this centralizes and standardizes them.

Roxabi addresses a completely different problem (SaaS boilerplate), so this axis is rated üü° (different, not better or worse).

### 2. How It Works üü¢

1. Rules are stored as `.mdc` files in `.cursor/rules/{category}/` with a strict naming convention (`{category-number}-rule-name[@version][-specificity].mdc`).
2. A VSCode extension ("AI-Driven Dev Rules") connects to GitHub, fetches the repository tree in a single API call using the Git Trees API, and lets users browse and download rules into their own `.cursor/rules/` folder.
3. The meta-generator rule (`meta-generator.mdc`) is a bootstrapper ‚Äî it guides an AI agent to generate new rules following the taxonomy and format conventions.
4. A `memory-bank/` directory stores the project's own AI memory (activeContext, systemPatterns, techContext, etc.) ‚Äî a Cursor-specific working memory pattern.

The Git Trees API optimization (single call vs recursive `contents` calls) is a notable implementation insight.

### 3. Architecture üî¥

No multi-layered application architecture ‚Äî this is a flat rules repository with a companion VSCode extension. The extension itself uses a service-oriented structure (`SelectionService`, `DownloadService`, `UpdateCheckService`, `ExplorerTreeProvider`) but is a small single-package TypeScript project.

There is no backend API, no database, no frontend app. Not applicable to compare against roxabi's monorepo (NestJS + TanStack Start).

### 4. File / Project Structure üü¢

The rule taxonomy is exceptionally clean:

```
.cursor/rules/
‚îú‚îÄ‚îÄ 00-architecture/
‚îú‚îÄ‚îÄ 01-standards/
‚îú‚îÄ‚îÄ 02-programming-languages/
‚îú‚îÄ‚îÄ 03-frameworks-and-libraries/
‚îú‚îÄ‚îÄ 04-tools-and-configurations/
‚îú‚îÄ‚îÄ 05-workflows-and-processes/
‚îú‚îÄ‚îÄ 06-templates-and-models/
‚îú‚îÄ‚îÄ 07-quality-assurance/
‚îú‚îÄ‚îÄ 08-domain-specific-rules/
‚îî‚îÄ‚îÄ 09-other/
```

Numbered prefixes enforce stable ordering and make it trivially navigable. File names encode category, version, and specificity:

```
3-react@19.1-hook.mdc
```

The `meta-rules/` directory separates "rules about rules" (the `meta-generator.mdc` and `semantic-language.yaml`) from the actual rule library ‚Äî a clean separation of concerns.

The `memory-bank/` directory (6 structured markdown files: `activeContext.md`, `productContext.md`, `progress.md`, `projectbrief.md`, `systemPatterns.md`, `techContext.md`) is a deliberate AI memory management pattern.

Roxabi has rich docs structure but lacks any equivalent structured AI rules taxonomy or memory-bank pattern.

### 5. Tech Stack & Tooling üü°

| Tool | ai-driven-dev/rules | roxabi_boilerplate |
|------|--------------------|--------------------|
| Runtime | Node.js / npm (extension) | Bun |
| Language | TypeScript | TypeScript (strict) |
| Linter/Formatter | Biome | Biome |
| Git hooks | Lefthook | Lefthook |
| Bundler | esbuild (vscode:prepublish) | Vite / TurboRepo |
| Package manager | pnpm (extension), npm | Bun |
| Monorepo | No | TurboRepo |

Biome and Lefthook are shared ‚Äî clear convergence. The extension uses ESLint alongside Biome (in the VSCode sub-package), which is inconsistent. The repo has no Bun usage.

Notably, the Biome config in this repo disables `noExplicitAny` (`"level": "off"`), which contradicts their own TypeScript rule (`Never use any`). Roxabi's Biome configuration is stricter and more consistent.

### 6. Developer Experience (DX) üü°

For rule consumers, the DX is excellent: install the VSCode extension, browse visually, click to download. No CLI, no config, no setup.

For contributors, the DX is adequate but sparse:
- No `package.json` scripts at the root level for contributing rules (rules are pure markdown, no build step)
- The extension has `npm run typecheck`, `npm run vscode:prepublish`, `npm run vscode:package`
- Lefthook runs typecheck + build + format on pre-commit (auto-packages the `.vsix` on every commit ‚Äî clever)
- `.env.example` documents only two tokens (`OPEN_VSX_TOKEN`, `VSCE_PAT`) needed for publishing

No dev server, no hot reload (not applicable). Onboarding to contribute a rule is essentially "write an `.mdc` file and submit a PR" ‚Äî very low friction for that use case.

Roxabi has far richer DX for a full-stack app (Bun scripts, Docker, db commands, multiple ports).

### 7. Testing Strategy üî¥

The rules themselves have no automated testing. Quality enforcement is social (PR review, community validation) rather than technical.

The VSCode extension has a test scaffolding (`@vscode/test-electron`) with a single test runner file but no meaningful test cases visible at the repository root level.

No unit tests, no integration tests, no coverage targets. Roxabi's testing strategy (Vitest + Playwright + coverage enforcement via pre-push hook) is substantially more mature.

### 8. CI/CD Pipelines üî¥

No GitHub Actions workflows. Quality enforcement happens only via:
- Lefthook pre-commit: typecheck + build extension + Biome format
- PR template for manual review

There is no automated lint check, type check, or test run on PR. The `.github/` directory contains only a `pull_request_template.md`.

Roxabi has `ci.yml`, `deploy-preview.yml`, and `neon-cleanup.yml` ‚Äî a complete pipeline.

### 9. Documentation Quality üü¢

**README** (French, with English-readable structure) is well-organized with:
- Mermaid workflow diagram showing the full user journey
- Step-by-step installation guide with known issues callout
- Clear rule naming convention with examples
- Rule generation workflow with prompts
- A concrete example pointing to a specific file

**CONTRIBUTING.md** defines three contributor tiers (Alpha/Beta/Delta), their responsibilities, and a Todo list per team ‚Äî a good model for community management.

**PR template** is well-structured with sections for PR type, description, behavior changes, and testing steps. Uses checkboxes throughout.

**memory-bank/** acts as living documentation of the AI's working context ‚Äî a novel documentation form.

Weaknesses: no architecture docs, no API docs, no changelog (other than the extension's CHANGELOG.md). The README is in French, limiting the global audience.

Roxabi's docs are more comprehensive (MDX, versioned, with architecture/standards/guides), but the memory-bank pattern and PR template quality are worth adopting.

### 10. Unique / Novel Ideas üü¢

**Three standout innovations:**

1. **Semantic Compression Language** (`meta-rules/semantic-language.yaml`): A YAML-defined notation standard using symbols (`‚Üπ`, `‚äï`, `‚Üí`, `Œ£`, `‚®Å`, `‚áå`, `‚Ä¢`, `[p=n]`) to maximize information density in AI rules. The goal is to fit more semantic meaning into fewer tokens, reducing context window usage while maintaining precision. This is a principled approach to prompt engineering.

2. **meta-generator rule** (`.cursor/rules/meta-generator.mdc`): A bootstrapper rule that guides an AI agent to generate new rules following the exact taxonomy, naming convention, frontmatter schema, and content format. It enforces a step-by-step approval workflow (check existing rules ‚Üí generate description ‚Üí generate globs ‚Üí generate content ‚Üí write file). Essentially a rule-generating rule.

3. **memory-bank pattern**: Six structured markdown files that maintain the AI's working memory across sessions: `projectbrief.md` (north star), `productContext.md` (why), `systemPatterns.md` (architecture decisions), `techContext.md` (stack), `activeContext.md` (current focus), `progress.md` (done/doing/todo). This is a deliberate, structured answer to the problem of AI context loss between sessions.

4. **VSCode extension for rule distribution**: Instead of asking developers to copy-paste from GitHub, the extension fetches the full repository tree in one Git Trees API call and provides a checkbox UI. The SHA-based update detection (comparing local vs remote SHAs) means you can see which rules have been updated since you last downloaded them.

5. **Versioned rule specificity**: The naming convention (`3-react@19.1-hook.mdc`) allows multiple versions of the same rule to coexist. Teams can pin to a specific version while the community evolves newer ones.

### 11. What They Do Better Than roxabi_boilerplate

1. **Structured Cursor rules taxonomy**: Roxabi has a `CLAUDE.md` and a rich docs system, but no equivalent structured `.cursor/rules/` directory organized by category with versioning. The ai-driven-dev numbering system (00‚Äì09) creates a stable, extensible structure.

   Actionable: Create `.cursor/rules/` in roxabi with the same category taxonomy, starting with rules directly relevant to the stack (NestJS, TanStack, TypeScript, Biome, testing).

2. **memory-bank pattern**: Roxabi has `CLAUDE.md` as a project briefing, but no structured "AI working memory" split across context types (product context, system patterns, active context, progress). The memory-bank separates concerns that are currently mixed in `CLAUDE.md`.

   Actionable: Create a `.claude/memory-bank/` (or `.cursor/memory-bank/`) directory with the 6 structured files. This would complement rather than replace `CLAUDE.md`.

3. **meta-generator rule**: Roxabi has no equivalent bootstrapper for creating new AI rules/agents. The meta-generator enforces a structured approval loop (propose ‚Üí validate ‚Üí write), reducing rule quality drift.

   Actionable: Create a `.cursor/rules/meta-generator.mdc` (or equivalent for Claude) that enforces the rule format for new cursor/claude rules.

4. **PR template quality**: Roxabi has no `pull_request_template.md` in `.github/`. The ai-driven-dev template (type checkbox, description, behavior, testing steps) is concise and functional.

   Actionable: Add `.github/pull_request_template.md` to roxabi.

5. **Semantic compression notation**: Roxabi's `CLAUDE.md` and standards docs are verbose prose. The semantic compression approach could reduce context window usage in rules that are frequently loaded.

   Actionable: Experiment with applying semantic compression to the most token-heavy sections of `CLAUDE.md` (the tier table, the routing decision tree).

### 12. What They Do Better Than 2ndBrain

2ndBrain (`/home/mickael/projects/2ndBrain/`) is a Python-based personal knowledge management and Telegram bot project. Key findings:

1. **Rule distribution mechanism**: 2ndBrain has a `CLAUDE.md` and `.claude/processes/` directory but no structured rule taxonomy. The ai-driven-dev numbered categories and VSCode distribution mechanism is entirely absent from 2ndBrain.

2. **Community contribution model**: ai-driven-dev has tiered contributor roles (Alpha/Beta/Delta), a Discord community, and a regular live session cadence. 2ndBrain is a personal project with no contribution model. The contributor tier model is a good reference for when/if 2ndBrain becomes a shared project.

3. **Versioned rules**: 2ndBrain has no equivalent of version-specific rules. The `@version` naming convention in ai-driven-dev would be useful for 2ndBrain as its skills evolve.

4. **PR template**: 2ndBrain has a `CONTRIBUTING.md` but no `.github/pull_request_template.md`. The ai-driven-dev template is directly reusable.

Strengths shared with roxabi comparison: the memory-bank pattern, meta-generator, and semantic compression are all equally useful for 2ndBrain, which also suffers from AI context loss between sessions.

### 13. Key Takeaways

**Priority 1 ‚Äî Must Have:**

1. **Add `.github/pull_request_template.md`** (Size XS, 30 min): Directly portable from ai-driven-dev. Adds PR type checkbox, description, behavior, and testing steps. No dependencies.

2. **Create `.cursor/rules/` taxonomy** (Size S, 2‚Äì4h): Set up the numbered category structure (00‚Äì09) and populate the immediately relevant categories: `01-standards` (TypeScript, clean code, naming), `02-programming-languages` (TypeScript), `03-frameworks-and-libraries` (NestJS, TanStack/React), `07-quality-assurance` (testing standards). Can directly reuse/adapt the ai-driven-dev rules as a starting point.

**Priority 2 ‚Äî High Value:**

3. **Adopt memory-bank pattern** (Size S, 2‚Äì3h): Create `.claude/memory-bank/` with the 6 structured files. Split current `CLAUDE.md` knowledge into: `projectbrief.md` (vision/roadmap ref), `productContext.md` (why, audience), `systemPatterns.md` (architecture decisions, ADRs), `techContext.md` (stack, tooling), `activeContext.md` (current sprint focus), `progress.md` (changelog summary). This improves AI context quality across sessions.

4. **Add meta-generator rule** (Size XS, 1h): A `.cursor/rules/meta-generator.mdc` that enforces the format and approval loop when creating new AI rules for the project.

**Priority 3 ‚Äî Nice to Have:**

5. **Experiment with semantic compression** (Size S, research spike): Apply the `meta-compress.mdc` notation (`‚Üπ`, `‚äï`, `‚Üí`, `Œ£`) to the most-loaded sections of `CLAUDE.md` (tier table, agent routing tree). Measure token reduction. Only adopt if readability is not impacted for human contributors.

**Links to potential issues:**
- "Add `.github/pull_request_template.md`" ‚Üí new GitHub issue (Size XS, no epic)
- "Bootstrap `.cursor/rules/` taxonomy" ‚Üí sub-issue under epic #163 or new issue
- "Adopt memory-bank pattern" ‚Üí sub-issue under epic #163 or new CLAUDE.md improvement issue

## What's next?

- Create a GitHub issue to add `.github/pull_request_template.md` (directly portable, zero risk)
- Create a GitHub issue to bootstrap `.cursor/rules/` with the 10-category taxonomy and populate it with the 4 most critical rule files (TypeScript, NestJS, React, testing standards) adapted from this repo
- Consider a spike issue to evaluate the memory-bank pattern against the current `CLAUDE.md` structure ‚Äî the goal is not to replace it but to separate long-lived architectural knowledge from session-specific context
