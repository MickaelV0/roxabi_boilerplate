---
title: "Brainstorm: AIDD Framework Analysis"
description: Analysis of paralleldrive/aidd for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#208](https://github.com/roxabi/boilerplate/issues/208)
**Repository:** [paralleldrive/aidd](https://github.com/paralleldrive/aidd)
**Stars / Activity:** 228 stars, last commit 2026-02-13

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | AI workflow framework / CLI, different domain from roxabi (not a SaaS boilerplate) |
| How it works | ðŸŸ¢ | SudoLang + slash-command orchestration is a novel and well-executed agent UX |
| Architecture | ðŸŸ¡ | Flat single-package with `ai/`, `src/`, `lib/`, `utils/` â€” lighter than roxabi's monorepo |
| File structure | ðŸŸ¢ | `ai/commands/` + `ai/rules/` split and auto-generated `index.md` files are very clean |
| Tech stack | ðŸŸ¡ | Node + npm + Biome + Vitest + Husky â€” comparable tooling, different runtime (no Bun) |
| DX | ðŸŸ¢ | npx one-liner bootstrap, auto-generated index files, dry-run CLI flag, Cursor symlink |
| Testing | ðŸŸ¡ | Vitest + riteway, colocated, TDD-first discipline â€” comparable but no e2e coverage |
| CI/CD | ðŸ”´ | Two-workflow setup (test + release), no preview deploys, no branch protection visible |
| Documentation | ðŸŸ¢ | Exceptionally thorough README, vision.md pattern, AGENTS.md, CHANGELOG, CONTRIBUTING |
| Unique ideas | ðŸŸ¢ | SudoLang, vision.md as agent source-of-truth, progressive discovery index.md, activity-log.md |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

AIDD Framework is an **AI-first development workflow framework and CLI tool** published on npm (`npx aidd`). It provides:

- An `ai/` directory scaffold of orchestration rules (`.mdc` files), slash-command workflows (`.md` files), and SudoLang programs
- A lightweight Node.js server framework (`aidd/server`) built around `asyncPipe` composition with auth, CSRF, config, and request-id middleware
- A CLI (`bin/aidd.js`) that bootstraps the `ai/` folder into any project and optionally creates a `.cursor` symlink

The **target audience** is developers using AI coding assistants (Claude Code, Cursor, VS Code Copilot) on JavaScript/TypeScript projects. The problem it solves: AI agents generate code fast but degrade code quality over time â€” AIDD provides structural guardrails (TDD rules, review workflows, security rules, spec-driven discovery) to keep AI output production-grade.

This is a **different product category** from roxabi_boilerplate. Roxabi is a deployable SaaS framework (TanStack Start + NestJS + Vercel). AIDD is a methodology layer you drop into any project. There is no direct overlap. Rating is ðŸŸ¡ because they serve adjacent concerns (AI-assisted development) but aren't competing alternatives.

### 2. How It Works ðŸŸ¢

The core workflow model is a **slash-command system** that agents follow:

```
/discover  â†’ product discovery (user journeys, story maps)
/task      â†’ create a structured task epic
/execute   â†’ implement with TDD, one requirement at a time
/review    â†’ code quality + best practices enforcement
/log       â†’ log changes to activity-log.md
/commit    â†’ conventional commit with context
/user-test â†’ generate human + AI agent test scripts
```

Each command is a markdown file in `ai/commands/` that references SudoLang rule files. The **main orchestrator** (`ai/rules/please.mdc`) wires commands together and enforces a "one thing at a time, get approval" constraint.

**SudoLang** is a typed pseudocode DSL for prompting LLMs. It provides scope blocks, explicit control flow, and typed interfaces, which reduces token usage vs. natural language while improving reasoning. The README cites academic papers showing pseudocode improves LLM performance.

The `vision.md` document acts as a **persistent project context** that every agent reads before acting. The `AGENTS.md` instructs agents on progressive discovery (read `index.md` files before diving into subdirectories, skip irrelevant domains).

This approach is well-thought-out and clearly more mature than roxabi's current approach, hence ðŸŸ¢.

### 3. Architecture & Layers ðŸŸ¡

AIDD is a **single-package library** with the following layers:

```
paralleldrive/aidd/
â”œâ”€â”€ ai/                  # The agent system (rules, commands, sudolang)
â”‚   â”œâ”€â”€ commands/        # Slash-command markdown files
â”‚   â””â”€â”€ rules/           # SudoLang .mdc orchestration rules
â”‚       â”œâ”€â”€ javascript/
â”‚       â”œâ”€â”€ frameworks/
â”‚       â”œâ”€â”€ security/
â”‚       â””â”€â”€ sudolang/
â”œâ”€â”€ bin/                 # CLI entry point (aidd.js)
â”œâ”€â”€ src/server/          # AIDD Server Framework (asyncPipe middleware)
â”œâ”€â”€ lib/                 # Type declarations
â”œâ”€â”€ utils/               # Shared utilities
â”œâ”€â”€ plan/                # Product discovery artifacts (story maps, test scripts)
â”œâ”€â”€ tasks/               # Task epics
â””â”€â”€ docs/                # Documentation (server README, user-testing guide)
```

No monorepo, no separate frontend/backend packages. The `src/server/` is a lightweight Express alternative. Design patterns: function composition (`asyncPipe`), fail-fast config, explcit CORS. No DDD or hexagonal patterns â€” intentionally pragmatic.

Compared to roxabi's TurboRepo monorepo with `apps/web`, `apps/api`, `packages/config`, `packages/types`, `packages/ui`, AIDD is much simpler. This is appropriate given its scope. Rating ðŸŸ¡ â€” different appropriate architectures, no clear winner.

### 4. File / Project Structure ðŸŸ¢

AIDD has two notable structural innovations roxabi lacks:

**Auto-generated `index.md` per folder:**
Every subdirectory under `ai/` has a machine-generated `index.md` built from frontmatter. The pre-commit hook regenerates these automatically (`node bin/aidd.js --index`). Agents can read the index to understand folder contents without consuming every file's tokens â€” "progressive discovery" that conserves context window.

**Colocated domain-specific rules:**
`ai/rules/javascript/`, `ai/rules/frameworks/`, `ai/rules/security/`, `ai/rules/sudolang/` â€” rules are colocated by domain. Agents are instructed to skip irrelevant domains (e.g., if working on backend logic, skip `ai/rules/ui.mdc`).

**`plan/` directory convention:**
Product discovery artifacts (YAML story maps, human test scripts, AI agent test scripts) live in `plan/` at the project root, cleanly separated from code and documentation.

**`activity-log.md`:**
A structured log file maintained by AI agents to track significant changes. Acts as a lightweight CHANGELOG that agents update automatically when `/log` is run.

roxabi has a more complex monorepo structure but does not have these AI-specific structural patterns. Rating ðŸŸ¢ for ideas to borrow.

### 5. Tech Stack & Tooling ðŸŸ¡

| Dimension | AIDD | roxabi_boilerplate |
|-----------|------|--------------------|
| Runtime | Node.js 16â€“22 (no Bun) | Bun 1.x |
| Package manager | npm (package-lock.json) | Bun workspaces |
| Language | JavaScript + TypeScript (checkJs: false) | TypeScript strict |
| Linter/Formatter | Biome 2.3.12 | Biome 2.4.x |
| Test runner | Vitest 3.x + riteway | Vitest 4.x + Testing Library + Playwright |
| Git hooks | Husky | Lefthook |
| Release | release-it + .release-it.json | manual (no release-it) |
| Monorepo | None (single package) | TurboRepo |
| Frontend | N/A | TanStack Start |
| Backend | Lightweight server framework | NestJS + Fastify |

Both use Biome â€” the configuration is notably similar. AIDD's biome.json enables `useSortedKeys`, `useSortedAttributes`, and organizeImports with `":NODE:", ":PACKAGE:", ":BLANK_LINE:", ":PATH:"` groups â€” slightly more opinionated import ordering than roxabi's current config.

AIDD uses **Husky** instead of Lefthook. Both achieve the same goal. Lefthook is faster and supports parallel hooks; Husky is more widely known in the npm ecosystem.

AIDD uses **riteway** as a test assertion library on top of Vitest. This is unusual but intentional â€” riteway enforces the "5 questions" assertion format from the TDD rule.

AIDD uses **release-it** for automated versioning and release from the command line. roxabi does not have an automated release tool.

Rating ðŸŸ¡ â€” equivalent quality, different choices.

### 6. Developer Experience (DX) ðŸŸ¢

AIDD's DX strengths:

**One-command bootstrap:**
```bash
npx aidd --cursor my-project
```
This copies the entire `ai/` system, creates the Cursor symlink, and you're running in under 30 seconds. No install-and-configure friction.

**`--dry-run` flag:**
Preview what the CLI would do before committing. roxabi has no equivalent for its setup process.

**`--force` and `--verbose` flags:**
Standard CLI ergonomics baked in from the start.

**Auto-regenerated index files on pre-commit:**
Developers never need to manually maintain the `index.md` files â€” the hook runs `node bin/aidd.js --index` automatically.

**Auto-regenerated README ToC on pre-commit:**
`npm run toc` (doctoc) regenerates the README table of contents on every pre-commit. roxabi relies on manual ToC maintenance.

**Cursor symlink:**
`.cursor -> ai/` lets Cursor editor automatically pick up all rules without extra config. Elegant for Cursor users.

**Pre-push runs tests + lint + typecheck:**
Same discipline as roxabi's pre-push hook. Both enforce quality at the gate.

The main DX gap in AIDD: no hot reload dev server (not applicable since it's a library/CLI, not an app). Rating ðŸŸ¢ for the CLI UX patterns.

### 7. Testing Strategy ðŸŸ¡

AIDD uses **Vitest** as the runner with **riteway** as the assertion library. Tests are colocated with source code (`**/*.test.js` alongside implementation).

The TDD rule (`ai/rules/tdd.mdc`) defines a formal 5-question assertion format:
1. What is the unit under test?
2. What is the expected behavior?
3. What is the actual output?
4. What is the expected output?
5. How can we find the bug?

This is a thoughtful codification of what makes a test useful. The rule forbids `it()` wrappers (to avoid ambiguous descriptions), mandates test isolation (no shared mutable state), and explicitly calls out when to use Playwright vs. unit tests.

Separate unit and e2e test commands:
- `npm run test:unit` â€” Vitest excluding `*-e2e.test.js` files
- `npm run test:e2e` â€” Vitest targeting only `*-e2e.test.js`

E2e tests are colocated (same runner, distinguished by file naming convention) rather than a separate Playwright project. This is simpler but less powerful than roxabi's Playwright setup.

The test matrix in CI (Node 18, 20, 22) is notable â€” ensures compatibility across LTS versions. roxabi does not have a matrix build.

No coverage thresholds visible; `@vitest/coverage-v8` is in devDependencies. Rating ðŸŸ¡ â€” good discipline in the TDD rule but no coverage enforcement.

### 8. CI/CD Pipelines ðŸ”´

AIDD has two GitHub Actions workflows:

**`test.yml`:**
- Triggers on push to `main` and `claude/**` branches, and on PRs to `main`
- Runs `npm test` on Node 18, 20, and 22 matrix
- No separate lint/typecheck steps (they're embedded in `npm test`)

**`release.yml`:**
- Handles versioning and npm publish via `release-it`

There is **no preview deploy** pipeline, no staging environment, and no branch protection configuration visible. The CI is intentionally minimal for a library (no deployment needed beyond npm publish). The `claude/**` branch pattern is interesting â€” it suggests agents create branches under a `claude/` prefix and CI covers them automatically.

By contrast, roxabi has a full CI/CD pipeline: lint + typecheck + test + Vercel preview deploy for PRs, production deploy on merge to `main`, and Neon database branch management.

Rating ðŸ”´ relative to roxabi, though this is an appropriate choice for a library project.

### 9. Documentation Quality ðŸŸ¢

AIDD's documentation is exceptionally strong for a project of its size:

**README.md (23KB):**
- Auto-generated ToC (doctoc)
- Full installation guide with multiple scenarios
- Complete CLI reference table
- Server framework docs with working code examples
- Vision document specification with template
- Troubleshooting section
- Examples for every workflow

**`vision.md`:**
A concise, structured project context document that serves as the agent source-of-truth. Sections: Mission, Product, Why it Wins, Target Users, Business Model, Core Principles. This pattern is documented and templated in the README.

**`AGENTS.md`:**
Explicit agent behavior guidelines covering: directory structure, index files, progressive discovery, vision document requirement, and conflict resolution protocol.

**`CONTRIBUTING.md`:**
Clear contributing guide referencing the development workflow.

**`CHANGELOG.md`:**
Well-maintained, follows Keep a Changelog format with semantic versioning. Entries go back to v2.0.0.

**`activity-log.md`:**
A machine-maintained log of recent significant changes. Novel concept.

**`plan.md`:**
Current priorities/roadmap maintained in the root.

**`docs/` directory:**
- `docs/server/README.md` â€” full server framework docs
- `docs/user-testing.md` â€” user testing guide

roxabi has a more structured docs site (`docs/` with MDX, architecture docs, standards, processes) but AIDD's inline documentation is more actionable. Rating ðŸŸ¢ for the `vision.md`, `AGENTS.md`, and `activity-log.md` patterns.

### 10. Unique / Novel Ideas ðŸŸ¢

**SudoLang as a prompt DSL:**
A typed pseudocode language for AI prompts with scope blocks, typed interfaces, and control flow. Claims 20â€“30% token reduction vs. natural language. The `.mdc` format extends standard markdown with frontmatter for Cursor rule metadata.

**`vision.md` as agent contract:**
A short, structured document the agent reads before every task. Includes non-goals, constraints, architectural decisions, UX principles, and success criteria. Forces a "check against vision before acting" protocol. If a conflict is detected, the agent must stop and ask â€” not proceed blindly.

**Progressive context discovery via auto-generated `index.md`:**
Every subdirectory has a machine-generated index built from frontmatter. Agents read the index before diving into files. This is architecturally clever: it creates a two-level discovery protocol (root index â†’ relevant subdirectory index â†’ specific files) that conserves context window in large repos.

**`activity-log.md` as agent-maintained changelog:**
A living log file that AI agents update via `/log` command. Captures recent significant changes in a lightweight, browsable format separate from git history.

**`claude/**` branch naming convention in CI:**
The test workflow triggers on `claude/**` branches. This signals an intentional convention: agent-created branches are namespaced under `claude/`, and CI explicitly covers them. roxabi uses `feat/` branches but doesn't have this distinction.

**`--cursor` symlink:**
Creating `.cursor -> ai/` as a symlink rather than copying files means updates to `ai/` are immediately reflected in Cursor's rule system. Elegant solution to editor integration without file duplication.

**Riteway assertion library:**
A minimalist test assertion library that enforces the `{ given, should, actual, expected }` format, which aligns with the 5-question TDD rule. The constraint reduces test debt by making it harder to write ambiguous tests.

**User testing scripts (human + AI agent):**
The `/user-test` command generates two scripts from a user journey YAML: a human think-aloud protocol and an AI agent executable test. The dual output concept is unusual and practical.

### 11. What They Do Better Than roxabi_boilerplate

**1. `vision.md` pattern (`vision.md` in project root)**
roxabi has a vision doc (`docs/vision.mdx`) but it's a long architectural document, not the concise agent-contract format AIDD uses. The AIDD template is shorter, more structured, and explicitly agent-readable. The "conflict detection + stop-and-ask" protocol embedded in `AGENTS.md` is actionable.

*Suggestion:* Add a standardized short `vision.md` at the roxabi repo root (separate from the detailed `docs/vision.mdx`) as an agent-readable contract. Include: goals, non-goals, constraints, architectural decisions, UX principles.

**2. Auto-generated index files for the `.claude/` or `docs/` tree**
roxabi has a large `docs/` tree and `.claude/skills/` directory. Agents reading these benefit from an indexed overview. AIDD's pre-commit hook that regenerates `index.md` from frontmatter is directly portable.

*Suggestion:* Add a script + pre-commit hook that generates `index.md` files for `.claude/skills/` and `docs/` subdirectories from MDX frontmatter.

**3. `activity-log.md` for agent-maintained change tracking**
roxabi has `CHANGELOG.md` (maintained in releases) and git history, but no lightweight agent-maintained activity log. The `activity-log.md` fills a gap between "full changelog entry" and "ephemeral chat context."

*Suggestion:* Introduce `activity-log.md` at the roxabi root as a rolling log agents update when making significant changes.

**4. `--index` and `--dry-run` flags in the CLI**
roxabi has no public CLI. When/if one is built, these UX patterns from AIDD are worth adopting.

**5. `release-it` for automated versioning**
roxabi has no automated release tooling. AIDD's `.release-it.json` + `release.js` pattern handles version bumping, CHANGELOG generation, and npm/git tagging automatically. roxabi's `/promote` skill handles this manually.

*Suggestion:* Evaluate adopting `release-it` or `changesets` to replace the manual `/promote` workflow.

**6. Multi-LTS Node.js test matrix in CI**
AIDD tests on Node 18, 20, and 22 in parallel. roxabi's CI tests on a single Node version. For library code (e.g., `packages/types`, `packages/config`), a matrix build would catch regression early.

**7. `claude/**` branch naming convention**
Explicit CI coverage for agent-created branches is a smart pattern. Roxabi could adopt a `claude/**` convention (or `agent/**`) to distinguish human-authored from AI-authored branches at a glance.

### 12. What They Do Better Than 2ndBrain

2ndBrain is a Python personal productivity system (Google Workspace + Telegram bot) â€” a very different domain from AIDD. However, some comparisons are still useful:

**Agent workflow structure:**
AIDD's `ai/commands/` + `ai/rules/` hierarchy is more modular and reusable than 2ndBrain's `.claude/skills/` approach. AIDD rules are domain-namespaced (`javascript/`, `security/`, `frameworks/`) and self-indexed. 2ndBrain skills are flat.

**`vision.md` and `AGENTS.md`:**
2ndBrain has a `CLAUDE.md` for project context, but no structured `vision.md` contract or explicit `AGENTS.md` with progressive discovery instructions. AIDD's separation of concerns (vision = goals, AGENTS.md = navigation protocol) is cleaner.

**Testing discipline:**
AIDD has a formal TDD rule with the 5-question format. 2ndBrain has pytest-based tests but no equivalent codified TDD methodology. Both are valid but AIDD's approach is more teachable and enforceable.

**Documentation quality:**
AIDD's README is more thorough and user-facing than 2ndBrain's. Both have CHANGELOG; AIDD's `activity-log.md` concept does not appear in 2ndBrain.

The strengths of AIDD over roxabi (vision.md, index files, activity log) are different from its strengths over 2ndBrain (modular agent rules, TDD discipline, README quality). The overlap: both would benefit from the progressive discovery index pattern and the vision.md agent contract.

### 13. Key Takeaways

**Priority 1 â€” Must-have: `vision.md` agent contract**

Create a short (1â€“2 page) `vision.md` at the roxabi root, distinct from `docs/vision.mdx`. Structured sections: goals, non-goals, constraints, architectural decisions, UX principles. Update `AGENTS.md` and `CLAUDE.md` to instruct agents to read it before every task.

*Action:* Create GitHub issue "Add `vision.md` agent contract to roxabi root" under epic #163.

**Priority 1 â€” Must-have: Auto-generated `index.md` for `.claude/skills/` and `docs/`**

Add a script that generates `index.md` per subdirectory from MDX/MD frontmatter. Wire into lefthook pre-commit. This directly reduces agent context consumption when navigating the skills tree.

*Action:* Create GitHub issue "Add auto-generated index.md for .claude/skills/ and docs/" under epic #163.

**Priority 2 â€” High value: `activity-log.md` rolling change log**

Add `activity-log.md` at the repo root. Update `CLAUDE.md` to instruct agents to append an entry after significant changes. Can be a companion to the existing CHANGELOG.

*Action:* Create GitHub issue "Add activity-log.md for agent-maintained change tracking" under epic #163.

**Priority 2 â€” High value: `claude/**` or `agent/**` branch naming convention**

Adopt a naming convention for agent-created branches. Update CI to trigger on these branch patterns explicitly. Update `CLAUDE.md` worktree instructions accordingly.

*Action:* Mention in the next git/workflow standards review.

**Priority 3 â€” Nice-to-have: Evaluate `release-it` or `changesets`**

The manual `/promote` skill works but is brittle. AIDD's `release-it` setup with a custom `release.js` orchestrator is worth studying for a future roxabi release automation improvement.

*Action:* Create GitHub issue "Evaluate release-it/changesets to automate /promote workflow" under epic #163.

## What's next?

- Create GitHub issue: "Add `vision.md` agent contract (inspired by paralleldrive/aidd)"
- Create GitHub issue: "Auto-generate `index.md` files in .claude/skills/ from frontmatter"
- Create GitHub issue: "Add `activity-log.md` for lightweight agent-maintained change tracking"
- Study the SudoLang spec (`ai/rules/sudolang/`) for potential adoption in `.claude/skills/` rule files
- Review AIDD's security rules (`ai/rules/security/jwt-security.mdc`, `timing-safe-compare.mdc`) â€” may have useful patterns for the roxabi auth module
- Evaluate `riteway` as an alternative to jest-dom/Testing Library for pure unit tests in roxabi packages
