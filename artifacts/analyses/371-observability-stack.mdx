---
title: "Production Observability & Analytics Stack"
description: "Technical analysis of integration points, risks, and architectural approach for the full observability epic"
---

## Source

GitHub Issue #371 — "epic(observability): production monitoring & analytics stack". Supersedes #22, #54, #347, #349, #350.

## Problem

Zero production visibility. No structured logs, no error tracking, no product analytics, no performance monitoring. Foundation pieces exist but are disconnected: audit logs (~60%), consent framework (100%), correlation IDs, error handling, web-vitals (installed, unused).

## Outcome

A coherent observability stack where:

1. All backend logs are structured JSON with correlation IDs (Pino)
2. Errors are tracked with real-time alerts to Slack/email (Sentry + Sentry Alerts)
3. Product analytics are consent-gated, feeding feature decisions (PostHog analytics)
4. Feature flags enable gradual rollouts and kill switches (PostHog feature flags)
5. Performance regressions are caught in CI before merge (web-vitals + Lighthouse CI)
6. Audit mutations are auto-captured via interceptor (audit system completion)

## Appetite

~6–8 dev days across all phases. Each phase is independently shippable. Adjusted from initial 5–6 day estimate to account for feature flags (Phase 3a) and Sentry filter chain complexity (Phase 2b).

## Context

### Backend (apps/api)

| Component | Status | Files | Key Details |
|-----------|--------|-------|-------------|
| **Logger instances** | 23 services | `apps/api/src/**/*.ts` | All use `new Logger(ClassName.name)` — NestJS built-in, unstructured strings. Manual `[${correlationId}]` prefixes in log calls need cleanup |
| **Fastify logger** | Basic | `apps/api/src/index.ts:101-103` | `LOG_LEVEL` env var, defaults to `'debug'`. No structured output. `FastifyAdapter` logger config must be removed when `nestjs-pino` takes over |
| **CLS (correlation IDs)** | Complete | `apps/api/src/app.module.ts:37-49` | `nestjs-cls` generates UUID per request, sets `x-correlation-id` header. Pino can consume this directly |
| **AllExceptionsFilter** | Complete | `apps/api/src/common/filters/allExceptions.filter.ts:35-138` | Catch-all filter. Returns structured error response with correlationId. **Sentry hooks here** |
| **Domain exception filters** | 14 filters | Various | All extract correlationId from CLS. Handle 4xx only (400/404/409) — no 5xx. Do not re-throw. AllExceptionsFilter only sees unhandled + 5xx |
| **Audit schema** | Complete | `apps/api/src/database/schema/audit.schema.ts` | `audit_logs` table: actor, action, resource, before/after JSONB, 6 indices |
| **AuditService** | Complete | `apps/api/src/audit/audit.service.ts` | Manual `log()` method. Called explicitly from 4 admin services (13 call sites including tests) |
| **Audit admin endpoint** | Complete | `apps/api/src/admin/adminAuditLogs.controller.ts` | `GET /api/admin/audit-logs`, superadmin only, cursor pagination, field redaction |
| **Error codes** | 47 codes | `apps/api/src/common/errorCodes.ts` | Typed enum across RBAC, tenant, user, consent, org, admin, API keys, rate limiting |
| **NestJS modules** | 16 total | `apps/api/src/*/` | AppModule imports all. 10 global filters, 2 global guards, 1 global interceptor (TenantInterceptor) |
| **EventEmitter** | Active | `apps/api/src/app.module.ts` | Used by RbacListener, ApiKeyListener. Pattern available for async audit events |
| **Package deps** | No monitoring libs | `apps/api/package.json` | NestJS 11.1.14, Fastify 5.6.2, nestjs-cls 6.2.0. Zero observability packages |

### Frontend (apps/web)

| Component | Status | Files | Key Details |
|-----------|--------|-------|-------------|
| **Consent framework** | 100% | `apps/web/src/lib/consent/` | 3 categories (necessary/analytics/marketing), cookie + DB sync, 6-month expiry, `useConsentGate()` hook |
| **Error boundaries** | 3 layers | `__root.tsx:29-54`, `admin.tsx:16-35`, `DocsErrorBoundary.tsx` | Root (react-error-boundary `onError` callback available), Admin (TanStack errorComponent), Docs. No error reporter wired |
| **Provider stack** | Mapped | `apps/web/src/routes/__root.tsx` | `RootProvider → ConsentProvider → ErrorBoundary → children`. New providers (Sentry, PostHog) insert between ConsentProvider and ErrorBoundary |
| **web-vitals** | Installed | `apps/web/package.json:91` | `^5.1.0` as devDep. Zero imports. Wiring point: `useEffect` in AppShell or dedicated `useWebVitals()` hook |
| **Env vars** | VITE_ ready | `.env.example` | Only `VITE_GITHUB_REPO_URL` currently. Vite exposes `VITE_*` to bundle |
| **Package deps** | Minimal | `apps/web/package.json` | react-error-boundary 6.1.1, sonner (toasts). No Sentry, PostHog, or analytics libs |
| **Existing packages/** | No observability | `packages/` | Contains ui, types, config, email, vitest-config, playwright-config. No observability package exists |

### CI/CD & Deployment

| Component | Status | Files | Key Details |
|-----------|--------|-------|-------------|
| **CI pipeline** | Mature | `.github/workflows/ci.yml` | 7 jobs: detect-changes, secrets, lint, typecheck, test, build, e2e. Coverage reporting via vitest-coverage-report-action |
| **E2E matrix** | Complete | `.github/workflows/ci.yml:420-551` | Sharded Playwright across 4 browsers. Blob reporter + artifact upload. Pattern replicable for Lighthouse |
| **Deploy preview** | Active | `.github/workflows/deploy-preview.yml` | Vercel preview deploys. No post-deploy checks. **Lighthouse CI runs here as post-deploy step** |
| **Vercel config** | Both apps | `apps/web/vercel.json`, `apps/api/vercel.json` | turbo-ignore, bun install, turbo build. API has daily purge cron. `trustProxy: 1` already set in index.ts:105 |
| **TurboRepo** | `turbo.jsonc` | Root config | build/test/lint/typecheck tasks. `build.env` needs Sentry vars added for cache correctness |
| **Docker** | Postgres only | `docker-compose.yml` | postgres:16-alpine. No additional containers needed — all observability tools are SaaS |
| **.env.example** | Needs update | Root `.env.example` | `LOG_LEVEL=debug` exists. Needs SENTRY_DSN, VITE_SENTRY_DSN, VITE_POSTHOG_KEY, CI-only vars |

## Risks & Mitigations

| # | Risk | Impact | Mitigation |
|---|------|--------|-----------|
| 1 | **Pino replaces 23 Logger instances** — `nestjs-pino` auto-replaces NestJS Logger globally, but manual `[${correlationId}]` string interpolation produces duplicated info in JSON output | Medium | Pino + CLS auto-injects correlationId. Grep-and-replace all `[${correlationId}]` patterns. Remove `FastifyAdapter` logger config (replaced by nestjs-pino). One-time migration |
| 2 | **SentryGlobalFilter vs AllExceptionsFilter ordering** — `@sentry/nestjs` ships `SentryGlobalFilter` that must be outermost. If AllExceptionsFilter runs first, it swallows exceptions and Sentry never sees them. If both capture, exceptions are double-reported | **Critical** | **Decision: Use `SentryGlobalFilter` as outermost filter (captures + re-throws), then AllExceptionsFilter formats response.** Register SentryGlobalFilter before AllExceptionsFilter in AppModule. Domain filters (4xx only) are unaffected — they never reach either global filter |
| 3 | **Sentry serverless flush** — Vercel serverless functions exit before Sentry's async event queue flushes, dropping errors | High | Call `await Sentry.flush(2000)` before handler returns. Use Sentry's `@sentry/nestjs` serverless integration which handles this automatically |
| 4 | **Sentry import ordering** — `Sentry.init()` must be called before any other imports for instrumentation to work | High | `Sentry.init()` as absolute first call in `apps/api/src/index.ts`, before AppModule import. Use `--import` flag or dynamic import pattern |
| 5 | **PostHog consent timing + bundle size** — PostHog must NOT load before consent; `posthog-js` adds ~45-60KB gzipped | High | Dynamic import: `import('posthog-js')` only when `useConsentGate('analytics')` returns true. Also gate on key presence: `if (!import.meta.env.VITE_POSTHOG_KEY) return`. Lazy init supports mid-session consent grant |
| 6 | **Sentry PII in error context** — Request bodies, auth tokens, cookies could leak to Sentry | High | `beforeSend` hook strips Authorization headers, cookies, request bodies. Allowlist only safe context fields |
| 7 | **PostHog feature flags SSR** — Feature flags need evaluation during server rendering for TanStack Start | Medium | Use PostHog's `isFeatureEnabled()` client-side only initially. SSR pages render default state, hydrate with flag values. Avoids server-side PostHog dependency |
| 8 | **Lighthouse CI flakiness** — Performance scores vary between runs | Medium | Set thresholds with margin (perf ≥ 75 not 90), use median of 3 runs, allow manual override label on PR |
| 9 | **Audit interceptor + existing manual calls** — Risk of double-logging mutations | Medium | Decorator-based `@AuditLog()` interceptor. Existing manual `auditService.log()` calls migrated to decorator. Transition period: add idempotency check |
| 10 | **Source map upload in CI** — Needs secrets, must delete sourcemaps after upload | Low | Upload in `build` job (ci.yml:305-308). Add `SENTRY_AUTH_TOKEN`, `SENTRY_ORG`, `SENTRY_PROJECT` to build job env + turbo.jsonc `build.env`. Delete sourcemaps post-upload to avoid shipping to users |
| 11 | **TurboRepo cache correctness** — Without Sentry vars in `build.env`, Turbo caches builds ignoring token changes, skipping sourcemap upload | Low | Add `SENTRY_AUTH_TOKEN` to `globalPassThroughEnv`. Add `SENTRY_ORG`, `SENTRY_PROJECT_API`, `SENTRY_PROJECT_WEB` to `build.env` array |

## Shapes

### Shape 1: Direct Integration (per-app)

Wire each tool directly into the app where it's used. Pino in `apps/api`, Sentry in both apps, PostHog in `apps/web`. No shared package or abstraction layer. Delivered as sequential phases, each independently shippable.

**Approach:**
- `nestjs-pino` replaces NestJS Logger globally in AppModule via `LoggerModule.forRootAsync()` with CLS integration
- `@sentry/nestjs` + `SentryGlobalFilter` (outermost) in apps/api; `@sentry/react` with `onError` callbacks on existing ErrorBoundaries in apps/web
- Separate `PostHogProvider` with dynamic import, consent-gated via `useConsentGate('analytics')`. Includes `useFeatureFlag()` hook
- web-vitals reports to PostHog via `onCLS/onFID/onLCP/onTTFB/onINP` callbacks in a `useWebVitals()` hook
- Lighthouse CI as post-deploy step in `deploy-preview.yml` against Vercel preview URL
- Sentry Alerts configured in Sentry dashboard: error spike → Slack/email

**Trade-offs:**
- Pro: Simplest to implement, no premature abstractions, each tool is independently removable
- Pro: Follows existing codebase pattern (tools live where they're used)
- Con: Tool-specific config duplicated if both apps need the same tool (only Sentry crosses apps, but uses different SDKs anyway)

**Rough scope:** M-L (6–8 days total across 6 phases)

### Shape 2: Shared Observability Package

Create `packages/observability` with shared initialization, config types, and helper utilities. Apps import from `@repo/observability`.

**Approach:**
- `packages/observability/src/pino.ts` — Pino config factory
- `packages/observability/src/sentry.ts` — Sentry init for both node and browser
- `packages/observability/src/posthog.ts` — PostHog provider wrapper
- `packages/observability/src/web-vitals.ts` — Metrics reporter
- Apps import and configure with app-specific DSNs/keys

**Trade-offs:**
- Pro: Centralized config, consistent initialization across apps
- Pro: Single place to update SDK versions
- Con: Over-engineering for 2 apps — adds package boilerplate, build config, TurboRepo DAG edge with no user value
- Con: Sentry node vs browser are fundamentally different SDKs — shared wrapper adds complexity without value
- Con: PostHog is frontend-only, Pino is backend-only — little actual sharing. `packages/` currently has 6 packages, none observability-related

**Rough scope:** L (8–10 days — extra package scaffolding, build config, cross-package types)

### Shape 3: Hybrid — Shared Types, Direct Integration

Use `@repo/types` for shared event name enums and log level types. Integrate tools directly in each app.

**Approach:**
- Add `ObservabilityEvent` enum and `LogContext` type to `packages/types`
- Direct tool integration in each app (same as Shape 1)
- Shared constants ensure consistent event naming across FE/BE

**Trade-offs:**
- Pro: Consistent event naming without over-abstracting
- Pro: Types are cheap — no runtime overhead
- Con: Marginal benefit — PostHog events are frontend-only, Pino logs are backend-only. Only audit actions cross the boundary, and those already have an enum in `errorCodes.ts`

**Rough scope:** M-L (6–8 days + 2h for types)

## Fit Check

**Shape 1 (Direct Integration) is the best fit.**

- **Constraint alignment:** Vercel serverless means each app deploys independently — shared packages add build coupling without benefit. The tools barely overlap: Pino is backend-only, PostHog is frontend-only, only Sentry spans both (but uses completely different SDKs: `@sentry/nestjs` vs `@sentry/react`).
- **Shape 2 eliminated:** Over-engineering. `packages/observability` would wrap fundamentally different SDKs behind a shared interface that adds indirection without value. Violates "avoid premature abstractions" principle.
- **Shape 3 eliminated:** Marginal benefit. The only shared constants would be audit action names (already exist) and PostHog event names (~10 strings). Not worth cross-package dependency.
- **Appetite fit:** 6–8 days matches Shape 1. Shape 2 adds 2+ days of package scaffolding that don't deliver user value.
- **Risk profile:** Shape 1 isolates changes to each app — a broken Sentry init in apps/web can't affect apps/api. Matches serverless deployment model.

## Integration Decisions (Recommended)

| # | Decision | Recommendation | Rationale |
|---|----------|---------------|-----------|
| 1 | Pino integration method | **`nestjs-pino` with CLS** | `nestjs-cls` already configured globally (app.module.ts:37-49). `LoggerModule.forRootAsync()` auto-injects correlationId. Manual Pino setup = strictly more work for no benefit |
| 2 | Sentry + existing ErrorBoundaries | **Wrap, don't replace** | Keep `react-error-boundary` for UI rendering. Add `onError` callback calling `Sentry.captureException()`. Keeps Sentry removable without touching UI code |
| 3 | Sentry filter ordering | **SentryGlobalFilter outermost** | Registered before AllExceptionsFilter in AppModule. SentryGlobalFilter captures + re-throws. AllExceptionsFilter formats response. No `Sentry.captureException()` in AllExceptionsFilter (would double-report) |
| 4 | Audit interceptor approach | **Decorator-based `@AuditLog()`** | Preserves explicit intent (opt-in per endpoint). Avoids fragile path-based inference. Works with existing EventEmitter pattern |
| 5 | PostHog provider placement | **Separate `PostHogProvider`** | ConsentProvider is 200 lines, single-responsibility. PostHogProvider sits inside ConsentProvider in stack, uses `useConsentGate('analytics')` + dynamic import. Provides `usePostHog()` and `useFeatureFlag()` hooks |
| 6 | Lighthouse CI target | **Vercel preview deploy URL** | Tests actual production-like environment (CDN, edge functions, compression). Run as post-deploy step in `deploy-preview.yml`. Local build gives misleading scores |

## Recommended Phase Order

| Phase | Scope | Est. | Dependencies | Notes |
|-------|-------|------|-------------|-------|
| 1 | Pino structured logging | 1 day | None | Foundation. Remove FastifyAdapter logger, add nestjs-pino, clean manual correlationId prefixes |
| 2a | Sentry backend | 1.5 days | Phase 1 | `@sentry/nestjs`, SentryGlobalFilter ordering, PII `beforeSend`, serverless flush, source map upload in CI |
| 2b | Sentry frontend + alerting | 1 day | — | `@sentry/react`, `onError` on 3 boundaries, env vars. Configure Sentry Alerts (Slack/email) |
| 3a | PostHog analytics + feature flags | 1.5 days | — | Dynamic import, consent-gated, `PostHogProvider`, `useFeatureFlag()`, core events (pageview, signup, login) |
| 3b | web-vitals + Lighthouse CI | 1 day | Phase 3a | web-vitals → PostHog bridge, `lighthouserc.json`, deploy-preview.yml post-deploy step |
| 4 | Audit interceptor | 1 day | Phase 1 | `@AuditLog()` decorator, migrate manual calls, RLS policy. **Consider splitting to separate issue** — architecturally distinct from external observability |

Phases 2a/2b parallel. Phases 3a/3b parallel (3b needs PostHog as metrics destination). Total: ~7 days with parallelization.

## Environment Variables (Spec Reference)

```
# Backend (server-side)
SENTRY_DSN=                      # apps/api: SDK init (required in production)
SENTRY_AUTH_TOKEN=               # CI only: sourcemap upload
SENTRY_ORG=                      # CI only: org slug
SENTRY_PROJECT_API=              # CI only: project slug for apps/api
SENTRY_PROJECT_WEB=              # CI only: project slug for apps/web

# Frontend (VITE_*)
VITE_SENTRY_DSN=                 # apps/web: browser SDK init
VITE_POSTHOG_KEY=                # PostHog project API key
VITE_POSTHOG_HOST=               # PostHog ingestion host (default: https://app.posthog.com)

# turbo.jsonc additions
# globalPassThroughEnv: SENTRY_AUTH_TOKEN
# build.env: SENTRY_ORG, SENTRY_PROJECT_API, SENTRY_PROJECT_WEB
```

## Assumptions

- **Vercel Analytics** (built-in) provides baseline Web Vitals for free with zero code. This analysis does not spec it — it's already active.
- **PostHog dependency on Sentry** (from frame): not a hard dependency. PostHog analytics works independently. The Phase 3a→2b dependency in the frame was about having error context enriched with PostHog session IDs — this is a nice-to-have, not blocking. PostHog can run parallel to Phase 2.
