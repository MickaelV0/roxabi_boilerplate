---
title: "Admin Panel Enhancements: Users List Columns & Org Membership Editing"
description: Add organizations count and last active columns to admin users list (#312) and superadmin inline-edit org memberships via context menu (#313).
---

## Context

Issues [#312](https://github.com/roxabi/roxabi_boilerplate/issues/312) and [#313](https://github.com/roxabi/roxabi_boilerplate/issues/313) — incremental enhancements to the Admin Panel Phase 2 ([#269](https://github.com/roxabi/roxabi_boilerplate/issues/269), completed).

**Parent spec:** [Admin Phase 2 Spec](../specs/269-admin-phase2)

**Current state (post-Phase 2):**

- `/admin/users` lists all platform users with cursor-based pagination. Table columns: Name, Email, Role, Status, Created. The `listUsers` service already batch-fetches org memberships per page (two-query approach), returning an `organizations[]` array per user — but the frontend does not display organizations or last active.
- `/admin/organizations/:id` detail page shows a read-only `MembersCard` table: Name, Email, Role, Joined. No inline editing capability.
- `AdminMembersService.changeMemberRole()` exists for org-scoped role changes (uses RBAC `roleId` from `roles` table).
- `AdminUsersService.updateUser()` exists for cross-tenant name/email/role editing.
- `AdminUsersService.getUserDetail()` already derives `lastActive` from the most recent audit log entry.
- Radix-based UI primitives (including `ContextMenu`) available from `@repo/ui`.

## Questions Explored

1. How to add "Organizations" and "Last Active" columns to the users list without degrading performance?
2. How to implement inline membership editing on the org detail page using context menus?
3. What existing backend services can be reused vs. what needs new endpoints?
4. How to handle the role system (dynamic RBAC roleId) in a context menu submenu?

## Analysis

### #312 — Organizations Count &amp; Last Active Columns

#### Organizations count

The backend `listUsers` already returns `organizations[]` per user via a batch membership query. The frontend simply needs to display `user.organizations.length` (or a comma-separated list of org names) in a new column. **No backend changes required.**

Two display options:

- **Count badge**: `Badge` showing the number (e.g., "3"). Compact, works at any scale.
- **Comma-separated names**: Show org names directly (e.g., "Acme, Globex"). More informative but truncation needed for users in many orgs.

**Recommendation:** Count badge with a tooltip showing org names. Clicking the count navigates to the user detail where full memberships are visible.

#### Last active

The `getUserDetail` method derives `lastActive` from the first audit log entry: `redactedEntries[0]?.timestamp ?? null`. For the list view, the same approach requires one additional query.

**Options:**

| Approach | Performance | Complexity | Accuracy |
|----------|-------------|------------|----------|
| Audit log subquery per user page | O(N) where N = page size (batch via `IN`) | Low — single additional query | Good — reflects last admin-visible action |
| Lateral join in main query | O(1) — single query | Medium — Drizzle lateral join ergonomics | Good |
| Denormalized `lastActiveAt` column | O(0) — already in row | High — migration + write-path middleware | Best — real-time |

**Recommendation:** Audit log batch query (same pattern as memberships). For a 20-user page, one `SELECT MAX(timestamp) FROM audit_logs WHERE actorId IN (...)` query is cheap. The lateral join is theoretically cleaner but Drizzle's lateral join support is limited and would add complexity. Denormalized column is overkill for this use case.

**Implementation:** Add a third query to `listUsers` after fetching users and memberships:

```sql
SELECT actor_id, MAX(timestamp) as last_active
FROM audit_logs
WHERE actor_id IN (:userIds)
GROUP BY actor_id
```

Map results into a `lastActiveByUserId: Map<string, Date>` and merge onto each user object.

**Null state:** Users with zero audit log entries display "Never" in the Last Active column (not an empty cell or dash — "Never" communicates meaning).

### #313 — Inline-Edit Org Memberships via Context Menu

#### Scope

Right-click context menu on the org detail (`/admin/organizations/:id`) members table only. Two actions:

1. **Change role** → submenu listing available org roles (fetched from `roles` table for this org)
2. **Edit profile** → dialog with Name and Email fields

~~Change status~~ → skipped (no member-level status field exists; ban/unban available on the user detail page).

#### Backend reuse

| Action | Existing Service | Endpoint | Changes Needed |
|--------|-----------------|----------|----------------|
| Change role | `AdminMembersService.changeMemberRole()` | `PATCH /api/admin/members/:orgId/:memberId/role` | None — already exists |
| Edit name/email | `AdminUsersService.updateUser()` | `PATCH /api/admin/users/:id` | None — already exists |
| Fetch org roles | None (roles fetched inside `changeMemberRole`) | Need new: `GET /api/admin/organizations/:orgId/roles` | New endpoint to list available roles for a specific org |

The only new backend work is a **roles list endpoint** so the frontend can populate the context menu submenu dynamically. This endpoint lives on the `AdminOrganizationsController` (cross-tenant, `@Roles('superadmin')` + `@SkipOrg()`) and queries the `roles` table filtered by `tenantId = orgId`. It does NOT use the session's active org — it accepts the orgId as a path parameter, consistent with all other Phase 2 cross-tenant endpoints.

**Empty roles fallback:** If the org has no RBAC roles configured (new org, empty `roles` table for that tenant), the context menu's "Change role" submenu is **disabled** with a tooltip: "No roles configured for this organization." This avoids mixing the dynamic RBAC system with hardcoded legacy role strings, which could create data inconsistencies.

#### Frontend implementation

The `MembersCard` component in `organizations.$orgId.tsx` currently renders a plain `&lt;Table>`. The enhancement adds:

1. **`ContextMenu`** wrapper around each `&lt;TableRow>` (from `@repo/ui` Radix primitives)
2. **Role submenu**: Fetches org roles via the new endpoint, displays as `&lt;ContextMenuSub>` items
3. **Edit profile dialog**: `&lt;Dialog>` with Name/Email form, calls `PATCH /api/admin/users/:userId`
4. **Optimistic updates**: TanStack Query `setQueryData` for immediate UI feedback on role changes
5. **Guards**: Hide context menu for non-superadmin (already enforced by route guard `requireSuperAdmin`). Disable self-role-change option.
6. **Toast feedback**: Success/error toasts via `sonner` (existing pattern)

**Email edit security note:** The `AdminUsersService.updateUser()` already guards against email conflicts (409 on duplicate) and prevents self-role-change. Email changes from the context menu path go through the same service — no additional security concern beyond what the user detail edit form already handles. The existing `@Throttle({ global: { ttl: 60_000, limit: 30 } })` rate limit applies.

#### Audit logging

Both actions are already audit-logged by the existing services:
- `changeMemberRole` logs `member.role_changed` with before/after role snapshots
- `updateUser` logs `user.updated` with before/after profile snapshots

No additional audit work needed.

#### Edge cases

| Scenario | Behavior |
|----------|----------|
| Self-role-change | `AdminMembersService.changeMemberRole` throws `SelfRoleChangeException`. Frontend: disable the "Change role" option for the current user's row |
| Last owner demotion | `AdminMembersService.changeMemberRole` does not currently guard this. **Must be investigated and fixed before implementation** — changing the last owner to a non-owner role leaves the org without an owner. |
| User not found (deleted between list and action) | Service throws `AdminUserNotFoundException` → 404 → error toast + refetch |
| Concurrent role change | Last-write-wins (same as Phase 2 pattern). Both changes audit logged |
| Org has no custom roles | "Change role" submenu is disabled with tooltip "No roles configured for this organization" |

## Shapes

### Shape A: Minimal Additive (Inline Changes Only)

Add the two new columns to `users.tsx` (frontend only for org count, one new batch query for last active). Add context menu directly inside `MembersCard` component in `organizations.$orgId.tsx`. New roles endpoint on the organizations controller.

- **Description:** Smallest possible change. Frontend column additions + context menu + one new API endpoint. All changes are additive, no refactoring.
- **Trade-offs:**
  - Pro: Minimal diff, fast to implement (~2-3 days), low risk
  - Pro: No new abstractions or patterns beyond what exists
  - Con: Context menu logic lives directly in `organizations.$orgId.tsx` making it a larger component
  - Con: If context menus are needed elsewhere later, the pattern isn't extracted
- **Rough scope:** ~6 files touched (users.tsx, admin-users.service.ts, organizations.$orgId.tsx, admin-organizations.controller.ts, admin-organizations.service.ts, types/admin.ts)

### Shape B: Extracted Context Menu Component

Same as Shape A for #312. For #313, extract a reusable `&lt;MemberContextMenu>` component that encapsulates the context menu, role submenu, edit dialog, and mutation hooks. The component receives `member`, `orgId`, `onActionComplete` props.

- **Description:** Slightly more structured. The context menu is a standalone component that can be reused on the `/admin/members` page or other tables in the future.
- **Trade-offs:**
  - Pro: Clean separation of concerns — `MembersCard` stays simple
  - Pro: Reusable if context menus are added to other pages
  - Con: Slightly more files (+1 component, +1 hook), marginally more effort
  - Con: Pre-optimization if context menus are only used in one place
- **Rough scope:** ~8 files touched (same as Shape A + new `member-context-menu.tsx` + `use-member-actions.ts` hook)

### Shape C: Admin Membership Management Service

For #313, create a dedicated `AdminOrgMembersService` (or extend `AdminOrganizationsService`) with methods for cross-tenant membership management (change role, update profile, list roles). This centralizes membership mutation logic for the org detail context instead of calling two different services from the frontend.

- **Description:** Backend-centric approach. New service layer that orchestrates calls to existing services. Frontend calls a single API surface.
- **Trade-offs:**
  - Pro: Clean API surface for the frontend (single controller, consistent patterns)
  - Con: Over-engineering for 2 actions. `changeMemberRole` already exists in `AdminMembersService` and `updateUser` in `AdminUsersService`
  - Con: Adds a third member-related service, increasing cognitive load
  - Con: More effort (~4-5 days) for marginal benefit
- **Rough scope:** ~12 files touched (new service + controller + tests + frontend components)

## Fit Check

| Requirement | Shape A | Shape B | Shape C |
|-------------|---------|---------|---------|
| Org count column in users list | ✅ | ✅ | ✅ |
| Last active column in users list | ✅ | ✅ | ✅ |
| Context menu on org detail members | ✅ | ✅ | ✅ |
| Change role via context menu | ✅ | ✅ | ✅ |
| Edit name/email via context menu | ✅ | ✅ | ✅ |
| Reuses existing services | ✅ | ✅ | ❌ |
| Minimal diff / low risk | ✅ | ✅ | ❌ |
| Future reusability | ❌ | ✅ | ✅ |
| Implementation speed (&lt;3 days) | ✅ | ✅ | ❌ |

**Selected shape:** Shape B (Extracted Context Menu Component) — balances minimal effort with clean component boundaries. The extracted `&lt;MemberContextMenu>` keeps `organizations.$orgId.tsx` manageable and provides a reusable pattern at negligible extra cost.

## Conclusions

1. **#312 is almost entirely frontend work.** The backend already returns organizations per user. Only addition: a batch `MAX(timestamp)` query on `audit_logs` for last active. Frontend adds two columns.
2. **#313 reuses existing backend services.** The only new backend endpoint is `GET /api/admin/organizations/:orgId/roles` to populate the role submenu. Role changes and profile edits use existing `AdminMembersService` and `AdminUsersService`.
3. **Context menu is the main new UI pattern.** Using Radix `ContextMenu` from `@repo/ui`. Extracted as `&lt;MemberContextMenu>` component for clean separation.
4. **No schema migrations needed.** Both issues are additive on existing tables and queries.
5. **Risk is low.** All changes build on proven Phase 2 patterns. The batch audit query for last active is the only potentially slow operation, but it's bounded by page size (20 users).

## Next Steps

1. Create combined spec for #312 + #313 with API contracts, component breakdown, and success criteria.
2. **Investigate last owner guard:** Verify whether `AdminMembersService.changeMemberRole` guards against demoting the last owner to a non-owner role. If not, add the guard before implementation.
3. Verify `@repo/ui` exports `ContextMenu`, `ContextMenuSub`, `ContextMenuContent`, `ContextMenuItem` primitives.
4. Confirm `organizations[]` is serialized in the `listUsers` API response (not stripped before the DTO leaves the controller).
