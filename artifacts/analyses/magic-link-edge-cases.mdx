---
title: "Magic Link Authentication Edge Cases"
description: Analysis of three unhandled magic link scenarios — unregistered emails, generic error messages, and logged-in user conflicts.
---

## Source

> "We need to clarify the behavior that we have at the level of authentication and magic links and redirects. So we should list all scenarios for the magic links. I am a user, I click on login, I click on magic links, I put my email. There are several scenarios when I put the address mail, I click on validate. The mail has no account. The mail has an account and in that case, it sends the link. Then I click on the link. It redirects me to the token validation page. It validates the token. And there, you have to see if the token is still good, if it exists. And in function, take the right action. So we need to clarify all that, what does not exist in the code and what do we do."

## Problem

The magic link flow handles the happy path but treats all edge cases identically. Three gaps:

1. **Unregistered emails silently succeed** — Better Auth sends a magic link to any email, potentially creating a new account on verification. No feedback to the user that no account exists.
2. **All verification errors are generic** — expired, already-used, and invalid tokens all show "Your link is invalid or has expired." Users can't tell what went wrong or what action to take.
3. **Logged-in users are silently redirected** — if a user is signed in as Account A and clicks a magic link (for Account B or A), `requireGuest` redirects to `/dashboard` without explanation. The magic link is consumed without feedback.

## Outcome

Each magic link edge case produces a specific, actionable response: unregistered emails are rejected with a clear message, token errors are differentiated, and logged-in users see who they're signed in as with explicit options.

## Appetite

1 week. Three focused changes touching ~5 files across frontend and backend. No new packages or architectural patterns.

## Context

Issues #19, #68, and #200 delivered a comprehensive auth system including magic link support. The `packages/email` package provides branded, i18n-ready email templates. Redirect-back-after-login is implemented via `?redirect=` query params. The current magic link flow:

1. User enters email on `/login` (Magic Link tab)
2. Frontend calls `authClient.signIn.magicLink({ email })`
3. Backend's `sendMagicLink` callback in `auth.instance.ts:126-153` queries `users` for locale, renders email, sends via Resend
4. User clicks link → `/magic-link/verify?token=xxx`
5. `useVerifyMagicLink` hook calls `authClient.magicLink.verify({ query: { token } })`
6. Three states: loading → success (redirect to dashboard) / error (generic message)

**Key files:**
- `apps/api/src/auth/auth.instance.ts` — `buildMagicLinkPlugin()` (lines 126-153)
- `apps/web/src/routes/-login-handlers.ts` — `handleMagicLink()` (lines 79-100)
- `apps/web/src/routes/magic-link/verify.tsx` — verification page (116 lines)
- `apps/web/src/lib/routeGuards.ts` — `requireGuest()` (lines 52-60)

**Related documents:**
- [Analysis: #200 Auth Flow Review](./200-auth-flow-review)
- [Spec: #200 Auth Flow Review](../specs/200-auth-flow-review)

## Decisions

The following decisions were made during a structured conversation (AskUserQuestion) before this analysis was written. They are **user-confirmed requirements**, not proposals:

1. **Unregistered email → Reject with error** ("No account found for this email"). Chosen over auto-create and redirect-to-signup.
2. **Token errors → Specific messages** (expired vs invalid vs used). Chosen over a single generic message.
3. **Logged-in user + magic link → Block and warn** ("You're already signed in as X. Sign out first."). Chosen over auto-switch and silent redirect.

## Questions Explored

1. What does Better Auth do when `signIn.magicLink` is called for an unregistered email?
2. What error codes does Better Auth return for different token verification failures?
3. How does the `requireGuest` guard interact with magic link verification?
4. What changes are needed to differentiate each scenario?

## Analysis

### Gap 1: Unregistered Email Handling

**Current behavior:** The `sendMagicLink` callback (`auth.instance.ts:132`) receives `{ email, url }` from Better Auth. It queries `users` for locale but does not check whether the user exists — if `userData` is null, it defaults to `'en'` and sends the email anyway. Better Auth generates a token regardless and, on verification, may create a new account.

**Risk:** A typo in the email address silently sends a magic link to the wrong address. If someone clicks it, an unintended account is created.

**Decision (from user):** Reject with error — show "No account found for this email."

**Implementation approach:** In the `sendMagicLink` callback, check `userData` existence before sending. If null, throw or return early. Better Auth's magic link plugin will propagate the error to the client. The frontend handler in `-login-handlers.ts:86-87` already handles `mlError` — add a specific check for the "user not found" error code.

**Security note:** See [Security Considerations](#security-considerations) below for the email enumeration trade-off.

### Gap 2: Generic Verification Error Messages

**Current behavior:** The `useVerifyMagicLink` hook (`verify.tsx:26-54`) checks for any error from `authClient.magicLink.verify()` and sets `status = 'error'`. The `ErrorState` component shows either "missing token" or "link invalid or expired" — no distinction between expired, already-used, or truly invalid tokens.

**Better Auth error codes:** The `magicLink.verify()` endpoint returns error objects with `code` and `message` fields. Common codes:
- `INVALID_TOKEN` — token doesn't exist in `verifications` table
- `TOKEN_EXPIRED` — token exists but `expiresAt &lt; now()`
- Token already used — record deleted after first use, returns `INVALID_TOKEN`

**Decision (from user):** Show specific messages for each case.

**Implementation approach:** Capture the error object in `useVerifyMagicLink` and expose the error code. The `ErrorState` component maps codes to messages:
- Expired → "This link has expired. Request a new one." + "Request new link" button
- Invalid/already used → "This link is invalid or has already been used." + "Back to sign in" link
- Missing token → "No verification token found." + "Back to sign in" link

**Note:** "Already used" and "invalid" cannot be distinguished server-side (both result in a missing record → same `INVALID_TOKEN` code). This is a **known limitation**: server logs cannot differentiate a double-click from a bad actor replaying a token. The combined message ("invalid or already used") covers both cases clearly for the user. If debugging becomes an issue, a future enhancement could log token lookups before deletion — tracked as a non-goal for this scope.

### Gap 3: Logged-In User Clicking Magic Link

**Current behavior:** `requireGuest` in `routeGuards.ts:52-60` checks `authClient.getSession()`. If a session exists, it throws `redirect({ to: '/dashboard' })`. The magic link token in the URL is never processed. The user silently lands on the dashboard with no indication that a magic link was involved.

**Decision (from user):** Block and warn — show "You're already signed in as {email}. Sign out first to use this link."

**Implementation approach:** Replace `requireGuest` with custom inline logic **in the component** (not `beforeLoad`, since we need to render UI instead of redirecting):

```
// Pseudocode for MagicLinkVerifyPage
session = authClient.useSession()
token = Route.useSearch().token

if (session.data &amp;&amp; token) → render WarningState (new)
  "You're already signed in as {session.data.user.email}."
  [Go to dashboard] button
  [Sign out] button → authClient.signOut() → reload page → re-triggers verify

if (session.data &amp;&amp; !token) → redirect to /dashboard

if (!session.data) → proceed with useVerifyMagicLink(token) (existing flow)
```

**Where the logic lives:** The `beforeLoad: requireGuest` is removed from the route definition. Session checking moves into the component body via `authClient.useSession()`. A new `WarningState` component is added alongside the existing `VerifyingState`, `SuccessState`, and `ErrorState`. No changes to `routeGuards.ts`.

## Shapes

### Shape A: Backend Rejection + Frontend Error Mapping

- **Description:** Backend validates email existence in `sendMagicLink` callback and throws if not found. Frontend parses error codes from both send and verify responses to show specific messages. Verify page handles auth state inline.
- **Trade-offs:**
  - ✅ Minimal surface area — changes are localized to existing files
  - ✅ No new API endpoints or middleware
  - ✅ Better Auth error propagation is already wired
  - ❌ Email enumeration via magic link endpoint (accepted trade-off)
- **Rough scope:** ~5 files, ~150 lines changed

### Shape B: Pre-Check API Endpoint + Frontend Error Mapping

- **Description:** Add a dedicated `/api/auth/check-email` endpoint that validates email existence before calling `signIn.magicLink`. Frontend calls check first, then magic link. Verify page changes same as Shape A.
- **Trade-offs:**
  - ✅ Separates validation from email sending
  - ❌ Extra network round-trip on every magic link request
  - ❌ New endpoint to maintain and secure
  - ❌ Race condition: email could be deleted between check and send
  - ❌ Over-engineered for a simple pre-check
- **Rough scope:** ~7 files, ~250 lines changed

## Fit Check

| Requirement | Shape A | Shape B |
|-------------|---------|---------|
| Reject unregistered email | ✅ | ✅ |
| Specific verify error messages | ✅ | ✅ |
| Block-and-warn logged-in users | ✅ | ✅ |
| No new API endpoints | ✅ | ❌ |
| Minimal code change | ✅ | ❌ |
| No race conditions | ✅ | ❌ |

**Selected shape:** Shape A — Backend Rejection + Frontend Error Mapping. Simplest approach, all validation happens where data already flows.

## Security Considerations

### Email Enumeration via Magic Link Endpoint

**Trade-off:** Rejecting unregistered emails with "No account found" reveals whether an email is registered. This is an **accepted trade-off** (user decision).

**Mitigations in place:**
- **Global rate limiter:** 5 auth requests per 60s per IP, 300s block on threshold breach (`customThrottler.guard.ts`)
- **No per-email rate limit** (user decision) — global limit is sufficient for this scope

**Residual risk:** A determined attacker with multiple IPs could enumerate emails at ~5/min/IP. This is comparable to the existing email/password login flow (which also returns distinct errors for "wrong password" vs "no account"). The risk profile is unchanged.

**Recommendation:** Confirm rate-limit effectiveness during implementation. If the team later moves to stricter anti-enumeration posture, all three auth endpoints (login, register, magic link) would need to be updated together.

## Conclusions

1. **Three focused changes** with no architectural complexity. All leverage existing Better Auth error propagation and frontend state management.
2. **Email enumeration trade-off is accepted** — the user explicitly chose "reject with error" over silent success. Rate limiting mitigates abuse.
3. **Error code mapping requires investigation** — Better Auth's exact error codes for magic link verification need to be confirmed during implementation. The `INVALID_TOKEN` and `TOKEN_EXPIRED` codes are expected but should be verified against the library source.
4. **The logged-in user warning is a UX improvement** that prevents confusion when magic links are shared or clicked from the wrong browser profile.

## Next Steps

- Create GitHub issue for these 3 magic link improvements
- Promote this analysis to a spec with detailed implementation plan
- Implement in a worktree via `/scaffold`
