---
title: "Spec 365 Review: Magic Link Edge Cases — Architectural Soundness"
description: Architecture review of spec 365, validating Better Auth integration, error handling approach, and security model.
---

## Review Summary

**Status: GOOD — Ready to implement**

The spec proposes a sound architecture for handling three magic link edge cases. The approach leverages Better Auth's native callback error propagation and error code extraction, avoiding unnecessary new endpoints or race conditions. Security trade-offs are explicitly documented and accepted.

---

## Detailed Findings

### 1. Better Auth Integration Approach — CORRECT

**Spec Claim:** "Throwing an error in the `sendMagicLink` callback propagates it to the SDK client as `{ error: { status, message, code } }`."

**Validation:**
- ✅ Better Auth's plugin API is designed for callback errors to propagate
- ✅ The SDK wraps the HTTP response and exposes error object to client
- ✅ Current code in `auth.instance.ts:126-153` already uses this callback; error throwing is the idiomatic extension point
- ✅ `-login-handlers.ts:86-87` already handles `mlError` object; infrastructure exists

**Verification Required (Implementation Phase):**
- [ ] Confirm exact shape of `error.code` when callback throws (e.g., does `throw new Error('USER_NOT_FOUND')` result in `error.code === 'USER_NOT_FOUND'` or is `APIError` required?)
- [ ] Log error object structure during first test request
- [ ] May need to import `APIError` from `better-auth/api` instead of plain `Error`

**Risk Level:** Low. Better Auth's callback pattern is well-established; minor shape adjustments possible but unlikely.

---

### 2. Verify Error Code Extraction — SOUND

**Spec Claim:** "`authClient.magicLink.verify()` returns error codes `INVALID_TOKEN` and `EXPIRED_TOKEN`. Frontend hook must capture and expose `error.code`."

**Validation:**
- ✅ Better Auth's magic link plugin uses standard token verification patterns
- ✅ Spec correctly identifies the two distinct error cases (expired vs invalid/used)
- ✅ Current code in `verify.tsx:26-54` discards error details; adding `setErrorCode(error.code)` is straightforward
- ✅ Error code extraction is idiomatic in SDK-based SPAs (standard pattern, not novel)
- ⚠️ Spec notes: "Already used" and "invalid" cannot be distinguished server-side (token deleted after use). Both return `INVALID_TOKEN`. **This is correct.** Combined message ("invalid or already been used") is appropriate.

**Verification Required:**
- [ ] Confirm `INVALID_TOKEN` and `EXPIRED_TOKEN` are the actual returned codes (vs `TOKEN_INVALID`, `TOKEN_EXPIRED`, etc.)
- [ ] Check if other error codes are possible (e.g., malformed token format, database errors)

**Risk Level:** Very Low. Error code extraction is a common pattern; exact code names can be verified via Better Auth docs or library source.

---

### 3. Session Check Replaces `requireGuest` — CORRECT DESIGN

**Spec Claim:** "Remove `beforeLoad: requireGuest` from route definition. Replace with inline `authClient.useSession()` to enable WarningState rendering."

**Validation Against Current Code:**

Current route (`verify.tsx:15-16`):
```typescript
export const Route = createFileRoute('/magic-link/verify')({
  beforeLoad: requireGuest,  // ← Redirects logged-in users to /dashboard
  // ...
})
```

Current guard (`routeGuards.ts` not shown, but pattern is clear):
```typescript
// Pseudocode: if (session.data) throw redirect({ to: '/dashboard' })
```

**Problem with Current Approach:**
1. Route-level guards cannot render conditional UI — only redirect or allow
2. Magic link token in URL is never processed; user sees dashboard with no context
3. Poor UX: user doesn't understand why they were redirected

**Spec Solution:**
- ✅ Move session check into component body (`authClient.useSession()`)
- ✅ Three-way branch: session+token → warning, session+!token → redirect, !session → verify
- ✅ Allows rendering `WarningState` with "You're already signed in as {email}. Sign out to use this link."
- ✅ This is the idiomatic React Router + auth pattern (conditional rendering over route guards)

**State Machine Validation:**
```
useSession() ─┬─ session + token → WarningState (new)
              │   "Sign out" button → signOut() → reload → re-verify as guest
              │   "Go to dashboard" button → navigate /dashboard
              │
              ├─ session + !token → redirect /dashboard (same as current requireGuest)
              │
              └─ !session → useVerifyMagicLink(token)
                   ├─ loading → VerifyingState (current)
                   ├─ success → SuccessState (current)
                   └─ error → ErrorState(code) (enhanced with code)
```

**This state machine is sound.** Each path is explicit; no hidden redirects.

**Edge Cases Covered:**
- ✅ Magic link with no token + logged in → redirect /dashboard
- ✅ Magic link with token + logged in → warning
- ✅ Magic link + logout via warning → reload triggers fresh verify
- ✅ Click "Go to dashboard" → token stays valid (expires naturally in 5 min)

**Risk Level:** Very Low. This is a textbook React component refactor. No novel patterns.

---

### 4. Security Analysis — ACCEPTABLE WITH MITIGATIONS

**Email Enumeration via Magic Link Endpoint**

**Spec Statement:** "Returning 'no account found' reveals email registration status. Mitigated by global rate limiter (5 req/60s per IP)."

**Assessment:**
- ✅ **Trade-off is explicit:** Spec acknowledges the risk and the user's decision to accept it
- ✅ **Mitigation is in place:** Custom throttler at `customThrottler.guard.ts` enforces 5/60s per IP
- ✅ **Risk profile unchanged:** This is identical to existing email/password login behavior (which also returns distinct "no account" vs "wrong password" errors)
- ✅ **Comparable attacks:** Determined attacker with multiple IPs could enumerate ~5 emails/min/IP — same as brute-forcing passwords

**Rate Limiter Verification Needed:**
- [ ] Confirm `customThrottler.guard.ts` applies to `/api/auth/signin/magic-link` endpoint
- [ ] Test 5-per-60-second limit in isolation (manual test or integration test)
- [ ] Confirm block duration (300s stated in analysis)

**Recommendations:**
- If risk posture changes later, update all three auth endpoints together (login, register, magic link) — don't silently fix just magic link
- Consider adding observability: log/alert on enumeration patterns (e.g., 10+ unique IPs hitting same endpoint in 5 minutes)

**Risk Level:** Low. Mitigations are documented and in place. User has explicitly accepted the trade-off.

---

### 5. Code Impact Analysis

**Files Modified:**
1. `apps/api/src/auth/auth.instance.ts` — Add email existence check in `sendMagicLink` callback
2. `apps/web/src/routes/-login-handlers.ts` — Detect `USER_NOT_FOUND` error in `handleMagicLink`
3. `apps/web/src/routes/magic-link/verify.tsx` — Capture error code, add session check, add WarningState
4. `apps/web/messages/{en,fr}.json` — Add 5 new i18n keys per language

**Scope: ~150 lines, 4 files — Tier F-lite confirmation appropriate**

**Regressions Unlikely:**
- Backend: error check is additive (doesn't change happy path)
- Frontend: error code extraction is additive (hook still returns status)
- Route: session check replaces guard but preserves all three paths
- i18n: new keys only; no changes to existing translations

---

### 6. Implementation Readiness

**Open Questions from Spec (Explicitly Flagged):**

1. **`APIError` propagation:** Does Better Auth's `APIError` from `better-auth/api` propagate `message` as `error.code`?
   - **Mitigation:** Spec marks as "[NEEDS CLARIFICATION]" and "Test during implementation"
   - **Risk:** Low — if wrong, adjust in first test iteration
   - **Resolution:** Log error shape in callback error handler; adjust frontend error detection

2. **Verify endpoint redirect vs SDK:** SDK wraps HTTP redirect with `?error=<code>` — does `error.code` field get populated?
   - **Mitigation:** Spec marks as "[NEEDS VERIFICATION]"
   - **Risk:** Low — Better Auth docs or source code clarifies
   - **Resolution:** Test with actual token; check error object in console

3. **Token deletion timing:** After first verification, does token immediately delete? Or is there a window for second verification?
   - **Mitigation:** Spec notes this is implementation-dependent
   - **Risk:** Very Low — second click will fail appropriately with `INVALID_TOKEN` either way
   - **Resolution:** Observe in logs during testing

**These questions are NOT blockers** — all three have clear resolution paths (test during implementation) and do not affect the soundness of the overall approach.

---

### 7. Comparison to Alternatives (from Analysis)

**Shape A (Selected):** Better Auth Callback Error Propagation + Client-Side Error Mapping
- ✅ No new endpoints, no race conditions, minimal code change
- ✅ Leverages existing Better Auth infrastructure
- ✅ **Selected as the sound choice**

**Shape B (Considered & Rejected):** Dedicated Email Pre-Check Endpoint
- ❌ Race condition: email deleted between check and send
- ❌ Extra round-trip (latency)
- ❌ Over-engineered for a simple check
- **Correctly rejected**

**Comparison is thorough and reaches the right conclusion.**

---

## Verification Checklist

- [ ] Better Auth error code shape confirmed (implementation phase)
- [ ] Rate limiter validates endpoint coverage and enforcement
- [ ] Error code mapping tested for all four codes (EXPIRED_TOKEN, INVALID_TOKEN, USER_NOT_FOUND, + fallback)
- [ ] Session check + warning state tested (logged-in user clicks link)
- [ ] Logout-and-retry flow tested (warning state → signOut → reload)
- [ ] i18n keys complete (EN + FR, `bun run i18n:check` passes)
- [ ] No regressions in happy path (unregistered → registered email, valid token, guest user)

---

## Recommendations

1. **Implementation can proceed immediately.** All three edge cases are architecturally sound.
2. **Classify as Tier F-lite.** Clear scope, single domain (auth), fully documented. No bootstrap needed.
3. **Create worktree from staging:** `git worktree add ../roxabi-365 -b feat/365-magic-link-edge-cases staging`
4. **Phases can be sequential:** Backend validation → frontend send error → verify error codes → warning state. Each phase depends on previous.
5. **Test each open question on day 1 of implementation:** Error code shape, rate limit coverage, SDK behavior. Surface any divergence immediately.
6. **Document error code mapping** in code comments for future maintainers (e.g., "Better Auth returns `EXPIRED_TOKEN` for tokens past `expiresAt`").

---

## Conclusion

**The spec is architecturally sound.** It correctly identifies Better Auth's native error handling as the appropriate extension point, avoids unnecessary endpoints and race conditions, and addresses all three edge cases with clear, separate code paths. Security trade-offs are explicit and mitigated. Implementation can proceed with confidence.

**Status: APPROVED FOR IMPLEMENTATION**
