---
title: "Public API & Developer Platform"
description: Unified analysis covering API key management, per-key rate limiting, and CLI generation for the Roxabi developer platform.
---

## Context

Roxabi needs a public API to support external integrations, third-party developers, and AI agents. The platform already has strong foundations — Better Auth for session-based authentication, a two-tier rate limiting system backed by Upstash Redis, RBAC with granular permissions, OpenAPI/Swagger documentation, and a multi-tenant architecture with org-scoped data.

This analysis covers the full "Developer Platform" epic (#194) which groups three dependent issues:

1. **#57** — Public API &amp; API Keys (foundational)
2. **#146** — Public API Key Rate Limiting (depends on #57)
3. **#58** — CLI from OpenAPI / AI Agent Interface (depends on #57)

**Promoted from:** GitHub issues [#194](https://github.com/roxabi/roxabi_boilerplate/issues/194), [#57](https://github.com/roxabi/roxabi_boilerplate/issues/57), [#146](https://github.com/roxabi/roxabi_boilerplate/issues/146), [#58](https://github.com/roxabi/roxabi_boilerplate/issues/58)

**Complexity score:** 7/10 (Tier F-full)

## Questions Explored

1. How should API key authentication coexist with the existing Better Auth session system?
2. How should API key scopes map to the existing RBAC permission model?
3. What API versioning strategy best fits the platform?
4. What rate limiting model should apply to API keys?
5. How should the CLI be generated — build-time codegen or runtime OpenAPI client?
6. What endpoints should comprise the V1 public API surface?
7. How do both human developers and AI agents consume the API effectively?
8. How does the CLI handle initial authentication without an OAuth authorization server?
9. What does the API key management UI look like?

## Analysis

### 1. API Key Authentication

**Current state:** The `AuthGuard` (global `APP_GUARD`) validates cookie-based sessions via Better Auth. It supports decorators for public routes (`@AllowAnonymous`), optional auth (`@OptionalAuth`), role checks (`@Roles`), org requirements (`@RequireOrg`), and permission checks (`@Permissions`).

**Proposed approach:** Extend `AuthGuard.canActivate()` with a Bearer token fallback. When no cookie session is found, the guard checks for an `Authorization: Bearer sk_live_xxx` header, looks up the key hash in the `api_keys` table, and constructs a synthetic session with the key's org context and scoped permissions.

**Key format:** Prefix-based for easy identification and partial display:
- `sk_live_` — production keys
- `sk_test_` — test/sandbox keys (future)

The full key is shown once at creation. Only the prefix + last 4 characters are stored in plaintext for display. The full key is hashed (SHA-256 + salt) for lookup.

**Lookup flow:**
1. Extract `Authorization: Bearer <token>` header
2. Hash the token
3. Query `api_keys` table by hash (indexed)
4. Verify: not revoked, not expired, org is active
5. Construct `AuthenticatedSession` with `actorType: 'api_key'`
6. Set `request.session` and `request.user` as if it were a cookie session
7. Permission checks (`@Permissions`) work unchanged — they read from the session

**Synthetic session construction:** The API key lookup populates an `AuthenticatedSession` where:
- `user.id` = the key's `userId` (the user who created the key, not the key ID itself)
- `session.id` = the key's `id` (used as a synthetic session identifier)
- `session.activeOrganizationId` = the key's `tenantId`
- `permissions` = the key's `scopes` array (already intersected with org permissions)
- `actorType` = `'api_key'` (new variant — requires updating `AuditActorType` in `packages/types/src/audit.ts`)

This means `user.id` still references a real user, so the existing soft-delete check (`userService.getSoftDeleteStatus(user.id)`) works unchanged. The guard skips the soft-delete check entirely when `actorType === 'api_key'` since key validity is checked separately (revoked/expired).

**Audit integration:** The `audit_logs.actorId` column has a FK constraint to `users.id`. For API key audit events, `actorId` stores the key owner's `userId` (a valid user FK), and a new `apiKeyId` column is added to the audit log for traceability. `AuditAction` in `@repo/types` must be extended with `api_key.created`, `api_key.revoked`, and `api_key.rotated` actions.

**Key enumeration protection:** Hash lookups use `crypto.timingSafeEqual` for the comparison step to prevent timing-based key enumeration.

### 2. API Key Scopes &amp; RBAC Integration

API key scopes reuse the existing RBAC permission strings (e.g., `members:read`, `roles:write`). This means:

- **No new permission system** — one model for both session users and API keys
- **Least privilege by default** — keys can only have a subset of permissions available to the creating user's role
- **Validation at creation** — the API validates that requested scopes are a subset of the user's current permissions
- **Runtime enforcement** — the `@Permissions()` decorator works identically for session and API key auth

The `api_keys` table stores scopes as a `text[]` column. When constructing the synthetic session, the guard intersects the key's scopes with the org's currently available permissions **at runtime** (not just at creation time). This means if a user's role is downgraded after key creation, the key's effective permissions shrink accordingly — no stale elevated access.

### 3. API Versioning

**Strategy:** URL prefix versioning (`/api/v1/`).

- Simple, widely adopted, easy to route and document
- Version-specific controllers under `src/public-api/v1/`
- Internal app routes (`/api/organizations`, `/api/users`, etc.) remain unchanged — the web frontend continues using them directly
- Public routes are a thin layer: new controllers calling existing services with API-key-aware serialization
- **Versioning lifecycle:** V2 is introduced only when breaking changes are needed. V1 remains supported for a minimum deprecation window (documented in public API docs). Deprecation policy details are out of scope for V1 — we commit only to not breaking V1 without notice.

**Error response format:** Public API responses follow a consistent error envelope based on the existing `AllExceptionsFilter` format:

```json
{
  "error": {
    "code": "API_KEY_INVALID",
    "message": "The provided API key is invalid or has been revoked.",
    "statusCode": 401
  }
}
```

New error codes: `API_KEY_INVALID`, `API_KEY_REVOKED`, `API_KEY_EXPIRED`, `API_KEY_RATE_LIMITED`, `API_KEY_SCOPE_DENIED`.

**Route structure:**

```
/api/v1/organizations      GET, PATCH
/api/v1/members            GET, POST, PATCH, DELETE
/api/v1/invitations        GET, POST, DELETE
/api/v1/roles              GET, POST, PATCH, DELETE
/api/v1/users/me           GET
/api/v1/api-keys           GET, POST, DELETE (self-management)
```

### 4. Rate Limiting

**Current state:** Two throttler tiers exist — `global` (60 req/60s) and `auth` (5 req/60s for sensitive paths). Env vars `RATE_LIMIT_API_TTL` and `RATE_LIMIT_API_LIMIT` are already declared and validated but not wired to a tier.

**Proposed approach:**

- Add a third throttler tier: `api` using the existing env vars (default: 100 req/60s)
- Tracker key: `apikey:${keyId}` (instead of `user:${userId}` or `ip:${ip}`)
- `CustomThrottlerGuard.handleRequest()` detects API key auth and applies the `api` tier
- Rate limit headers (`X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`) included on all API key responses (the existing `registerRateLimitHeadersHook()` already adds these — just needs to be applied to the `api` tier)

**Tier schema:** The `api_keys` table includes a `rateLimitTier` column (`'standard' | 'premium'`) defaulting to `'standard'`. Only the standard tier is implemented in V1. Premium tier activates when billing is available — the lookup logic is a single branch:

```typescript
const tier = apiKey.rateLimitTier === 'premium'
  ? { ttl: PREMIUM_TTL, limit: PREMIUM_LIMIT }
  : { ttl: env.RATE_LIMIT_API_TTL, limit: env.RATE_LIMIT_API_LIMIT }
```

### 5. CLI Generation

Two mutually exclusive approaches explored as shapes below. Both produce a standalone CLI package (`packages/cli` or a separate repo) that:

- Authenticates via device code login or direct API key
- Mirrors the public API structure as hierarchical commands (e.g., `roxabi members list`)
- Supports `--json` flag for machine-parseable output (AI agents)
- Provides human-friendly formatted output by default

### 6. Public API Controllers

New controllers under `src/public-api/v1/` act as a thin layer:

- **Input:** Accept the same DTOs as internal controllers (or simplified public versions)
- **Service layer:** Call existing services (`OrganizationService`, `AdminMembersService`, etc.)
- **Output:** Serialize responses with public-facing DTOs (may differ from internal responses — e.g., hide internal IDs, add HATEOAS links)
- **Auth:** Require API key auth via `@RequireApiKey()` decorator — this sets `SetMetadata('REQUIRE_API_KEY', true)` on the route. The extended `AuthGuard` reads this metadata: if set, only API key auth is accepted (session cookies are rejected with 401). If not set, both auth methods work. This prevents session-authenticated users from accidentally reaching public-only endpoints.
- **Docs:** Separate OpenAPI document for public API (Swagger UI at `/api/v1/docs`)

### 7. Database Schema

New `api_keys` table using the established Drizzle patterns:

```typescript
const genId = () => crypto.randomUUID()

export const apiKeys = pgTable('api_keys', {
  id: text('id').primaryKey().$defaultFn(genId),
  ...tenantColumn,                          // org-scoped via RLS
  userId: text('user_id').references(() => users.id).notNull(),
  name: text('name').notNull(),             // human-readable label
  keyPrefix: text('key_prefix').notNull(),  // "sk_live_" display prefix
  keyHash: text('key_hash').notNull().unique(),
  keySalt: text('key_salt').notNull(),      // per-key salt for SHA-256
  lastFourChars: text('last_four').notNull(),
  scopes: text('scopes').array().notNull().default([]),
  rateLimitTier: text('rate_limit_tier').notNull().default('standard'),
  expiresAt: timestamp('expires_at', { withTimezone: true }),
  lastUsedAt: timestamp('last_used_at', { withTimezone: true }),
  revokedAt: timestamp('revoked_at', { withTimezone: true }),
  ...timestamps,
})
```

### 8. API Key Management UI

API key management lives in the org settings area (extending the existing settings sidebar):

- **Location:** `/settings/api-keys` — new tab in the settings layout alongside "Profile" and "Account"
- **Create key flow:** Name field + scope checkboxes (filtered to the user's current permissions) + optional expiry date → shows the full key **once** with a copy button and warning
- **Key list:** Table showing name, prefix + last 4 chars, scopes (badges), created date, last used, status (active/expired/revoked)
- **Revoke:** Destructive action with `DestructiveConfirmDialog` (existing component)
- **Rotate:** Create new key → copy → optionally revoke old key (not atomic — user controls the transition)

The UI follows the established admin pattern from `admin/members.tsx`: TanStack Query for data fetching, skeleton loading, error card, and invalidation on mutation.

### 9. CLI Authentication Flow

The CLI bridges interactive and non-interactive auth. **Important:** The current system uses Better Auth for session-based auth — there is no OAuth 2.0 authorization server. The CLI auth flow uses a **device code** pattern instead:

1. `roxabi auth login` → CLI calls `POST /api/v1/auth/device-code` to get a `device_code` + `user_code` + `verification_url`
2. CLI opens the browser to the verification URL (a page in the web app)
3. User logs in via Better Auth (if not already) and enters the `user_code` to authorize the CLI
4. CLI polls `POST /api/v1/auth/device-token` until the code is confirmed
5. Server creates an API key and returns it in the poll response
6. CLI stores the key in `~/.config/roxabi/credentials.json`
7. All subsequent CLI commands use `Authorization: Bearer &lt;key&gt;`

**Fallback:** Users can also paste an API key manually (`roxabi auth login --token sk_live_xxx`) for environments where a browser is not available (CI/CD, remote servers).

This avoids the need for a full OAuth 2.0 authorization server while providing a smooth interactive experience similar to `gh auth login`.

## Shapes

### Shape 1: Build-Time CLI Codegen

- **Description:** Use `openapi-typescript` to generate typed client code from the OpenAPI spec at build time. The CLI is a standalone npm package (`packages/cli`) that wraps the generated client with Commander.js commands. Published to npm as `@roxabi/cli`.
- **Trade-offs:**
  - **Pro:** Fully typed, deterministic, works offline after install, version-locked to a specific API version
  - **Pro:** Build step catches breaking changes before release
  - **Con:** Requires a codegen pipeline (generate → build → publish)
  - **Con:** CLI version can drift from deployed API — needs versioned releases
- **Rough scope:** ~15 files (codegen config, CLI entry point, command modules, auth module, output formatter, tests). Adds `packages/cli` to the monorepo.

### Shape 2: Runtime OpenAPI Client

- **Description:** The CLI fetches the OpenAPI spec from the running server on first use and dynamically builds commands from it. Uses `openapi-fetch` or similar runtime client. Commands are generated from spec paths/operations.
- **Trade-offs:**
  - **Pro:** Always up-to-date with the deployed API — no version drift
  - **Pro:** No codegen pipeline needed
  - **Con:** Requires network access on first run (can cache the spec locally)
  - **Con:** Less type safety during development
  - **Con:** Startup latency on first use (spec fetch + parse)
  - **Con:** Harder to provide rich help text and examples (generated from spec metadata)
- **Rough scope:** ~12 files (CLI entry point, dynamic command builder, spec fetcher/cache, auth module, output formatter, tests). Same `packages/cli` location.

### Shape 3: Hybrid (Build-Time Types + Runtime Discovery)

- **Description:** Generate TypeScript types from OpenAPI at build time for type safety, but discover available commands at runtime from the server's spec. The CLI ships with compiled types but adapts its command tree to the server version.
- **Trade-offs:**
  - **Pro:** Type safety during development + runtime adaptability
  - **Pro:** Graceful degradation — works with types even if server is unreachable
  - **Con:** Most complex — combines both pipelines
  - **Con:** Type mismatches when server is ahead of compiled types
- **Rough scope:** ~18 files. Combines both approaches.

## Fit Check

| Requirement | Shape 1 (Build-Time) | Shape 2 (Runtime) | Shape 3 (Hybrid) |
|---|---|---|---|
| Works offline after install | ✅ | ❌ | ✅ |
| Always matches deployed API | ❌ | ✅ | ❌ |
| Full TypeScript type safety | ✅ | ❌ | ✅ |
| No codegen pipeline needed | ❌ | ✅ | ❌ |
| Rich help text &amp; examples | ✅ | ❌ | ✅ |
| AI agent friendly (predictable) | ✅ | ✅ | ✅ |
| Minimal complexity | ✅ | ✅ | ❌ |
| Fast startup | ✅ | ❌ | ✅ |

**Selected shape:** **Shape 1 (Build-Time CLI Codegen)** — Type safety, offline capability, rich help text, and deterministic behavior outweigh the version drift concern (which is manageable with a CI pipeline that regenerates on API changes). AI agents benefit from predictable, versioned command structures. The codegen pipeline also serves as a contract test — if the spec changes in a breaking way, the build fails.

## Conclusions

1. **API key auth fits cleanly into the existing guard** — a Bearer token fallback in `AuthGuard.canActivate()` requires minimal changes to the auth flow while reusing all existing decorators.
2. **RBAC reuse eliminates a parallel permission system** — API key scopes are just permission string subsets, enforced by the same `@Permissions()` decorator. Runtime intersection prevents stale elevated access.
3. **The rate limiting infrastructure is 90% built** — adding the third `api` tier to the throttler config and wiring it to API key auth is straightforward.
4. **New `/api/v1/*` controllers provide a clean public surface** without modifying internal routes — the web app continues using existing endpoints unchanged.
5. **Build-time CLI codegen** provides the best developer experience for both humans and AI agents, with type safety and offline capability.
6. **Device code auth flow** avoids building a full OAuth 2.0 authorization server while providing a smooth CLI onboarding experience — two new endpoints + a web verification page.
7. **Key management UI** fits naturally into the existing settings layout using established TanStack Query patterns.

### Implementation notes from expert review

- `audit_logs.actorId` FK constraint requires using the key's `userId` (not key ID) as `actorId`, plus a new `apiKeyId` column
- `AuditActorType` and `AuditAction` in `@repo/types` need extension for `'api_key'` events
- `lastUsedAt` updates should be fire-and-forget (non-blocking async write) to avoid adding latency to every request
- Key rotation is supported via create-then-revoke pattern — no atomic rotation needed in V1
- `sk_test_` prefix is reserved but not implemented in V1 — explicitly a non-goal
- HATEOAS links in public API responses are a non-goal for V1
- `CustomThrottlerGuard.getTracker()` needs to detect API key auth from the request context — the tracker must be resolved inside `handleRequest()` where the throttler name is known

## Next Steps

- Promote this analysis to a spec via `/interview --promote artifacts/analyses/194-public-api-developer-platform.mdx`
- The spec should define the Breadboard (UI → Code → Data wiring) and Slices (vertical increments) for implementation
- Recommended slice order:
  1. **V1:** API key CRUD (schema + service + management UI + self-management endpoint)
  2. **V2:** Auth guard extension (Bearer token fallback + synthetic session + `@RequireApiKey()` decorator)
  3. **V3:** Public API controllers (5 resources under `/api/v1/`)
  4. **V4:** Rate limiting tier activation (wire `api` tier to API key tracker)
  5. **V5:** CLI package (codegen pipeline + device code auth + core commands)
