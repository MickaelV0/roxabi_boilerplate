---
title: "CI/CD Pipeline Hardening"
description: Analysis of five CI/CD improvements — PR title enforcement, scope-aware CI, release-please evaluation, docs link audit, and PR template.
---

## Context

The Roxabi boilerplate's CI pipeline is functional but has gaps identified during the [repo comparison epic (#163)](https://github.com/MickaelV0/roxabi_boilerplate/issues/163). Reference repos (OpenClaw, memU, LocalAI, aidd, review-flow) all implement one or more of these improvements. This analysis covers five discrete tasks from [issue #222](https://github.com/MickaelV0/roxabi_boilerplate/issues/222), ranging from XS to M in size.

**Current CI infrastructure:**

- `ci.yml` — Lint, Typecheck, Test, Build, E2E (with `dorny/paths-filter` for E2E path detection)
- `deploy-preview.yml` — Manual preview deploys (web + API with Neon branch management)
- `auto-merge.yml` — Squash-merge when "reviewed" label is present
- `neon-cleanup.yml` — Deletes Neon DB branches on PR close
- `lefthook.yml` — Local hooks: commitlint (commit-msg), biome (pre-commit), lint+typecheck+test (pre-push)

**Key gap:** Local git hooks (lefthook) enforce Conventional Commits on individual commits, but squash-merge uses the **PR title** as the final commit message — bypassing commitlint entirely. No CI-level validation of PR titles exists.

**See also:** [CI/CD GitHub Actions analysis](./08-cicd-github-actions.mdx) for prior CI architecture decisions.

## Questions Explored

1. How should PR titles be validated in CI to close the squash-merge loophole?
2. Which file paths should trigger CI skips, and how granular should the filter be?
3. Is `release-please` a good fit for this project's release workflow?
4. What tooling best validates internal MDX links in CI?
5. What sections should a PR template include for this project?

## Analysis

### Task 1: PR Title Conventional Commits Enforcement (XS)

**Problem:** Squash-merge rewrites the commit message to the PR title. If the PR title is `fix stuff`, the Conventional Commits convention is violated on `main`/`staging` despite local commitlint passing. This breaks changelog generation, semantic versioning, and commit history readability.

**Solution:** Add `.github/workflows/pr-title.yml` using [`amannn/action-semantic-pull-request`](https://github.com/amannn/action-semantic-pull-request).

**Configuration decisions:**

- **Allowed types:** `feat`, `fix`, `refactor`, `docs`, `style`, `test`, `chore`, `ci`, `perf`, `build`, `revert` (matching `commitlint.config.cjs` exactly)
- **Scopes:** Optional, freeform (e.g., `feat(auth):`, `fix(web):`) — no fixed list enforced
- **Bot exemptions:** Exempt `dependabot[bot]` and `renovate[bot]` via the action's `ignoredAuthors` input (not `ignoreLabels`, which does not exist on this action)
- **Trigger:** `pull_request` types `[opened, edited, synchronize, reopened]` — no branch filter needed (branch protection settings control where the check is required)
- **Required status check:** Mark this workflow as a required check in branch protection to block merge on failure

**Edge cases:**

- PRs with `!` for breaking changes (e.g., `feat!:`) should be allowed
- Empty or multi-line PR titles should fail validation
- Renovate/dependabot PRs often use their own title format — exempting by actor avoids noise

**Effort:** ~1 new workflow file, ~25 lines. No changes to existing workflows.

### Task 2: Scope-Aware CI — Docs-Only Skip (S)

**Problem:** Editing a markdown file in `docs/` triggers the full CI pipeline (lint, typecheck, test, build, ~5-10 min). This wastes CI minutes and slows down documentation PRs.

**Solution:** Add a `detect-changes` job at the top of `ci.yml` using `dorny/paths-filter` (already a dependency for the E2E path check). Downstream jobs conditionally skip when only non-code files changed.

**Paths that should skip full CI:**

```yaml
code:
  - 'apps/**'
  - 'packages/**'
  - 'turbo.jsonc'
  - 'bun.lock'
  - 'biome.json'
  - 'tsconfig*.json'
  - 'lefthook.yml'
```

If `code` filter returns `false`, skip `lint`, `typecheck`, `test`, `build`, and `e2e` jobs. This means changes to `docs/**`, `artifacts/analyses/**`, `artifacts/specs/**`, root `*.md` files, and `.claude/**` naturally trigger the skip without needing explicit listing.

**Implementation pattern:**

```yaml
jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      code: ${{ steps.filter.outputs.code }}
    steps:
      - uses: actions/checkout@v6
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            code:
              - 'apps/**'
              - 'packages/**'
              - 'turbo.jsonc'
              - 'bun.lock'
              - 'biome.json'
              - 'tsconfig*.json'
              - 'lefthook.yml'
              - '.github/workflows/**'

  lint:
    needs: detect-changes
    if: needs.detect-changes.outputs.code == 'true'
    # ... existing config
```

**Edge cases:**

- `push` events on `main`/`staging` should **always** run full CI regardless of paths (safety net) — apply the skip filter only to `pull_request` events
- The `workflow_call` trigger on `ci.yml` means other workflows can call it — the skip logic must handle this event type too (treat as "always run", like `push`)
- The `check-e2e-paths` job already uses `dorny/paths-filter` — consolidate into the new `detect-changes` job to avoid redundant checkout+filter steps
- Required status checks: when jobs are skipped, GitHub sees them as "not run" which can block merge. **Recommended solution:** Add a terminal `ci-success` aggregator job that depends on all other jobs with `if: always()`, checks their outcomes, and is the **only** required branch protection check. This is the standard pattern for conditional CI jobs
- Workflow files (`.github/workflows/**`) are included in the code filter so that CI config changes always trigger full validation

**Effort:** Modify `ci.yml` — add 1 new job, update `if:` conditions on 4-5 existing jobs.

### Task 3: Evaluate `release-please` (M)

**Problem:** Releases are currently manual via the `/promote` skill (bump version, write changelog, create PR, tag). As the project scales, this becomes a bottleneck. Conventional Commits already provide the raw data for automated releases.

**What `release-please` does:**

- Reads Conventional Commits since last release
- Auto-generates `CHANGELOG.md` entries grouped by type (Features, Bug Fixes, etc.)
- Bumps version according to semver (feat → minor, fix → patch, `!` → major)
- Creates a "Release PR" that, when merged, triggers a GitHub Release + git tag
- Supports monorepo mode (separate versions per package)

**Comparison with current `/promote` skill:**

| Aspect | `/promote` (current) | `release-please` |
|--------|----------------------|-------------------|
| Trigger | Manual command | Automatic on push to main |
| Changelog | Generated by Claude, reviewed by human | Generated from commits, deterministic |
| Version bump | Computed by skill | Computed from commit types |
| GitHub Release | Not automated | Automated on Release PR merge |
| Monorepo support | Single version | Per-package versions possible |
| Customization | Full control (skill code) | Config-driven (manifest + config) |
| Human review | `/promote` creates PR for review | Release PR created for review |

**Trade-offs:**

- **Pro:** Fully automated, deterministic, widely adopted (10k+ stars), maintained by Google
- **Pro:** Release PRs give the same review gate as `/promote`
- **Con:** Less flexible than custom skill — e.g., custom changelog sections, pre-release validation scripts require workarounds
- **Con:** Monorepo config can be complex (manifest.json + release-please-config.json)
- **Con:** Migration from existing workflow requires adapting `/promote` or retiring it

**Critical compatibility note:** The auto-merge workflow uses `--squash`. If release-please is adopted, its Release PRs must **not** be squash-merged — squashing collapses the commit history that release-please reads to generate changelogs. This is a blocking compatibility issue that the ADR must address (e.g., merge Release PRs with `--merge` instead of `--squash`, or use a label-based merge strategy selector).

**Recommendation:** Produce an ADR evaluating adoption. The research phase should cover: (1) monorepo configuration complexity, (2) integration with the existing auto-merge workflow (squash vs merge conflict), (3) whether `/promote` can coexist or should be replaced, (4) impact on the existing `CHANGELOG.md` and tag format.

**Why this is sized M (not S):** While the output is a document, the research requires understanding release-please's monorepo manifest format, testing config against this repo's structure, and resolving the auto-merge compatibility question — more investigation than a typical S analysis.

**Effort:** Research + ADR document. Implementation (if approved) would be a separate issue.

### Task 4: Docs Link Audit in CI (S)

**Problem:** Internal MDX docs reference each other with relative links (e.g., `[guide](./auth.mdx)`, `[spec](../specs/42-foo.mdx)`). When files are renamed, moved, or deleted, these links silently break. No automated check catches this.

**Tool options:**

| Tool | Approach | Pros | Cons |
|------|----------|------|------|
| `markdown-link-check` | HTTP check + file check | Mature, configurable | Slow on HTTP links, config verbose |
| `remark-validate-links` | AST-based, local only | Fast, remark ecosystem | Doesn't check external URLs |
| Custom script (Bun) | Regex/AST scan + `fs.existsSync` | Full control, fast, no new dep | Maintenance burden |
| `lychee` | Rust-based, fast | Very fast, handles both local + HTTP | External binary, less JS ecosystem fit |

**Recommendation:** Use `lychee` — it's fast, handles both internal and external links, can be configured via `.lychee.toml`, and has a GitHub Action (`lycheeverse/lychee-action`). Exclude external URLs initially (just check internal links resolve) to avoid flaky CI from transient HTTP failures.

**Configuration:**

```toml
# .lychee.toml
exclude_path = ["node_modules", ".turbo", "coverage"]
include_fragments = true
# Start with internal links only
exclude = ['^https?://']
```

**CI integration:** Add as a **separate lightweight job** (not inside the `lint` job — `lychee` is a Rust binary unrelated to the Bun/Biome toolchain, and docs-link failures should not block the main lint gate). This also pairs well with Task 2's skip logic: the docs-link job can run on the inverse condition — only when docs files changed. Uses `lycheeverse/lychee-action` which handles binary installation transparently.

**Edge cases:**

- MDX-specific syntax (JSX components, imports) may confuse some link checkers — `lychee` handles this well
- Anchor links (`#section`) should be validated if possible
- Links to generated files (e.g., API docs) may not exist at CI time — add to exclude list

**Effort:** 1 new config file + 1 CI job/step addition.

### Task 5: PR Template Audit (XS)

**Current state:** A PR template already exists at `.github/PULL_REQUEST_TEMPLATE.md` with sections: Summary, Related Issue, Type of Change, Changes Made, Testing, Screenshots, Checklist. It covers most needs but has gaps.

**Gaps identified:**

- **Missing commit types in checkboxes:** `style`, `perf`, `build`, `revert` are valid commitlint types but absent from the template's Type of Change section
- **Missing checklist items:** "PR title follows Conventional Commits" and "No secrets committed" are not in the checklist
- **No alignment with `/pr` skill:** The `/pr` skill generates structured PR bodies — the template sections should complement (not conflict with) what `/pr` produces

**Solution:** Update the existing template to close these gaps. This is a small edit to an existing file, not a new creation.

**Edge cases:**

- Bot PRs (dependabot) auto-fill with their own template — the template is additive, not restrictive
- The `/pr` skill already generates structured PR bodies — the template ensures consistency even for manual PRs
- Keep it concise — overly long templates get ignored

**Effort:** Edit existing file, ~5-10 lines of changes.

## Conclusions

All five tasks are well-scoped, low-risk CI improvements with clear implementation paths:

| Task | Size | Priority | Dependencies |
|------|------|----------|--------------|
| PR title enforcement | XS | High | None — closes an active gap |
| PR template audit | XS | Medium | None — update existing file |
| Scope-aware CI skip | S | Medium | None — extends existing pattern |
| Docs link audit | S | Low | None — additive |
| Release-please evaluation | M | Low | Task 1 (needs Conventional Commits enforced first) |

**Suggested implementation order:** Task 1 → Task 5 → Task 2 → Task 4 → Task 3

Rationale: PR title enforcement (Task 1) is the highest-value fix and a prerequisite for release-please. The PR template audit (Task 5) is trivial and immediately useful. Scope-aware CI (Task 2) and docs link audit (Task 4) are independent. Release-please evaluation (Task 3) comes last as it is explicitly **blocked by** Task 1 (release-please requires Conventional Commits to be reliably enforced) and requires the most research.

## Next Steps

- Create spec from this analysis (Gate 2 of `/bootstrap`)
- Implementation via `/scaffold` — Tier F-lite (clear scope, single domain: CI/CD)
- Tasks 1, 2, 4, 5 can be implemented in a single PR or split into per-task PRs depending on review preference
- Task 3 (release-please) produces an ADR as its deliverable — create a separate issue if the ADR recommends adoption
- When creating implementation issues, set Task 3 as `blocked-by` Task 1 to enforce the dependency
