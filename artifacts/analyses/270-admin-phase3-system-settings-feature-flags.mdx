---
title: "Admin Panel Phase 3: System Settings + Feature Flags"
description: Analysis of system settings and feature flag management for the admin panel, exploring storage shapes, caching strategies, and initial settings catalog.
---

## Context

Issue [#270](https://github.com/roxabi/roxabi_boilerplate/issues/270) — Phase 3 of the Admin Panel ([#25](https://github.com/roxabi/roxabi_boilerplate/issues/25)).

**Phase 1 (#268)** delivered: admin layout, sidebar, guards, member management, `AuditService` scaffolding.
**Phase 2 (#269)** delivered: cross-tenant user/org CRUD with cursor pagination, org hierarchy, audit log viewer with diff view.
**Blocker #314** (centralized route permission map) is **closed**.

Phase 3 adds global system configuration and boolean feature flag management, restricted to super admins.

**Parent spec:** [artifacts/specs/25-admin-panel.mdx](../specs/25-admin-panel.mdx)
**Phase 2 spec:** [artifacts/specs/269-admin-phase2.mdx](../specs/269-admin-phase2.mdx)

## Questions Explored

1. How should system settings be stored — individual DB rows vs a TypeScript config-driven registry?
2. What settings should exist at launch (initial catalog)?
3. What caching strategy should `FeatureFlagService` use, given Vercel serverless deployment?
4. How do the two new features (settings + flags) integrate with the existing admin module patterns?
5. Where should `FeatureFlagService` live so non-admin code can consume it?
6. How should the initial catalog be seeded in production (given `db:seed` refuses to run when `NODE_ENV=production`)?

## Analysis

### System Settings Storage

The core question is where the settings **schema** (metadata: type, validation, category) lives versus where the **values** live.

**Row-per-setting (DB-only):** Each setting is a row in `system_settings` with `key` (unique), `value` (jsonb), `type` (`'string' | 'number' | 'boolean' | 'select'`), `name`, `description`, `category`. Admin creates, reads, and updates settings entirely via the UI and API. No compile-time type safety for setting keys — code referencing `getSetting('app.name')` has no guarantee the setting exists.

**Config-driven registry:** A TypeScript file (e.g., `settings.registry.ts`) defines each setting's metadata — key, type, default value, validation rules (min/max, regex, allowed values), category. The DB stores only overrides (non-default values). `getSetting('app.name')` is type-safe and always resolves (to the default if no DB override). But this creates two sources of truth and prevents admins from creating new setting types without a code change.

**Value type-casting:** With row-per-setting, the `value` column is jsonb (`unknown` at runtime). The `type` column declares the expected type. `SystemSettingsService.getValue&lt;T&gt;(key)` must validate the cast at read time — callers should never unsafely cast. The service returns typed values or throws if the stored value doesn't match the declared type.

### Feature Flag Caching on Vercel Serverless

Vercel serverless functions run in ephemeral processes. Each HTTP request may spin up a fresh Node.js instance — the in-memory cache starts **empty** every time. For low-traffic admin routes, processes are rarely reused. The cache provides benefit only when:

1. Multiple flag checks occur within the **same request** (process stays alive)
2. The process is **reused** for a subsequent request within the 60s TTL window (warm start)
3. Running locally via `bun run dev` where the process is long-lived

A single DB query for flag lookup is ~1-5ms — negligible overhead. The cache is a free optimization for local dev and traditional deployments, with zero cost when it doesn't help on serverless. Zero external dependencies (no Redis/Vercel KV) keeps the stack simple — the existing project has no external cache layer, and adding one for ~8 boolean flags is not justified.

**Cache invalidation on write:** When a superadmin toggles a flag, `FeatureFlagService.setFlag()` must invalidate (delete) the cache entry for that key immediately. Without this, a subsequent flag-check within the same warm process within the 60s TTL would return the stale value. This is a correctness requirement.

**Cross-instance coherence:** On serverless, concurrent instances cannot invalidate each other's caches. A flag toggle is visible immediately on the instance that handled the write, but other instances serve stale data for up to 60s. This is acceptable because: (a) feature flags are changed by superadmins at extremely low frequency, (b) 60s is the worst-case propagation delay, (c) flag state is boolean with no complex partial states.

### Initial Settings Catalog

A minimal seed set gives immediate value: the admin panel shows settings on first visit rather than an empty page. Code can reference known settings by key. New settings are still admin-creatable at runtime.

**Seeding strategy:** The existing `db:seed` script has a `NODE_ENV=production` guard — it refuses to run in deployed environments. Therefore, the initial catalog must be seeded via a **companion migration** (`INSERT ... ON CONFLICT (key) DO NOTHING`), not `db:seed`. This is idempotent, runs automatically on every deploy via the existing `db:migrate` build step, and requires no manual intervention. The `db:seed` script can also insert the same rows for local dev consistency.

**Proposed seed set (12 settings, 4 categories):**

| Key | Type | Default | Category |
|-----|------|---------|----------|
| `app.name` | string | "Roxabi" | General |
| `app.supportEmail` | string | "" | General |
| `app.maintenanceMode` | boolean | false | General |
| `auth.signupEnabled` | boolean | true | Authentication |
| `auth.sessionTtlHours` | number | 168 | Authentication |
| `auth.maxLoginAttempts` | number | 5 | Authentication |
| `org.maxMembers` | number | 100 | Organizations |
| `org.allowSelfRegistration` | boolean | false | Organizations |
| `email.fromName` | string | "Roxabi" | Email |
| `email.fromAddress` | string | "" | Email |
| `email.footerText` | string | "" | Email |
| `security.passwordMinLength` | number | 8 | Security |

**Auth defaults rationale:** `auth.sessionTtlHours` set to 168 (7 days) — conservative for B2B SaaS. `auth.maxLoginAttempts` set to 5 — standard B2B convention. These are **informational settings** in Phase 3: displayed and editable in the admin panel but not operationally read by the auth layer. Wiring them into Better Auth's runtime config is a separate concern that requires architectural work (dynamic config reload vs restart). A follow-up issue should connect settings to application behavior; Phase 3 establishes the storage and admin UI.

### Feature Flag Key Format

Flag keys are auto-slugified from the name on creation:

- **Allowed characters:** lowercase alphanumeric + hyphens + underscores (`/^[a-z0-9][a-z0-9_-]*$/`)
- **Max length:** 100 characters
- **Immutable after creation:** keys cannot be renamed (would break code references). Name/description are editable.
- **No namespacing enforced:** keys like `billing-stripe` or `new_onboarding_flow` are both valid. Namespacing (e.g., `billing.stripe`) is a convention, not enforced by the system.

### FeatureFlagService Module Placement

`FeatureFlagService` must be consumable by non-admin application code (e.g., a billing module checking `isEnabled('stripe-checkout')`). Placing it inside `AdminModule` would create circular dependency concerns.

**Decision:** Create a dedicated `FeatureFlagsModule` at `apps/api/src/feature-flags/`. This module owns the `FeatureFlagService` (with caching + `isEnabled()`) and the Drizzle schema reference. `AdminModule` imports `FeatureFlagsModule` and adds `AdminFeatureFlagsController` for CRUD. Any other module can import `FeatureFlagsModule` to call `isEnabled()`.

`SystemSettingsService` follows the same pattern: a `SystemSettingsModule` at `apps/api/src/system-settings/` for read access, with `AdminModule` providing the admin CRUD controller.

### Global Table Classification

Both `system_settings` and `feature_flags` are **Global tables** — no `tenant_id`, no RLS, no `TenantService` interaction. This follows the same pattern as `permissions` and `roles`. The migration must NOT call `SELECT create_tenant_rls_policy(...)` for these tables. The spec must state this explicitly to prevent implementors from adding tenant columns by mistake.

### Integration with Existing Admin Module

Phase 3 follows established Phase 1-2 patterns:

- **Controllers:** `AdminSettingsController`, `AdminFeatureFlagsController` — `@Roles('superadmin')` + `@SkipOrg()`, same as Phase 2
- **Services:** Owned by shared modules (see above), consumed by admin controllers
- **Audit logging:** `AuditService.log()` in every mutation, with before/after snapshots. `resourceId` for settings uses the setting `key` (human-readable in audit viewer), not UUID. Feature flags use the row UUID.
- **Exception handling:** `AdminExceptionFilter` extended with new exception types
- **Sidebar nav:** Enable currently `disabled: true` items for "System Settings" and "Feature Flags"
- **Route guards:** Use `enforceRoutePermission` from #314 with `staticData: { permission: 'role:superadmin' }`
- **Save granularity:** Per-card save for system settings (explicit "Save" button per category card). Each card saves independently — clearer feedback, fewer accidental changes. With 2-4 settings per category, no tedium concern.
- **Typed setting validation:** `SystemSettingsService` validates the value against the declared `type` on write. Number settings reject negative values unless explicitly allowed. Boolean settings accept only `true`/`false`. String settings accept any string. Select settings validate against allowed options (stored in a `metadata` jsonb column on the setting row).

## Shapes

### Shape 1: Row-per-setting with Migration Seed

- **Description:** Each system setting is a row in `system_settings` with full metadata (key, value, type, name, description, category). Feature flags are a separate `feature_flags` table with boolean `enabled` field. Initial catalog seeded via companion migration (`INSERT ... ON CONFLICT DO NOTHING`). `FeatureFlagService` in a shared module with in-memory cache (60s TTL, write-through invalidation).
- **Trade-offs:**
  - Pro: Simple CRUD, zero config layer, admin-creatable at runtime, matches issue spec exactly
  - Pro: Follows Phase 1-2 patterns — no new architectural concepts
  - Pro: Migration seed works in all environments (dev, preview, production)
  - Con: No compile-time type safety for setting keys
  - Con: In-memory cache provides minimal benefit on Vercel serverless
- **Rough scope:** ~18 files (2 tables + 2 migrations, 2 shared modules, 2 admin controllers, 2 route pages, components, types, tests)

### Shape 2: Config-driven Registry with DB Overrides

- **Description:** A `settings.registry.ts` defines all settings with metadata and defaults. DB stores only overrides. `getSetting(key)` resolves DB override → registry default. Feature flags same as Shape 1.
- **Trade-offs:**
  - Pro: Type-safe setting access, guaranteed defaults, validation rules in code
  - Pro: Settings catalog is version-controlled
  - Con: Two sources of truth (registry file + DB)
  - Con: Admin can't create new setting types without code change
  - Con: Sync logic needed (registry → DB migration on deploy)
  - Con: More complex — adds an abstraction layer not needed for 12 settings
- **Rough scope:** ~22 files (same as Shape 1 + registry file, sync service, validation layer)

## Fit Check

| Requirement | Shape 1: Row-per-setting | Shape 2: Config-driven |
|-------------|--------------------------|------------------------|
| Admin creates settings at runtime | ✅ | ❌ |
| Follows Phase 1-2 patterns | ✅ | ❌ |
| Type-safe setting access in code | ❌ | ✅ |
| Simple implementation (&lt;18 files) | ✅ | ❌ |
| Settings catalog version-controlled | ❌ | ✅ |
| No new architectural concepts | ✅ | ❌ |
| Matches issue spec exactly | ✅ | ❌ |
| Works in all deploy environments | ✅ | ✅ |

**Selected shape:** Shape 1 (Row-per-setting) — MVP simplicity wins. Config-driven registry adds overhead not justified for ~12 settings. TypeScript overlay can be added later if the catalog grows to 50+ settings.

## Conclusions

1. **Storage:** Row-per-setting in `system_settings` table with `UNIQUE` constraint on `key`. Simple CRUD. `SystemSettingsService.getValue&lt;T&gt;()` validates type-casting at read time.
2. **Seed catalog:** 12 settings across 4 categories (General, Authentication, Organizations, Email) + 1 Security setting. Seeded via companion migration (`INSERT ... ON CONFLICT DO NOTHING`) for production compatibility. `db:seed` also inserts for local dev consistency.
3. **Caching:** In-memory Map with 60s TTL for `FeatureFlagService`, with write-through cache invalidation on mutations. Zero external dependencies — no Redis/KV needed. The existing stack has no external cache, and adding one for boolean flags is not justified.
4. **Pattern continuity:** Follows Phase 1-2 patterns — same guard strategy, audit logging, exception handling, controller/service structure.
5. **Feature flags:** Separate `feature_flags` table with `UNIQUE` constraint on `key`. Global boolean toggles only. Keys are immutable after creation, auto-slugified, validated against `/^[a-z0-9][a-z0-9_-]*$/`.
6. **Module placement:** `FeatureFlagsModule` and `SystemSettingsModule` as shared modules. `AdminModule` imports them and adds admin CRUD controllers. Non-admin code can consume `isEnabled()` and `getValue()`.
7. **Global tables:** Both tables are Global (no RLS, no tenant_id). Migration must not create tenant RLS policies.
8. **Auth settings are informational:** `auth.sessionTtlHours` and `auth.maxLoginAttempts` are displayed/editable but not operationally wired to Better Auth in Phase 3. Wiring is a follow-up.
9. **Per-card save:** System settings save independently per category card. Typed validation on write.

## Next Steps

- Create spec: `artifacts/specs/270-admin-phase3-system-settings-feature-flags.mdx`
- Define breadboard (UI affordances → code handlers → data stores)
- Define slices (vertical increments for implementation)
- No investigation spike needed — all patterns are established from Phase 1-2
