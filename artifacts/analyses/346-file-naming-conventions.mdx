---
title: "Standardize File Naming Conventions"
description: Analysis of migration strategy for enforcing PascalCase components and camelCase everything else across the monorepo
---

## Context

Issue [#346](https://github.com/MickaelV0/roxabi_boilerplate/issues/346) identifies mixed file naming conventions across the monorepo:

- `hooks/`: `use-cursor-pagination.ts` (kebab) vs `useConsent.ts` (camelCase)
- `components/`: `AuthLayout.tsx` (PascalCase) vs `ban-dialog.tsx` (kebab)
- `lib/`: `buildDiceBearUrl.ts` (camelCase) vs `format-relative-time.ts` (kebab)
- `packages/ui/src/themes/`: `presets-base.ts` (kebab)

No Biome `useFilenamingConvention` rule exists today. Enforcement is entirely manual.

**Documentation gap:** `dev-process.mdx` "Naming Conventions" section only covers branches/artifacts/specs/worktrees — no file naming rules documented.

## Questions Explored

1. What is the full scope of violations across the monorepo?
2. How should Biome's `useFilenamingConvention` be configured with per-directory overrides?
3. What is the safest migration strategy for ~148 file renames + import updates?
4. What documentation needs updating?

## Analysis

### Full Audit Results

| Workspace | Violation Count | Category |
|-----------|----------------|----------|
| `apps/web/src/components/` | 14 .tsx files | kebab-case &rarr; PascalCase |
| `apps/web/src/lib/` | 24 .ts files (incl. tests) | kebab-case &rarr; camelCase |
| `apps/web/src/hooks/` | 2 files (incl. test) | kebab-case &rarr; camelCase |
| `apps/web/src/test/` | 5 mock files | kebab-case &rarr; camelCase |
| `apps/web/src/integrations/` | 4 files (2 components + 2 tests) | kebab-case &rarr; PascalCase/camelCase |
| `apps/api/src/` | 95 .ts files | kebab-case &rarr; camelCase |
| `packages/ui/src/themes/` | 6 .ts files | kebab-case &rarr; camelCase |
| `apps/web/src/mdx-components.tsx` | 1 file | kebab-case &rarr; camelCase |
| **Total** | **~148 files** | |

### Biome Configuration

Biome's `useFilenamingConvention` supports per-directory overrides and auto-handles TanStack route conventions (`$param`, `__root`). Proposed config:

```json
{
  "linter": {
    "rules": {
      "style": {
        "useFilenamingConvention": {
          "level": "error",
          "options": { "filenameCases": ["camelCase"] }
        }
      }
    }
  },
  "overrides": [
    {
      "includes": ["**/components/**/*.tsx"],
      "linter": {
        "rules": {
          "style": {
            "useFilenamingConvention": {
              "level": "error",
              "options": { "filenameCases": ["PascalCase"] }
            }
          }
        }
      }
    },
    {
      "includes": ["**/routes/**"],
      "linter": {
        "rules": {
          "style": { "useFilenamingConvention": "off" }
        }
      }
    }
  ]
}
```

**Key details:**

- Biome only checks file names, not directory names. NestJS module directories (`api-key/`, `admin/`) are unaffected.
- **`strictCase: true` (default):** Forbids consecutive uppercase characters. No current violations exist (e.g., no `apiURL.ts`), but future files with acronyms must use `apiUrl.ts` instead. The spec should document this constraint.
- **Multi-dot NestJS files:** Biome parses `admin-users.service.ts` as name=`admin-users`, extension=`service.ts`. After rename, `adminUsers.service.ts` gives name=`adminUsers` (valid camelCase). All `.controller.ts`, `.module.ts`, `.filter.ts` suffixes are preserved.
- **Override ordering:** Biome applies later overrides with higher precedence. Routes-off (last) wins over components-PascalCase for files inside `routes/-components/`. Correct behavior.
- **Known gap:** Files in `apps/web/src/integrations/` (e.g., `root-provider.tsx`) are React components but don't match `**/components/**/*.tsx`. These rename to camelCase under the default rule. This is acceptable — they are integration wrappers, not standalone UI components. If strict PascalCase is desired for all `.tsx` default-export files, the glob must be extended.

### Import Update Scope

Every renamed file requires updating imports in **six categories:**

1. **Relative imports:** `import { X } from './old-name'`, `'../old-name'`, `'../../old-name'`
2. **`@/` alias imports:** `import { X } from '@/lib/error-utils'` &rarr; `'@/lib/errorUtils'` — used extensively across `apps/web`
3. **Re-exports:** `export * from './old-name'` in barrel `index.ts` files
4. **Test imports:** `import { X } from '../old-name'` in `.test.ts` files
5. **Dynamic imports in test mocks:** `vi.mock('@/test/__mocks__/repo-ui')` and `await import()` — found in **20+ test files** for the `repo-ui` mock alone. Not rare.
6. **Barrel files:** `index.ts` re-exports that reference renamed modules

**Safe categories (no changes needed):**
- `@repo/*` package aliases resolve to package boundaries, not individual source files. Internal renames don't affect cross-package imports.
- `routeTree.gen.ts` is auto-generated and already excluded from Biome via `files.includes`.

`git mv` preserves history. Import path replacement via `sed` with explicit pattern coverage for all six categories above, followed by a **post-rename grep audit** (`grep -rn 'old-kebab-name'`) to catch any missed references.

### Test &amp; Multi-Dot File Convention

Test files follow the convention of their source file:
- Component test: `BanDialog.test.tsx` (PascalCase, matches component)
- Utility test: `errorUtils.test.ts` (camelCase, matches util)
- Hook test: `useCursorPagination.test.tsx` (camelCase, matches hook)

Multi-dot suffixes (`.service.ts`, `.controller.ts`, `.server.ts`, `.test.ts`) are preserved. Only the base name is renamed:
- `admin-users.service.ts` &rarr; `adminUsers.service.ts`
- `api-client.server.ts` &rarr; `apiClient.server.ts`
- `admin-users.service.test.ts` &rarr; `adminUsers.service.test.ts`

### Documentation Updates Required

1. **`docs/processes/dev-process.mdx`** — Add "File Naming" subsection to existing "Naming Conventions" section (after line 388):

   | Type | Convention | Example |
   |------|-----------|---------|
   | Component `.tsx` | PascalCase | `BanDialog.tsx`, `AuthLayout.tsx` |
   | Hooks, utils, lib `.ts` | camelCase | `useConsent.ts`, `formatDate.ts` |
   | API modules `.ts` | camelCase + suffix | `adminUsers.service.ts`, `apiKey.controller.ts` |
   | Route files | TanStack conventions | `$postId.tsx`, `__root.tsx`, `index.tsx` |

2. **`docs/standards/frontend-patterns.mdx`** — Add file naming reference under component conventions
3. **`docs/standards/backend-patterns.mdx`** — Add file naming reference, note that `nest generate` CLI outputs kebab-case by default and files must be manually renamed post-scaffold (Biome error will flag violations in CI)

## Shapes

### Shape 1: Atomic Big Bang

- **Description:** One PR containing all ~148 renames, all import updates, Biome rule addition, and documentation updates. Manual `git mv` + find-and-replace per file. Clean break.
- **Trade-offs:**
  - (+) No intermediate inconsistent states
  - (+) Single review cycle, one merge conflict window
  - (+) Biome rule enforced immediately — no gap
  - (-) Very large PR (~148 files changed + import updates = 200+ files touched)
  - (-) Hard to review thoroughly — manual renames are error-prone at this scale
  - (-) High merge conflict risk if other PRs land during review
  - (-) Not reproducible — if rebase needed, must redo all manual work
- **Rough scope:** 200+ files touched, 2-3 days of manual agent work

### Shape 2: Phased by Workspace

- **Description:** 3 sequential PRs, each adding the Biome override for its scope:
  1. `apps/web` renames + Biome override (47 files)
  2. `packages/*` renames + Biome override (6 files)
  3. `apps/api` renames + Biome override (95 files) + docs + global rule consolidation
- **Trade-offs:**
  - (+) Smaller, reviewable PRs (~50-100 files each)
  - (+) Lower blast radius per merge
  - (+) API rename (highest risk) is last, after process is proven on frontend
  - (-) 3 PRs to manage, 3 review cycles
  - (-) Intermediate state: Biome config has per-workspace overrides, developers see partial enforcement (new files in unprocessed workspaces still use old convention). CI passes but convention is inconsistent.
  - (-) If another PR adds a kebab-case file to an already-processed workspace, Biome catches it. If added to an unprocessed workspace, it passes until phase 3.
- **Rough scope:** 3 PRs over 3-4 days, each ~50-100 files

### Shape 3: Script-Assisted Atomic

- **Description:** Write a Bun script that automates `git mv` + import path replacement across all six import categories, then manually add Biome rule + docs. One PR, but the mechanical work is scripted and reproducible.
- **Trade-offs:**
  - (+) Reproducible — can re-run if rebasing introduces new conflicts
  - (+) Auditable — script serves as documentation of the transformation
  - (+) One PR like Shape 1, but faster and less error-prone than manual renames
  - (+) Post-rename grep verification built into the script catches missed references
  - (+) Handles all import patterns: relative, `@/` alias, `vi.mock()`, barrel re-exports
  - (-) Script needs writing and testing first
  - (-) PR size remains large (~200+ files), but script-driven approach reduces per-file review burden — reviewers verify the *script logic* rather than each individual rename
- **Rough scope:** Script development + execution + verification + Biome config + docs = 1 PR

## Fit Check

| Requirement | Shape 1: Big Bang | Shape 2: Phased | Shape 3: Script-Assisted |
|-------------|:-:|:-:|:-:|
| No intermediate inconsistent state | ✅ | ❌ | ✅ |
| Manageable PR size | ❌ | ✅ | ❌ |
| Low merge conflict risk | ❌ | ✅ | ❌ |
| Reproducible on rebase | ❌ | ❌ | ✅ |
| Single review cycle | ✅ | ❌ | ✅ |
| Biome enforced immediately | ✅ | ❌ | ✅ |
| Minimal tooling overhead | ✅ | ✅ | ❌ |
| Low human error risk | ❌ | ❌ | ✅ |

**Selected shape:** Shape 3 (Script-Assisted Atomic) — combines the clean-break benefits of Shape 1 with reproducibility and reduced human error. The large PR size is mitigated by the fact that reviewers verify the script logic and spot-check outputs rather than auditing each rename manually. The script investment pays off given ~148 renames across six import pattern categories.

## Conclusions

1. **~148 files** need renaming across the full monorepo (14 web components, 26 web lib/hooks/tests, 95 API files, 6 UI themes, 4 integrations, 1 misc, 2 mock-related)
2. **Biome `useFilenamingConvention`** supports per-directory overrides — PascalCase for `**/components/**/*.tsx`, camelCase default, routes exempted. `strictCase: true` (default) means no consecutive uppercase in future filenames.
3. **Script-assisted atomic** approach minimizes human error and is reproducible on rebase. Script must cover six import categories including `@/` aliases and `vi.mock()` dynamic imports.
4. **Documentation** needs updating in 3 files: `dev-process.mdx` (file naming table), `frontend-patterns.mdx` (component naming), `backend-patterns.mdx` (API module naming + NestJS CLI post-scaffold note)
5. **NestJS convention note:** Standard NestJS projects often use kebab-case for organizational clarity, but this project prioritizes monorepo-wide consistency with export naming conventions (e.g., `useConsent` function lives in `useConsent.ts`). The `nest generate` CLI outputs kebab-case by default — developers must rename post-scaffold, and the Biome error rule catches violations in CI.
6. **Post-rename verification:** Script includes a grep audit step to confirm zero remaining kebab-case references to renamed files.

## Next Steps

- Promote to spec with detailed rename inventory, script design, and complete Biome config
- Script design: `sed`-based replacement with explicit patterns for all six import categories, plus post-rename `grep` verification. AST-based approach is not needed at this scale — string replacement is reliable for import paths.
- Test files follow their source convention: component tests use PascalCase, utility tests use camelCase. Multi-dot suffixes (`.service.ts`, `.server.ts`, `.test.ts`) are preserved — only the base name is renamed.
