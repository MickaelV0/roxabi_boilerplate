---
title: "License Checker — Dependency License Compliance"
description: Analysis of approaches for scanning all monorepo dependencies (direct and transitive) and enforcing license compliance
---

## Context

The Roxabi Boilerplate is a SaaS framework with plans for open-source distribution and enterprise adoption. As the dependency tree grows across the monorepo (web, api, shared packages), there is no visibility into what licenses are being pulled in — directly or transitively.

This is driven by four converging needs:

1. **Legal compliance** — ensure shipped software doesn't include dependencies with incompatible licenses
2. **Open-source planning** — verify all transitive dependencies are compatible before publishing
3. **Preventive hygiene** — catch problematic licenses early, before they become deeply embedded
4. **Enterprise requirements** — enterprise clients often require license audits as part of procurement

No tooling or process exists today. License awareness is zero.

## Questions Explored

1. How can we scan the full transitive dependency tree in a Bun monorepo?
2. What existing tools are available, and should we use one vs. build our own?
3. What output format and policy enforcement model best fits the project?
4. How should unknown or missing licenses be handled?
5. What does CI integration look like?

## Analysis

### Scanning the Dependency Tree

Bun uses `bun.lock` (v2 text-based format) as its lockfile. This file contains the full resolved dependency tree, including transitive dependencies. The lockfile lists every package with its resolved version and integrity hash.

To extract license information, two approaches exist:

- **Parse `bun.lock`** to get the flat list of all resolved packages, then read each package's `package.json` from `node_modules` for the `license` field
- **Walk `node_modules`** directly, reading every `package.json` to collect `license` and `licenses` fields

The `node_modules` walk is more reliable because:
- It handles packages that use the deprecated `licenses` array field
- It can read `LICENSE` / `LICENCE` files as fallback when the `license` field is missing
- It works regardless of lockfile format changes

For a monorepo, the walk should cover the root `node_modules` (hoisted dependencies) plus any workspace-specific `node_modules` directories.

### Existing Tools vs. Custom Script

| Tool | Pros | Cons |
|------|------|------|
| `license-checker` (npm) | Mature, widely used, JSON output | Node-only, no Bun-native support, last meaningful update 2023 |
| `license-report` (npm) | Good output formats, configurable | Heavy, pulls in many deps itself |
| `legally` (npm) | Simple, scans node_modules | Limited output format, no policy enforcement |
| Custom Bun script | Full control, no extra deps, Bun-native, fits monorepo structure | Must build and maintain |

**Recommendation: Custom standalone script.** Rationale:

- Existing tools add dependencies of their own (ironic for a license checker)
- None natively understand Bun workspaces
- The core logic is straightforward: walk `node_modules`, read `package.json`, extract license, compare against allowlist
- A custom script can be tailored to the monorepo's TurboRepo structure and run as a Turbo task

### Output Format

Two complementary outputs:

1. **CLI table** (stdout) — human-readable summary showing package name, version, license, and compliance status. Useful for local dev and CI logs.
2. **JSON report** (file) — machine-readable full report with the complete dependency tree, license data, and policy violations. Useful for downstream tooling, dashboards, or audit records.

The script exits with code 0 if no violations, non-zero if policy violations are found (for CI gating).

### Policy Model

An **allowlist-based** approach:

- A configuration file (e.g., `license-policy.json` or a field in `package.json`) defines the list of permitted licenses (SPDX identifiers): `MIT`, `ISC`, `Apache-2.0`, `BSD-2-Clause`, `BSD-3-Clause`, etc.
- Any dependency whose license is NOT in the allowlist is flagged as a violation
- The allowlist is the single source of truth — simple to understand, audit, and maintain

### Handling Unknowns

Dependencies with missing or unrecognizable license fields are treated as **warnings**, not failures:

- They appear in the report with a `⚠ UNKNOWN` status
- The CLI exit code is NOT affected (still exits 0 unless there are actual violations)
- This avoids false-positive build failures while still surfacing packages that need manual review
- A future enhancement could add an `overrides` section in the policy file for manual license assignments

### Monorepo Scope

A **unified report** across all workspace packages:

- Deduplicate dependencies (same package@version appears once regardless of how many workspaces use it)
- The report covers the entire deployed surface area
- Simpler than per-package reports, and since all packages ship together, per-package granularity adds complexity without value

### CI Integration (Future)

The script will be designed for CI from day one, but CI integration is deferred until the team finalizes the target license whitelist:

1. Script runs as a Turbo task: `turbo run license:check`
2. In CI, the task runs as part of the validation pipeline (alongside lint, typecheck, test)
3. Exit code gates the pipeline: non-zero blocks merge
4. JSON report can be uploaded as a CI artifact for audit trail

## Conclusions

1. **Build a custom Bun/TypeScript script** that walks `node_modules` across all workspace packages
2. **Output a CLI table + JSON report** with per-dependency license info and compliance status
3. **Use an allowlist policy** defined in a config file at the repo root
4. **Warn on unknowns** — don't fail the build for missing license data
5. **Produce a unified, deduplicated report** across the entire monorepo
6. **Defer CI integration** until the target license whitelist is defined

## Next Steps

- Create a GitHub issue for implementation
- Write a spec with detailed technical design (script structure, config schema, output format)
- Implement as a Turbo task in the monorepo tooling
- Define the initial license allowlist with the team
- Add CI pipeline integration once the allowlist is finalized
