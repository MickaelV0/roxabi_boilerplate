---
title: "CLI for AI Agents: Strategic Analysis"
description: Technical analysis for Roxabi Boilerplate infrastructure
---

> **Deprecated**: This document is outdated and kept for historical reference only. Please refer to the main documentation sections for current information.


## Context

The Roxabi boilerplate aims to provide a comprehensive SaaS framework with an integrated AI team. Currently, the documentation and architecture do not mention the possibility of offering a CLI on top of the APIs to allow AI agents to interact with the services.

This analysis explores the relevance, benefits, and implications of adding this capability as a **core feature** of the boilerplate.

## Questions Explored

1. Why a CLI rather than an MCP server or SDK?
2. How to enable API discovery for AI agents?
3. What authentication strategy?
4. Should it be generic (generator) or specific to the boilerplate?
5. What risks and tradeoffs?

## Analysis

### Why a CLI for AI Agents?

#### The Current Problem

AI agents (Claude Code, Cursor, Copilot, etc.) interact with APIs in three ways:
1. **Directly via HTTP**: requires the AI to know the exact endpoint structure, handle auth, and parse responses
2. **Via MCP servers**: powerful but limited to tools that support MCP
3. **Via CLI**: universal, any agent capable of running bash can use it

#### The CLI Advantage

A well-designed CLI solves three major problems:

| Problem | CLI Solution |
|---------|--------------|
| **Discovery** | `cli --help` lists all available actions with descriptions |
| **Authentication** | Handled once, stored, and reused automatically |
| **Intent to API mapping** | Semantic commands (`user create`) vs technical endpoints (`POST /api/v1/users`) |

#### Why Not MCP?

MCP is an excellent technology, but a CLI offers:
- **Universality**: works with any AI agent capable of running bash
- **Dual usage**: human developers use it too (testing, debugging, scripts)
- **Development simplicity**: no protocol to implement
- **Easy inspection**: you can see exactly what is being executed

### Inspiration: GitHub CLI (gh)

`gh` is the reference model for a modern CLI oriented toward developers and AI:

```bash
# Human-friendly by default
gh pr list
# → displays a formatted table with colors

# JSON for AI and scripts
gh pr list --json number,title,author
# → [{"number": 42, "title": "...", "author": {...}}]

# Filtering with built-in jq
gh pr list --json number,title -q '.[0].title'
# → "My first PR"
```

**Key characteristics:**
- Adaptive output (TTY detection)
- `--json` flag with field selection
- Hierarchical commands (`gh repo clone`, `gh pr create`)
- Persistent auth (`gh auth login`)
- Shell autocompletion

### Proposed Architecture

#### Generation from OpenAPI

The boilerplate's NestJS API does not yet have OpenAPI/Swagger documentation. The recommended strategy:

```
┌─────────────────┐     ┌──────────────────┐     ┌─────────────┐
│  NestJS API     │ --> │  OpenAPI Spec    │ --> │  CLI        │
│  + decorators   │     │  (auto-generated)│     │  (generated)│
└─────────────────┘     └──────────────────┘     └─────────────┘
```

**Hybrid approach (build-time + runtime validation):**

1. **Build-time**: generates typed TypeScript command code
   - Strong types, autocompletion, compile-time errors
   - Integrated into the existing build pipeline

2. **Runtime (optional)**: compatibility validation
   - Verifies that the CLI matches the API version
   - Warns if endpoints have changed

**Recommended tools:**
- `@nestjs/swagger` to generate the OpenAPI spec from controllers
- `openapi-typescript` or `orval` to generate types
- `commander` or `oclif` for the CLI framework

### Multi-Mode Authentication

To support both humans and AI agents:

| Mode | Use case | Implementation |
|------|----------|----------------|
| Environment variables | CI/CD, AI agents | `ROXABI_API_KEY`, `ROXABI_TOKEN` |
| Config file | Local development | `~/.roxabi/config.json` |
| Interactive login | Initial setup | `cli auth login` (OAuth flow) |

**Priority order**: env vars > config file > interactive prompt

### Scope: Generator + Template

The CLI must serve two objectives:

1. **Built-in template**: the boilerplate includes a pre-configured CLI
   - Users have a working CLI out of the box
   - Customizable to their needs

2. **Reusable generator**: the generation tool is exposed
   - Can be used on other NestJS projects
   - Becomes a differentiator for the boilerplate

### AI Agent Use Cases

#### Automation
```bash
# The AI agent can execute repetitive tasks
roxabi users list --json | jq '.[] | select(.status == "pending")'
roxabi users bulk-activate --ids 1,2,3
```

#### Development
```bash
# Testing an endpoint during development
roxabi api call POST /users --data '{"name": "test"}'

# Debugging an error
roxabi logs --service api --level error --last 100
```

#### Integration
```bash
# The agent builds workflows
roxabi webhooks create --url "https://..." --events user.created
roxabi integrations list --json
```

### Identified Risks and Mitigations

#### 1. API to CLI Synchronization

**Risk**: the CLI becomes outdated if the API evolves without regeneration

**Mitigations**:
- Integrate generation into the CI/CD pipeline
- Optional runtime validation that warns about incompatibilities
- Semantic versioning tied to the API version

#### 2. AI Agent Security

**Risk**: an AI agent could execute destructive commands

**Mitigations**:
- Granular permissions on API keys
- `--dry-run` flag on destructive commands
- Confirmation required for critical actions (unless `--yes`)
- Logging of all actions for audit

#### 3. Added Complexity to the Boilerplate

**Risk**: increases the maintenance surface

**Mitigations**:
- Automatic generation = minimal manual code
- Tests automatically generated from the spec
- Documentation automatically generated from the spec

### Alternatives Comparison

| Approach | Universality | DX | Dev Effort | Maintenance |
|----------|--------------|-----|------------|-------------|
| Generated CLI | Excellent | Excellent | Medium | Low (auto) |
| MCP Server | Limited | Good | Medium | Medium |
| TypeScript SDK | Good | Excellent | High | High |
| Nothing (direct HTTP) | Excellent | Low | None | None |

## Conclusions

### Key Takeaways

1. **A CLI generated from OpenAPI is the optimal solution** for the Roxabi boilerplate, offering universality, good DX, and automated maintenance.

2. **The gh (GitHub CLI) model is the reference** to follow: adaptive output, `--json` flag, hierarchical commands, persistent auth.

3. **The hybrid approach (build-time + runtime validation)** offers the best tradeoff between strong typing and flexibility.

4. **It is a differentiator**: few SaaS boilerplates offer an AI-ready CLI out-of-the-box.

5. **The risks are manageable** through automatic generation, runtime validation, and security best practices.

### Prerequisites

Before implementing the CLI, the following is needed:
1. Add `@nestjs/swagger` to the API and document the endpoints
2. Choose a CLI framework (commander, oclif, or custom)
3. Choose an OpenAPI to TypeScript generator

### Impact on the Roxabi Vision

This feature aligns perfectly with the "integrated AI team" vision:
- AI agents can interact with the API autonomously
- Human developers benefit from the same tools
- The boilerplate becomes "AI-native" and not just "AI-compatible"

## Next Steps

1. Create a detailed spec for the CLI implementation
2. Evaluate CLI frameworks (commander vs oclif vs custom)
3. Prototype generation from a simple OpenAPI spec
4. Define the command structure (naming conventions)
5. Integrate into the existing build pipeline
