---
title: Agent Teams
description: Getting started with multi-agent coordination using Claude Code Agent Teams
---

Run specialized AI agents in parallel to implement features faster. Each agent has a dedicated role, domain, and tool access.

## Prerequisites

- Claude Code CLI installed
- Agent Teams enabled (experimental):

```bash
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
```

Add this to your shell profile (`.bashrc`, `.zshrc`) to persist across sessions.

## How It Works

### Subagents (`.claude/agents/`)

Each `.md` file in `.claude/agents/` defines a **subagent** — a pre-defined role with specific tools, permissions, and domain boundaries. Claude Code auto-discovers these files and makes them available as specialized workers within a single session via the `Task` tool.

Subagents are **stable** and work without any experimental flags.

### Agent Teams (experimental swarm)

Agent Teams go further: multiple independent Claude Code sessions coordinate in parallel via a shared task list and mailbox. Each teammate runs as a separate process with its own context window.

Agent Teams require the experimental flag:

```bash
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1
```

### How they connect

The `.md` files in `.claude/agents/` serve **both** purposes:
- **Single session**: The lead uses `Task` tool to delegate work to a subagent by referencing its definition
- **Agent Teams**: Team members reference the same `.md` files as their `agentType`, getting the same role, tools, and permissions

---

## Quick Start

### 1. Determine your tier

Before spawning agents, check the [Development Process](../processes/dev-process) to classify your task:

| Tier | Criteria | Agent Mode |
|------|----------|------------|
| **S** | &lt;=3 files, no arch risk | Single session + optional tester subagent |
| **F-lite** | Clear scope, documented requirements, single domain | Worktree + agents + /review (skip bootstrap) |
| **F-full** | New arch concepts, unclear requirements, or >2 domain boundaries | Bootstrap + worktree + agents + /review |

F-lite vs F-full is **judgment-based**, not file-count-based. Human always validates.

### 2. Pick your agents

Use the routing decision tree:

```
Is this a code change?
├── No (docs only) → doc-writer subagent
└── Yes
    ├── Tier S (<=3 files, no arch risk)
    │   └── Single session + optional tester subagent
    │
    ├── Tier F-lite (clear scope, documented requirements)
    │   ├── /scaffold (spec → PR, skip bootstrap):
    │   │   ├── Single-domain → subagents (Task tool)
    │   │   └── Multi-domain  → Agent Teams (TeamCreate)
    │   │   ├── Frontend? → frontend-dev + tester
    │   │   ├── Backend?  → backend-dev + tester
    │   │   ├── Full-stack? → frontend-dev + backend-dev + tester
    │   │   └── Security-sensitive? → + security-auditor
    │   └── Then /review (spawns fresh domain reviewers + 1b1 + fixer)
    │
    └── Tier F-full (new arch, unclear requirements, >2 domains)
        ├── /bootstrap (idea → spec): product-lead + architect + doc-writer
        ├── /scaffold (spec → PR):
        │   ├── Single-domain → subagents (Task tool)
        │   └── Multi-domain  → Agent Teams (TeamCreate)
        │   ├── Frontend? → frontend-dev + tester
        │   ├── Backend?  → backend-dev + tester
        │   ├── Full-stack? → frontend-dev + backend-dev + tester
        │   ├── Large scope? → + architect + doc-writer
        │   └── Security-sensitive? → + security-auditor
        └── Then /review (spawns fresh domain reviewers + 1b1 + fixer)
```

### 3. Start a session

**Single session (subagents via Task tool):**

```bash
# Start Claude Code — subagents are auto-discovered from .claude/agents/
claude

# Ask Claude to delegate to a subagent
> "Use the frontend-dev agent to implement the UserProfile component"
```

Claude uses the `Task` tool internally to spawn the subagent with the role's tools and permissions.

**Run as a specific agent (`--agent`):**

```bash
# Start Claude Code as a pre-defined agent
claude --agent backend-dev
```

The `--agent` flag loads an agent definition from `.claude/agents/<name>.md` (or `~/.claude/agents/`) and applies it to the **main conversation** — not as a subagent. The session uses the agent's system prompt, tools, permissions, and model. Useful for dedicated single-domain work sessions.

**Define ephemeral agents inline (`--agents`):**

```bash
# Pass agent definitions as JSON for a single session (not saved to disk)
claude --agents '{
  "quick-reviewer": {
    "description": "Quick code reviewer",
    "prompt": "You are a senior code reviewer. Focus on correctness and security.",
    "tools": ["Read", "Grep", "Glob"],
    "model": "sonnet"
  }
}'
```

The `--agents` (plural) flag accepts JSON with the same fields as agent `.md` frontmatter: `description`, `prompt`, `tools`, `disallowedTools`, `model`, `permissionMode`, `maxTurns`, `skills`, `hooks`, and `memory`. These agents exist only for the current session.

**Agent Teams (experimental — multiple independent sessions):**

```bash
# Enable agent teams
export CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1

# Start Claude Code as the lead
claude

# Spawn teammates as independent sessions
/teammates add frontend-dev backend-dev tester
```

### 4. Create tasks and assign

As the lead, you create tasks and set dependencies:

```
Create a task list for implementing the user profile page:
1. "Implement GET /api/users/:id endpoint" → assign to backend-dev
2. "Create UserProfile component" → assign to frontend-dev, blocked by task 1
3. "Write tests for user profile" → assign to tester, blocked by tasks 1 and 2
4. Create PR, then run /review
```

Agents will claim tasks matching their domain and execute within their boundaries.

### 5. Review and merge

Once all tasks are complete, review the deliverables and create the PR.

---

## Available Agents

### Domain Agents (code writers)

| Agent | Color | Domain | Standards |
|-------|-------|--------|-----------|
| **frontend-dev** | cyan | `apps/web/`, `packages/ui/` | [Frontend Patterns](../standards/frontend-patterns) |
| **backend-dev** | green | `apps/api/`, `packages/types/` | [Backend Patterns](../standards/backend-patterns) |
| **infra-ops** | yellow | `packages/config/`, root configs | [Configuration](../../configuration) |

### Quality Agents (verification and fixing)

| Agent | Color | Role | Standards |
|-------|-------|------|-----------|
| **fixer** | magenta | Fullstack quick fixer — applies accepted review comments. Spawned in parallel (one per domain) when fixes span multiple domains. | [Code Review](../standards/code-review) |
| **tester** | blue | Test generation &amp; validation | [Testing](../standards/testing) |
| **security-auditor** | red | Vulnerability detection | OWASP Top 10 |

### Strategy Agents (planning &amp; alignment)

| Agent | Color | Role | Standards |
|-------|-------|------|-----------|
| **architect** | white | System design, tier classification | [Architecture](../architecture/) |
| **product-lead** | purple | Product ownership, requirements, triage | [Issue Management](../processes/issue-management) |
| **doc-writer** | gray | Documentation maintenance | [Contributing](../../contributing) |

---

## Agent Configuration

Each agent's `.md` file contains YAML frontmatter that controls its behavior:

### `permissionMode`

Controls what the agent can do without user approval.

| Mode | Meaning | Used by |
|------|---------|---------|
| `bypassPermissions` | Agent can execute all its tools freely — appropriate for agents that write code or fix issues | frontend-dev, backend-dev, infra-ops, tester, doc-writer, product-lead, architect, fixer |
| `plan` | Agent can only read and analyze — it proposes changes but cannot execute them | security-auditor |

### `maxTurns`

Maximum number of agentic turns (API round-trips) before the agent stops. Prevents runaway token usage.

| Value | Used by |
|-------|---------|
| `50` | Domain agents, tester, and fixer (may need many iterations) |
| `30` | Security-auditor, doc-writer |
| `20` | Architect (analysis-focused) |
| none | Product-lead (unbounded — owns the full pipeline) |

### `memory: project`

All agents use `memory: project`, which enables persistent learnings stored in `.claude/agent-memory/`. Agents accumulate knowledge about the codebase across sessions.

### `skills`

Each agent has a core skill preloaded, matching its primary function:

| Agent | Skill | Purpose |
|-------|-------|---------|
| frontend-dev, backend-dev, infra-ops | `commit`, `context7` | Conventional Commits + library docs |
| doc-writer | `commit`, `context7` | Conventional Commits + library docs |
| fixer | `commit`, `context7` | Fix accepted review comments + commit |
| tester | `test`, `context7` | Test generation + library docs |
| architect | `adr`, `commit`, `context7` | ADRs, commits, library docs |
| product-lead | `interview`, `issue-triage`, `issues`, `adr`, `commit`, `pr`, `scaffold`, `agent-browser`, `context7`, `1b1`, `bootstrap` | Full product ownership toolkit |
| security-auditor | — | No skill (pure analysis) |

### `disallowedTools`

Defense-in-depth: even if an agent's `tools` list doesn't include certain tools, `disallowedTools` provides an explicit deny list as an extra safety layer:

| Agent | Disallowed |
|-------|------------|
| security-auditor | Write, Edit |

---

## Review Model

Review is performed by **fresh agent instances** — not the agents that wrote the code. This prevents bias and ensures independent verification.

### How it works

1. After a PR is created, Main Claude runs `/review`
2. The review skill spawns fresh review agents via the `Task` tool:

   | Always spawned | Conditionally spawned |
   |----------------|----------------------|
   | security-auditor | frontend-dev (if FE files changed) |
   | architect | backend-dev (if BE files changed) |
   | product-lead | infra-ops (if config files changed) |
   | tester | |

3. Each agent reviews the diff from its area of expertise, producing Conventional Comments
4. Main Claude merges findings, deduplicates, and walks the human through each one via `/1b1`
5. Human accepts, rejects, or defers each finding
6. Accepted findings are split by domain and sent to **parallel fixer agents** — one per affected domain (backend, frontend, infra). Single-domain fixes use one fixer.
7. Fixers run in parallel, then the lead commits, pushes, and CI runs

### Why fresh agents?

- No agent reviews code it wrote (eliminates confirmation bias)
- Each reviewer is scoped to what it knows best (security-auditor focuses on OWASP, architect on design patterns, etc.)
- The old single "reviewer" agent tried to cover all domains — splitting review from fixing gives better separation of concerns

### Fixer vs old reviewer

The **fixer** agent replaces the old reviewer agent. Key differences:

| Old reviewer | New fixer |
|--------------|-----------|
| Reviewed AND fixed AND verified CI | Only fixes accepted review comments |
| Single agent covering all domains | Fullstack — fixes across FE + BE + tests + config |
| Reviewed its own work | Never reviews — fresh agents handle review |
| Spawned automatically by /review | Spawned after human validates findings via /1b1 |

### Parallel Fixers

When accepted findings span **2+ domains** (e.g., backend + frontend + config), the lead spawns **one fixer per domain in parallel** instead of a single sequential fixer. This cuts fix time proportionally.

| Domain | Fixer scope | Files |
|--------|-------------|-------|
| **Backend** | `apps/api/`, `packages/types/` | Backend source + tests |
| **Frontend** | `apps/web/`, `packages/ui/` | Frontend source + tests |
| **Infra** | `packages/config/`, root configs, CI | Config + infrastructure |

Each parallel fixer:
- Receives only its domain's accepted findings
- Edits only files within its scope
- Does **not** commit — the lead combines all fixes into a single commit after all fixers complete
- Reports what was fixed and any issues

Single-domain fixes still use one fixer that commits and pushes directly.

---

## Playbooks

### Playbook 1: Frontend Feature (F-lite)

**Scenario:** Add a new page with components, no API changes. Clear requirements.

```bash
# Phase 2 — Create worktree and spawn agents
git worktree add ../roxabi-XXX -b feat/XXX-slug staging
cd ../roxabi-XXX && bun install

claude
/teammates add frontend-dev tester
```

**Task flow (test-first):**

```
[tester: Write failing tests from spec (RED)]
        |
[frontend-dev: Implement to pass tests (GREEN)]
        |
[frontend-dev: Refactor (REFACTOR)]
        |
[tester: Verify coverage + edge cases]
        |
Commit & PR
        |
/review (spawns fresh reviewers)
        |
/1b1 (human walks through findings)
        |
[fixer: Fix accepted comments]
        |
Merge
```

**As the lead, you:**
1. Confirm spec exists (Phase 1 — assessment)
2. tester writes failing tests from the spec
3. frontend-dev implements to pass the tests
4. Create the PR
5. Run `/review` — fresh agents review the code
6. Walk through findings with `/1b1` — accept, reject, or defer each
7. fixer applies accepted fixes
8. Approve merge once CI is green

### Playbook 2: Full-Stack Feature (F-lite)

**Scenario:** New API endpoint + frontend page that consumes it. Requirements documented.

```bash
/teammates add frontend-dev backend-dev tester
```

**Task flow (test-first):**

```
[tester: Write failing API + UI tests (RED)]
        |
[backend-dev: Implement API endpoint + types (GREEN)]
        |
[frontend-dev: Implement UI consuming the API (GREEN)]
        |
[tester: Verify coverage + edge cases]
        |
Commit & PR
        |
/review (spawns fresh reviewers)
        |
/1b1 (human walks through findings)
        |
[fixer: Fix accepted comments]
        |
Merge
```

**As the lead, you:**
1. Confirm spec exists (Phase 1)
2. tester writes failing tests for both API and UI
3. backend-dev implements the endpoint and shared types to pass API tests
4. frontend-dev implements the UI to pass UI tests
5. Create the PR
6. Run `/review` — fresh agents review
7. Walk through findings via `/1b1`
8. fixer applies accepted fixes
9. Approve merge once CI is green

### Playbook 3: Bug Fix with Regression Test

**Scenario:** Backend bug that needs a fix and regression test.

```bash
/teammates add backend-dev tester
```

**Task flow (test-first):**

```
[tester: Write failing regression test that reproduces the bug (RED)]
        |
[backend-dev: Fix the bug to pass the test (GREEN)]
        |
Commit & PR
        |
/review (spawns fresh reviewers)
        |
/1b1 (human walks through findings)
        |
[fixer: Fix accepted comments]
        |
Merge
```

**As the lead, you:**
1. Describe the bug with reproduction steps
2. tester writes a regression test that reproduces the bug
3. backend-dev fixes the bug to pass the test
4. Create the PR
5. Run `/review`, walk through findings via `/1b1`
6. fixer applies accepted fixes
7. Approve merge once CI is green

### Playbook 4: Large Feature (F-full with Bootstrap)

**Scenario:** Major feature spanning frontend, backend, and infrastructure. New arch concepts or unclear requirements.

**Phase 1 — Assessment (bootstrap):**

```bash
/bootstrap
# Spawns: product-lead, architect, doc-writer
# Product-lead interacts with human to write analysis + spec
# Architect provides technical analysis if needed
# Human approves spec before proceeding
```

**Phase 2 — Implementation (test-first):**

```bash
/teammates add architect frontend-dev backend-dev infra-ops tester doc-writer
# Add security-auditor if security-sensitive
```

**Task flow:**

```
[architect: Design + break into tasks]
        |
[tester: Write failing tests from spec (RED)]
        |
   +----+--------+
[front] [back] [infra]     <- parallel implementation (GREEN)
   +----+--------+
        |
[tester: Verify coverage + edge cases]
        |
[doc-writer: Update docs]
        |
Commit & PR
```

**Phase 3 — Review:**

```
/review (spawns fresh domain reviewers)
        |
/1b1 (human walks through all findings)
```

**Phase 4 — Fix and Merge:**

```
[parallel fixers by domain]
   +--------+--------+
[BE fixer] [FE fixer] [Infra fixer]   ← parallel (one per affected domain)
   +--------+--------+
        |
Combined commit & push
        |
CI runs (loop until green)
        |
Human approves merge
```

**As the lead, you:**
1. Run `/bootstrap` — product-lead gathers requirements, architect designs, doc-writer drafts spec
2. Human approves the spec
3. tester writes failing tests from spec
4. Domain agents implement in parallel (each in their own packages) to pass tests
5. doc-writer updates documentation
6. Create the PR
7. Run `/review` — fresh agents review from each domain
8. Walk through all findings via `/1b1`
9. fixer applies accepted fixes
10. Approve merge once CI is green

---

## Coordination Rules

All agents follow these rules (baked into their system prompts):

1. **Stay in your domain** — Never modify files outside your assigned packages
2. **Claim, don't grab** — Pick tasks from the shared task list, don't create your own
3. **Report blockers** — If stuck, message the lead with a clear description
4. **Hand off properly** — When done, mark your task complete and create tasks for the next agent
5. **Escalate cross-domain needs** — If you need changes in another domain, create a task for that agent

## Plugins

Claude Code plugins are enabled in `.claude/settings.json` and extend agent capabilities:

| Plugin | Purpose | Benefits |
|--------|---------|----------|
| `vercel@claude-plugins-official` | Vercel deployment management | All agents can check deployments |
| `frontend-design@claude-plugins-official` | Design guardrails for UI development | Helps frontend-dev avoid AI-generated design slop |

### Built-in Tools

`AskUserQuestion` is a built-in tool always available to all agents, regardless of the `tools:` field in their definition. It does not need to be listed explicitly.

---

## Model Tiering (Future)

Recommended model-per-role mapping for cost optimization. **Not applied yet** — all agents currently use `model: inherit`.

| Tier | Model | Agents | Rationale |
|------|-------|--------|-----------|
| **Heavy** | Opus | product-lead, architect | Complex analysis, planning, product decisions |
| **Standard** | Sonnet | frontend-dev, backend-dev, infra-ops, tester, doc-writer | Implementation, testing, documentation |
| **Standard** | Sonnet | fixer | Cross-stack fixes on identified issues |
| **Light** | Haiku | security-auditor | Read-only analysis, checklist verification |

This tiering will be applied when cost optimization becomes a priority. For now, all agents inherit the parent session's model.

---

## Troubleshooting

| Problem | Solution |
|---------|----------|
| Agent modifies wrong files | Check its `.claude/agents/*.md` boundaries section. Remind it of its domain. |
| Agent doesn't claim tasks | Make sure the task description matches the agent's domain keywords. |
| Context window exhausted | Restart the agent. The task list persists across sessions. |
| Agent teams feature not working | Verify `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1` is set. Check Claude Code version. |
| Two agents conflict on a file | Add a `blockedBy` dependency to serialize access. |
| Too expensive for small tasks | Use subagents (Task tool) for Tier S. Reserve full Agent Teams for Tier F multi-domain. |

## Fallback: Single Agent Mode

If agent teams are unstable or unavailable, the agent `.md` files still work as reference documents. You can:

1. Use a single Claude Code session
2. Read the relevant agent's `.md` file for domain context
3. Follow the same boundaries and standards manually

The agent definitions are designed to be useful both as agent team prompts and as human reference guides.
