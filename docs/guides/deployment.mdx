---
title: Deployment
description: Deploy Roxabi on Vercel — both web and API on one platform
---

## Overview

Roxabi uses a **staging-based** deployment architecture with **Vercel** as the single platform for both the web app and API.

```
Feature branch → PR to staging → CI runs
                                → (optional) Deploy Preview via GitHub Actions
staging → PR to main → CI runs → Vercel auto-deploys to production
```

| Component | Platform | Details |
|-----------|----------|---------|
| Web (TanStack Start + Nitro) | Vercel | SSR, edge caching, Fluid compute |
| API (NestJS + Fastify) | Vercel | Zero-config NestJS, Fluid compute, auto-scaling |
| Database | Neon | Serverless PostgreSQL, not managed by Vercel |

No Docker is needed for deployment. Docker configurations (Dockerfiles, `docker-compose.prod.yml`, Nginx configs, `deploy/`) remain in the repo for local development only.

---

## Branch Strategy

| Flow | Branch path | Deploys? |
|------|-------------|----------|
| **Normal** | `feat/*` → PR to `staging` → PR to `main` | Only `main` merges auto-deploy |
| **Hotfix** | `hotfix/*` → PR to `main` | Auto-deploys immediately |

- `staging` is the default integration branch — all feature PRs target it
- Automatic preview deployments are **disabled** at the Vercel project level — pushes to non-`main` branches do not trigger any Vercel build
- Use the **Deploy Preview** GitHub Action or Vercel CLI for on-demand preview URLs
- Only merges to `main` trigger production auto-deploys

---

## Preview Deploys

Preview deploys are **manual only**, triggered via the GitHub Actions tab.

### How to trigger

1. Go to **Actions** → **Deploy Preview**
2. Click **Run workflow**
3. Select the branch (typically `staging`)
4. Choose a target: `web`, `api`, or `both`
5. Click **Run workflow**

The workflow builds and deploys a Vercel preview. The preview URL appears in the **workflow run summary**.

### When to use

- Before promoting `staging` → `main`, to verify the integration build
- To share a preview URL with stakeholders for review
- To smoke-test a specific branch without deploying to production

---

## GitHub Actions Secrets

The **Deploy Preview** workflow requires these repository secrets:

| Secret | Description | Where to find |
|--------|-------------|---------------|
| `VERCEL_TOKEN` | Vercel personal access token | [vercel.com/account/tokens](https://vercel.com/account/tokens) |
| `VERCEL_ORG_ID` | Vercel team/org ID | `.vercel/project.json` → `orgId` (after `vercel link`) |
| `VERCEL_PROJECT_ID_WEB` | Vercel project ID for web | `apps/web/.vercel/project.json` → `projectId` |
| `VERCEL_PROJECT_ID_API` | Vercel project ID for API | `apps/api/.vercel/project.json` → `projectId` |
| `NEON_API_KEY` | Neon API key (for preview DB branches) | [console.neon.tech](https://console.neon.tech) → Account → API Keys |
| `NEON_PROJECT_ID` | Neon project ID | [console.neon.tech](https://console.neon.tech) → Project Settings |

Add them at **Settings** → **Secrets and variables** → **Actions** → **New repository secret**.

---

## Prerequisites

Install the Vercel CLI globally:

```bash
bun add -g vercel
```

Authenticate:

```bash
vercel login
```

---

## Initial Setup

You need **two Vercel projects** pointing to the same GitHub repository — one for the web app and one for the API.

### 1. Create Projects

Create both projects from the Vercel dashboard (one-time setup):

1. Sign up at [vercel.com](https://vercel.com) and connect your GitHub account
2. Click **Add New Project**, import the repository, set Root Directory to `apps/web`
3. Repeat for `apps/api`

Build settings are version-controlled in `apps/web/vercel.json` and `apps/api/vercel.json` — no manual configuration needed.

### 2. Link Projects Locally

Link each app directory to its Vercel project:

```bash
cd apps/web && vercel link
cd apps/api && vercel link
```

Select the matching project when prompted. This creates `.vercel/project.json` in each directory (gitignored).

### 3. Disable Automatic Preview Deployments

Disable Vercel's automatic preview deployments to prevent rate-limit exhaustion from canceled builds on non-production branches:

```bash
# Get your team ID and project IDs from .vercel/project.json after linking
TEAM_ID="<your-team-id>"
TOKEN="<your-vercel-token>"

# Disable for web project
curl -X PATCH -H "Authorization: Bearer $TOKEN" \
  "https://api.vercel.com/v9/projects/<web-project-id>?teamId=$TEAM_ID" \
  -H "Content-Type: application/json" \
  -d '{"previewDeploymentsDisabled":true}'

# Disable for API project
curl -X PATCH -H "Authorization: Bearer $TOKEN" \
  "https://api.vercel.com/v9/projects/<api-project-id>?teamId=$TEAM_ID" \
  -H "Content-Type: application/json" \
  -d '{"previewDeploymentsDisabled":true}'
```

Verify the setting:

```bash
curl -s -H "Authorization: Bearer $TOKEN" \
  "https://api.vercel.com/v9/projects/<project-id>?teamId=$TEAM_ID" \
  | jq '.previewDeploymentsDisabled'
# Should return: true
```

> **Why this matters:** Even with `ignoreCommand` in `vercel.json`, Vercel still *attempts* a deployment for every push, which counts toward the rate limit. The `previewDeploymentsDisabled` setting prevents Vercel from initiating the deployment entirely. Use the [Deploy Preview](#preview-deploys) GitHub Action or Vercel CLI when you need a preview.

### 4. Configure Environment Variables

#### Web project

```bash
cd apps/web
for env in production preview development; do
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add API_URL "$env"
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add APP_URL "$env"
done
```

> **Warning:** Always use `printf '%s'` instead of `echo` when piping values to `vercel env add`. `echo` appends a trailing newline that becomes part of the stored value, which causes `ERR_INVALID_CHAR` errors when the values are used in HTTP headers (e.g., CORS origin).

| Variable | Description |
|----------|-------------|
| `API_URL` | Vercel API project URL |
| `APP_URL` | This project's URL |

#### API project

```bash
cd apps/api

# Generate auth secret
SECRET=$(openssl rand -base64 32)

for env in production preview development; do
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add CORS_ORIGIN "$env"
  printf '%s' "$SECRET"                       | vercel env add BETTER_AUTH_SECRET "$env"
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add BETTER_AUTH_URL "$env"
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add APP_URL "$env"
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add API_URL "$env"
  printf '%s' "noreply@yourdomain.com"        | vercel env add EMAIL_FROM "$env"
done
```

Add secrets interactively (values not stored in shell history):

```bash
vercel env add DATABASE_URL production
vercel env add RESEND_API_KEY production
```

| Variable | Description |
|----------|-------------|
| `DATABASE_URL` | PostgreSQL connection string |
| `CORS_ORIGIN` | Web project URL (for CORS) |
| `BETTER_AUTH_SECRET` | Random 32+ character string |
| `BETTER_AUTH_URL` | This project's URL |
| `APP_URL` | Web project URL |
| `API_URL` | This project's URL |
| `EMAIL_FROM` | Sender email address |
| `RESEND_API_KEY` | Resend API key for transactional emails |

### 5. Verify

```bash
cd apps/web && vercel env ls
cd apps/api && vercel env ls
```

---

## Daily Operations

### Check Deployment Status

```bash
cd apps/web && vercel ls    # Web deployments
cd apps/api && vercel ls    # API deployments
```

### View Logs

```bash
vercel logs <deployment-url>
```

### Inspect a Deployment

```bash
vercel inspect <deployment-url>
vercel inspect <deployment-url> --logs   # With build logs
```

### Rollback

```bash
vercel promote <previous-deployment-url>
```

Or find the URL first:

```bash
vercel ls                                  # Find the working deployment
vercel promote <url>                       # Promote it to production
```

### Redeploy

```bash
vercel redeploy <deployment-url>
```

### Manage Environment Variables

```bash
vercel env ls                              # List all
vercel env add SECRET_NAME production      # Add (interactive)
vercel env rm SECRET_NAME production       # Remove
vercel env pull .env.local                 # Pull to local file
```

---

## Build Settings

Build settings are version-controlled in `vercel.json` files — no dashboard configuration needed.

**`apps/web/vercel.json`:**

```json
{
  "ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/web",
  "installCommand": "bun install",
  "buildCommand": "turbo run build"
}
```

**`apps/api/vercel.json`:**

```json
{
  "ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/api",
  "installCommand": "bun install",
  "buildCommand": "bun run db:migrate && turbo run build"
}
```

Nitro (TanStack Start) outputs to `.vercel/output/` using the Vercel Build Output API — no `outputDirectory` override needed.

> **Important:** Dashboard build settings (Install Command, Build Command) must match `vercel.json` values. If they diverge, Vercel shows a "Configuration Settings differ" warning. Use the Vercel API to sync them if needed:
> ```bash
> curl -X PATCH -H "Authorization: Bearer $TOKEN" \
>   "https://api.vercel.com/v9/projects/$PROJECT_ID?teamId=$TEAM_ID" \
>   -H "Content-Type: application/json" \
>   -d '{"buildCommand":"turbo run build","installCommand":"bun install"}'
> ```

---

## Build-Only on Main (Avoid Duplicate Deploys)

Automatic preview deployments are **disabled at the Vercel project level** via the `previewDeploymentsDisabled` API setting. This prevents Vercel from attempting (and canceling) preview builds on every push to non-production branches, which would otherwise consume the deployment rate limit.

As a secondary safeguard, both projects also use `ignoreCommand` in `vercel.json` to skip builds on non-`main` branches:

```json
"ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/web"
```

| Layer | Mechanism | Purpose |
|-------|-----------|---------|
| **Primary** | `previewDeploymentsDisabled: true` (project setting) | Prevents Vercel from even attempting preview deployments |
| **Secondary** | `ignoreCommand` in `vercel.json` | Skips builds on non-`main` branches if a deployment is triggered |

Preview deploys are **manual only** — use the **Deploy Preview** GitHub Action (see [Preview Deploys](#preview-deploys) above) or the Vercel CLI:

```bash
cd apps/web && vercel        # Preview deploy
cd apps/api && vercel        # Preview deploy
```

---

## Database Migrations

Database migrations run automatically during the Vercel build and are protected by CI schema drift detection.

### Automatic Migrations

The API build command runs migrations before building:

```json
"buildCommand": "bun run db:migrate && turbo run build"
```

| Behavior | Details |
|----------|---------|
| **When** | Every API deploy to production (merge to `main`) |
| **Idempotent** | Drizzle Kit tracks applied migrations — re-running is safe |
| **On failure** | Build fails, Vercel keeps the previous production deployment live |
| **On success** | Build continues, new code deploys with the updated schema |

> **Note:** Because migrations run *before* the build, your database schema is always at least as new as the deployed code. There is no window where new code runs against an old schema.

### Manual Rollback

Drizzle Kit does not support automatic rollback (`db:rolldown`). If a migration causes issues:

| Strategy | Steps |
|----------|-------|
| **Corrective migration** (preferred) | Write a new migration that undoes the change, commit, and push. The next deploy applies it automatically. |
| **Revert and redeploy** | Revert the commit containing the bad migration, push to `main`. Vercel redeploys with the previous schema. Only works if the migration was additive (e.g., adding a column). Destructive migrations (dropping columns/tables) cannot be reverted this way. |

### Schema Drift Detection

CI automatically detects when a developer modifies Drizzle schema files but forgets to generate the corresponding migration.

**How it works:**

1. The `typecheck` job runs `bun run db:generate` with a dummy `DATABASE_URL`
2. It checks `git diff` on the `apps/api/drizzle/` directory
3. If uncommitted migration files are produced, CI fails

**Error message you will see:**

```
Schema drift detected! Your Drizzle schema has changes that are not captured in a migration file.
Run 'cd apps/api && bun run db:generate' locally and commit the generated migration.
```

**To fix:** Run `cd apps/api && bun run db:generate` locally, review the generated SQL, and commit it with your schema changes.

### Preview Database Branches

When deploying API previews, the Deploy Preview workflow creates an **isolated Neon database branch** so preview environments do not share the production database.

| Step | What happens |
|------|-------------|
| `create-neon-branch` job | Creates a Neon branch named `preview/{branch}` with its own `DATABASE_URL` |
| `deploy-api` job | Builds the API with the branch `DATABASE_URL`, runs `db:migrate` during build |
| After review | Re-run the workflow with target `cleanup` to delete the Neon branch |

**Cleanup:**

1. Go to **Actions** &gt; **Deploy Preview**
2. Click **Run workflow**
3. Select the same branch used for the preview
4. Choose target: **cleanup**
5. Click **Run workflow**

The workflow deletes the Neon branch named `preview/{branch}`. You can also delete branches directly from the [Neon console](https://console.neon.tech).

---

## Custom Domains

```bash
cd apps/web && vercel domains add app.yourdomain.com
cd apps/api && vercel domains add api.yourdomain.com
```

Then configure DNS with a CNAME record pointing to `cname.vercel-dns.com`. Vercel handles SSL certificates automatically.

---

## Important Notes

- Vercel automatically sets `NODE_ENV=production`
- NestJS runs as a [Vercel Function](https://vercel.com/docs/functions) with [Fluid compute](https://vercel.com/docs/fluid-compute) — auto-scaling, reduced cold starts
- The API entrypoint is `src/index.ts` (not the NestJS default `src/main.ts`), configured via `entryFile` in `nest-cli.json`
- NestJS middlewares with the Fastify adapter receive raw Node.js `ServerResponse` objects — use `res.setHeader()`, not `res.header()`
- Free tier: 10s execution limit per request. Pro tier: 60s
- 250MB max application size (Vercel Functions limitation)
- `API_URL`, `APP_URL`, and `VITE_ENABLE_DEMO` are declared in `turbo.json` build env to ensure Turbo invalidates cache when they change
- `apps/api/turbo.json` declares runtime secrets (database, auth) as `passThroughEnv` — these are available at runtime but don't affect build cache

---

## VPS Alternative

The repository includes Docker configurations for VPS-based deployment:

- Multi-stage Dockerfiles for API and web
- `docker-compose.prod.yml` for container orchestration
- Nginx reverse proxy configs in `deploy/nginx/`

If you have a VPS with Docker, you can use the Docker build/push/SSH deploy pipeline instead of Vercel.
