---
title: Deployment
description: Deploy Roxabi on Vercel — both web and API on one platform
---

## Overview

Roxabi uses a **staging-based** deployment architecture with **Vercel** as the single platform for both the web app and API.

```
Feature branch → PR to staging → CI runs
                                → (optional) Deploy Preview via GitHub Actions
staging → PR to main → CI runs → Vercel auto-deploys to production
```

| Component | Platform | Details |
|-----------|----------|---------|
| Web (TanStack Start + Nitro) | Vercel | SSR, edge caching, Fluid compute |
| API (NestJS + Fastify) | Vercel | Zero-config NestJS, Fluid compute, auto-scaling |
| Database | Neon | Serverless PostgreSQL, not managed by Vercel |

No Docker is needed for deployment. Docker configurations (Dockerfiles, `docker-compose.prod.yml`, Nginx configs, `deploy/`) remain in the repo for local development only.

---

## Branch Strategy

| Flow | Branch path | Deploys? |
|------|-------------|----------|
| **Normal** | `feat/*` → PR to `staging` → PR to `main` | Only `main` merges auto-deploy |
| **Hotfix** | `hotfix/*` → PR to `main` | Auto-deploys immediately |

- `staging` is the default integration branch — all feature PRs target it
- Merging to `staging` does **not** trigger a Vercel deploy
- Use the **Deploy Preview** GitHub Action for on-demand preview URLs from staging
- Only merges to `main` trigger production auto-deploys

---

## Preview Deploys

Preview deploys are **manual only**, triggered via the GitHub Actions tab.

### How to trigger

1. Go to **Actions** → **Deploy Preview**
2. Click **Run workflow**
3. Select the branch (typically `staging`)
4. Choose a target: `web`, `api`, or `both`
5. Click **Run workflow**

The workflow builds and deploys a Vercel preview. The preview URL appears in the **workflow run summary**.

### When to use

- Before promoting `staging` → `main`, to verify the integration build
- To share a preview URL with stakeholders for review
- To smoke-test a specific branch without deploying to production

---

## GitHub Actions Secrets

The **Deploy Preview** workflow requires these repository secrets:

| Secret | Description | Where to find |
|--------|-------------|---------------|
| `VERCEL_TOKEN` | Vercel personal access token | [vercel.com/account/tokens](https://vercel.com/account/tokens) |
| `VERCEL_ORG_ID` | Vercel team/org ID | `.vercel/project.json` → `orgId` (after `vercel link`) |
| `VERCEL_PROJECT_ID_WEB` | Vercel project ID for web | `apps/web/.vercel/project.json` → `projectId` |
| `VERCEL_PROJECT_ID_API` | Vercel project ID for API | `apps/api/.vercel/project.json` → `projectId` |

Add them at **Settings** → **Secrets and variables** → **Actions** → **New repository secret**.

---

## Prerequisites

Install the Vercel CLI globally:

```bash
bun add -g vercel
```

Authenticate:

```bash
vercel login
```

---

## Initial Setup

You need **two Vercel projects** pointing to the same GitHub repository — one for the web app and one for the API.

### 1. Create Projects

Create both projects from the Vercel dashboard (one-time setup):

1. Sign up at [vercel.com](https://vercel.com) and connect your GitHub account
2. Click **Add New Project**, import the repository, set Root Directory to `apps/web`
3. Repeat for `apps/api`

Build settings are version-controlled in `apps/web/vercel.json` and `apps/api/vercel.json` — no manual configuration needed.

### 2. Link Projects Locally

Link each app directory to its Vercel project:

```bash
cd apps/web && vercel link
cd apps/api && vercel link
```

Select the matching project when prompted. This creates `.vercel/project.json` in each directory (gitignored).

### 3. Configure Environment Variables

#### Web project

```bash
cd apps/web
for env in production preview development; do
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add API_URL "$env"
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add APP_URL "$env"
done
```

> **Warning:** Always use `printf '%s'` instead of `echo` when piping values to `vercel env add`. `echo` appends a trailing newline that becomes part of the stored value, which causes `ERR_INVALID_CHAR` errors when the values are used in HTTP headers (e.g., CORS origin).

| Variable | Description |
|----------|-------------|
| `API_URL` | Vercel API project URL |
| `APP_URL` | This project's URL |

#### API project

```bash
cd apps/api

# Generate auth secret
SECRET=$(openssl rand -base64 32)

for env in production preview development; do
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add CORS_ORIGIN "$env"
  printf '%s' "$SECRET"                       | vercel env add BETTER_AUTH_SECRET "$env"
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add BETTER_AUTH_URL "$env"
  printf '%s' "https://app.roxabi.vercel.app" | vercel env add APP_URL "$env"
  printf '%s' "https://api.roxabi.vercel.app" | vercel env add API_URL "$env"
  printf '%s' "noreply@yourdomain.com"        | vercel env add EMAIL_FROM "$env"
done
```

Add secrets interactively (values not stored in shell history):

```bash
vercel env add DATABASE_URL production
vercel env add RESEND_API_KEY production
```

| Variable | Description |
|----------|-------------|
| `DATABASE_URL` | PostgreSQL connection string |
| `CORS_ORIGIN` | Web project URL (for CORS) |
| `BETTER_AUTH_SECRET` | Random 32+ character string |
| `BETTER_AUTH_URL` | This project's URL |
| `APP_URL` | Web project URL |
| `API_URL` | This project's URL |
| `EMAIL_FROM` | Sender email address |
| `RESEND_API_KEY` | Resend API key for transactional emails |

### 4. Verify

```bash
cd apps/web && vercel env ls
cd apps/api && vercel env ls
```

---

## Daily Operations

### Check Deployment Status

```bash
cd apps/web && vercel ls    # Web deployments
cd apps/api && vercel ls    # API deployments
```

### View Logs

```bash
vercel logs <deployment-url>
```

### Inspect a Deployment

```bash
vercel inspect <deployment-url>
vercel inspect <deployment-url> --logs   # With build logs
```

### Rollback

```bash
vercel promote <previous-deployment-url>
```

Or find the URL first:

```bash
vercel ls                                  # Find the working deployment
vercel promote <url>                       # Promote it to production
```

### Redeploy

```bash
vercel redeploy <deployment-url>
```

### Manage Environment Variables

```bash
vercel env ls                              # List all
vercel env add SECRET_NAME production      # Add (interactive)
vercel env rm SECRET_NAME production       # Remove
vercel env pull .env.local                 # Pull to local file
```

---

## Build Settings

Build settings are version-controlled in `vercel.json` files — no dashboard configuration needed.

**`apps/web/vercel.json`:**

```json
{
  "ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/web",
  "installCommand": "bun install",
  "buildCommand": "turbo run build"
}
```

**`apps/api/vercel.json`:**

```json
{
  "ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/api",
  "installCommand": "bun install",
  "buildCommand": "turbo run build"
}
```

Nitro (TanStack Start) outputs to `.vercel/output/` using the Vercel Build Output API — no `outputDirectory` override needed.

> **Important:** Dashboard build settings (Install Command, Build Command) must match `vercel.json` values. If they diverge, Vercel shows a "Configuration Settings differ" warning. Use the Vercel API to sync them if needed:
> ```bash
> curl -X PATCH -H "Authorization: Bearer $TOKEN" \
>   "https://api.vercel.com/v9/projects/$PROJECT_ID?teamId=$TEAM_ID" \
>   -H "Content-Type: application/json" \
>   -d '{"buildCommand":"turbo run build","installCommand":"bun install"}'
> ```

---

## Build-Only on Main (Avoid Duplicate Deploys)

Both projects use `ignoreCommand` in `vercel.json` to only trigger Vercel builds on the `main` branch. The command first checks if the branch is `main`, then uses `turbo-ignore` to skip builds when no relevant files changed:

```json
"ignoreCommand": "[ \"$VERCEL_GIT_COMMIT_REF\" != \"main\" ] || npx turbo-ignore @repo/web"
```

Preview deploys are handled via the **Deploy Preview** GitHub Action (see [Preview Deploys](#preview-deploys) above). You can also trigger them locally via the CLI:

```bash
cd apps/web && vercel        # Preview deploy
cd apps/api && vercel        # Preview deploy
```

---

## Custom Domains

```bash
cd apps/web && vercel domains add app.yourdomain.com
cd apps/api && vercel domains add api.yourdomain.com
```

Then configure DNS with a CNAME record pointing to `cname.vercel-dns.com`. Vercel handles SSL certificates automatically.

---

## Important Notes

- Vercel automatically sets `NODE_ENV=production`
- NestJS runs as a [Vercel Function](https://vercel.com/docs/functions) with [Fluid compute](https://vercel.com/docs/fluid-compute) — auto-scaling, reduced cold starts
- The API entrypoint is `src/index.ts` (not the NestJS default `src/main.ts`), configured via `entryFile` in `nest-cli.json`
- NestJS middlewares with the Fastify adapter receive raw Node.js `ServerResponse` objects — use `res.setHeader()`, not `res.header()`
- Free tier: 10s execution limit per request. Pro tier: 60s
- 250MB max application size (Vercel Functions limitation)
- `API_URL`, `APP_URL`, and `VITE_ENABLE_DEMO` are declared in `turbo.json` build env to ensure Turbo invalidates cache when they change
- `apps/api/turbo.json` declares runtime secrets (database, auth) as `passThroughEnv` — these are available at runtime but don't affect build cache

---

## VPS Alternative

The repository includes Docker configurations for VPS-based deployment:

- Multi-stage Dockerfiles for API and web
- `docker-compose.prod.yml` for container orchestration
- Nginx reverse proxy configs in `deploy/nginx/`

If you have a VPS with Docker, you can use the Docker build/push/SSH deploy pipeline instead of Vercel.
