---
title: "Multi-tenant Row-Level Security (RLS)"
description: Technical specification for implementing PostgreSQL RLS-based tenant isolation infrastructure in the Roxabi SaaS boilerplate.
---

## Context

Roxabi's architecture requires database-level tenant isolation for its SaaS model. The organization hierarchy is:

```
META Organization (super admin)
└── Organization (tenant)
    └── Child Organization(s) (subdivisions)
        └── Users
```

Issue #19 (Auth &amp; Users) delivered the foundation: Better Auth with its Organization plugin provides `organizations`, `members`, `invitations` tables, and `sessions.activeOrganizationId` for tracking the user's active organization context. The auth spec explicitly deferred tenant isolation:

> "Organization plugin's `organizationId` and our existing `tenantId` base column serve different purposes. Alignment is deferred to #21 (RLS)."

A `tenantColumn` helper already exists in `apps/api/src/database/schema/base.ts` but is not applied to any tables yet. The `nestjs-cls` module is already configured for correlation IDs.

**Promoted from:** [Multi-tenant RLS Strategy Analysis](../analyses/21-multi-tenant-rls.mdx)

**Dependencies:** #19 (Auth — complete)
**Blocks:** #24 (RBAC), #25 (Admin panel)

## Goal

Deliver the **RLS infrastructure and patterns** so that any future business table can opt into tenant isolation with minimal boilerplate. This includes the NestJS middleware layer, PostgreSQL migration (roles, reusable policy function), and integration tests proving isolation — but no business tables.

## Users &amp; Use Cases

### Developer creating a new business table

A developer adds a new feature (e.g., projects, invoices, documents). They:

1. Add `...tenantColumn` to their Drizzle schema definition
2. Create a migration that calls `SELECT create_tenant_rls_policy('table_name')` to apply the standard RLS policy
3. Use `TenantService` in their NestJS service to run queries — tenant isolation is automatic

### Service querying tenant-scoped data

A NestJS service method needs to read/write tenant-scoped data:

1. The `TenantInterceptor` has already extracted `activeOrganizationId` from the session and stored it in CLS
2. The service calls `TenantService.query(async (tx) => { ... })` which wraps queries in a transaction with `set_config()`
3. RLS policies enforce that only rows matching the current tenant are visible
4. The service code has zero tenant-awareness boilerplate

### User with no active organization

A user hits a tenant-scoped endpoint without an active organization:

1. `@RequireOrg()` guard (already exists) intercepts the request
2. Returns 403 Forbidden before the `TenantInterceptor` runs
3. No database query is executed

### Super admin (META Organization)

Deferred to #25 (Admin panel). For now, super admin users are subject to the same RLS policies as regular users when accessing business data. The analysis documents the future pattern: a separate Postgres role with `BYPASSRLS` and a dedicated connection pool.

## Expected Behavior

### Happy path

1. **Request arrives** → Fastify receives the HTTP request
2. **AuthGuard** validates session, injects `session` into request (existing behavior)
3. **`@RequireOrg()` guard** verifies `session.session.activeOrganizationId` is set (existing behavior, returns 403 if missing)
4. **TenantInterceptor** (new, global):
   - Reads `session.session.activeOrganizationId` from the request
   - Stores it in CLS via `ClsService.set('tenantId', activeOrganizationId)`
   - If no `activeOrganizationId` (route allows anonymous or optional auth), sets `tenantId` to `null` in CLS — the interceptor does NOT block, that's the guard's job
5. **Controller** receives the request and calls service methods
6. **Service** calls `TenantService.query(async (tx) => { ... })`:
   - `TenantService` reads `tenantId` from CLS
   - If `tenantId` is `null`, throws `ForbiddenException` (safety net — should not happen if `@RequireOrg()` is used correctly)
   - Opens a Drizzle transaction
   - Executes `SELECT set_config('app.tenant_id', tenantId, true)` as the first statement
   - Runs the callback with the transaction handle
   - Commits the transaction
   - `set_config()` is automatically cleared when the transaction ends
7. **RLS policies** filter all SELECT/INSERT/UPDATE/DELETE within the transaction to rows where `tenant_id = current_setting('app.tenant_id', true)`

### Edge cases

| Scenario | Behavior |
|----------|----------|
| **No active org on tenant-scoped route** | `@RequireOrg()` returns 403 before interceptor runs |
| **Anonymous route (e.g., health check)** | `TenantInterceptor` sets `tenantId = null` in CLS. `TenantService` is not called. |
| **Optional auth route** | Same as anonymous — interceptor stores whatever org context exists (or null). Service decides whether to use `TenantService`. |
| **INSERT without tenant_id** | RLS `WITH CHECK` policy rejects the insert. Drizzle surfaces a Postgres error. Service should always include `tenant_id` via the `tenantColumn` schema. |
| **INSERT with wrong tenant_id** | RLS `WITH CHECK` policy rejects if the provided `tenant_id` does not match `current_setting('app.tenant_id')`. Prevents cross-tenant data injection. |
| **Transaction failure / rollback** | `set_config(..., true)` is transaction-scoped. On rollback, the setting is discarded. The connection is returned to the pool clean. |
| **Connection pool exhaustion** | Standard Postgres connection pool behavior. `TenantService.query()` will wait for an available connection (up to `connect_timeout`), then throw. No tenant context leaks. |
| **Child org user** | Child org's `activeOrganizationId` is the child org's ID. Since child orgs share the parent's `tenant_id`, the RLS policy matches using the parent org's ID. The `TenantInterceptor` must resolve `activeOrganizationId` → `tenant_id` (which may be the parent org ID). |
| **User switches organization** | Better Auth updates `sessions.activeOrganizationId`. Next request picks up the new org. No stale tenant context. |
| **Cron jobs / background tasks** | These do not have a session. They must explicitly call `TenantService.queryAs(tenantId, callback)` to set context manually. |
| **Better Auth routes (`/api/auth/*`)** | Not tenant-scoped. `TenantInterceptor` stores `null`. Better Auth queries run without RLS. |

## Constraints

- **PostgreSQL required** — RLS is a Postgres-specific feature. No abstraction for other databases.
- **All business queries must go through `TenantService`** — Direct Drizzle queries bypass RLS context. Linting or code review should enforce this.
- **Better Auth tables are excluded from RLS** — Auth flows run before tenant context is known. Better Auth manages its own scoping.
- **Connection pooling** — `set_config(..., true)` is safe only inside transactions. `TenantService` must always wrap in a transaction.
- **Dependency on nestjs-cls** — Already configured for correlation IDs. Extending it for tenant context.
- **Child org → tenant_id resolution** — Requires a lookup to determine the parent org ID when the active org is a child. This lookup should be cached (CLS-scoped or short TTL).

## Non-goals

- **Business tables** — No new tables created. Future feature issues add tables using the `tenantColumn` pattern.
- **Organization CRUD endpoints** — Handled by Better Auth's Organization plugin.
- **RBAC** — Deferred to #24. This spec only ensures tenant isolation, not role-based permissions within a tenant.
- **Admin panel / super admin bypass** — Deferred to #25. The `BYPASSRLS` role pattern is documented but not implemented.
- **Modifying Better Auth tables** — Auth tables remain unprotected by RLS.
- **Multi-database or schema-per-tenant isolation** — Single database, single schema, RLS-only strategy.

## Technical Decisions

### 1. `tenant_id` = `organizations.id`

The organization IS the tenant. `tenant_id` on business tables is a foreign key to `organizations.id`. No separate tenant concept.

**Rationale:** Better Auth already manages organizations. `sessions.activeOrganizationId` already provides the context. Adding a separate tenant entity would duplicate state.

### 2. RLS on business tables only

Better Auth tables (`users`, `sessions`, `accounts`, `verifications`, `organizations`, `members`, `invitations`) are excluded from RLS.

**Rationale:** Investigation showed that Better Auth queries these tables during auth flows (login, session validation) before any tenant context exists. Adding RLS would break authentication. Better Auth's own application-level filtering is sufficient for its tables.

### 3. `set_config()` inside transactions

```sql
SELECT set_config('app.tenant_id', $1, true);
```

**Rationale:** Transaction-local, auto-cleared, safe with connection pooling, ergonomic with Drizzle's `sql` tagged template. Preferred over `SET LOCAL` for Node.js ecosystem conventions.

### 4. Reusable `create_tenant_rls_policy()` function

A PostgreSQL function that standardizes policy creation:

```sql
CREATE OR REPLACE FUNCTION create_tenant_rls_policy(table_name text)
RETURNS void AS $$
BEGIN
  EXECUTE format('ALTER TABLE %I ENABLE ROW LEVEL SECURITY', table_name);
  EXECUTE format('ALTER TABLE %I FORCE ROW LEVEL SECURITY', table_name);
  EXECUTE format(
    'CREATE POLICY tenant_isolation_%I ON %I
      USING (tenant_id = current_setting(''app.tenant_id'', true))
      WITH CHECK (tenant_id = current_setting(''app.tenant_id'', true))',
    table_name, table_name
  );
END;
$$ LANGUAGE plpgsql;
```

**Rationale:** Ensures consistent policy naming and structure across all business tables. One migration call per table.

### 5. NestJS interceptor + CLS for automatic context

`TenantInterceptor` stores the tenant ID in CLS. `TenantService` reads it from CLS and wraps queries in tenant-scoped transactions.

**Rationale:** `nestjs-cls` is already in the stack for correlation IDs. This pattern requires zero boilerplate in service code — just call `TenantService.query()`.

### 6. Child orgs share parent's tenant_id

Child organizations are subdivisions. All share the parent org's `tenant_id`. RLS policies only check `tenant_id`, not org hierarchy.

**Rationale:** Simplest RLS policy (single equality check). Covers the dominant SaaS pattern where company = tenant and departments are internal grouping.

### 7. Super admin bypass deferred

The analysis recommends a separate Postgres role with `BYPASSRLS`. Implementation is deferred to #25 (Admin panel) since there are no admin features yet.

**Rationale:** Avoids premature complexity. The dual-pool pattern is documented for when it's needed.

## Success Criteria

- [ ] `TenantInterceptor` extracts `activeOrganizationId` from session and stores in CLS
- [ ] `TenantService.query(callback)` wraps queries in a transaction with `set_config('app.tenant_id', ..., true)`
- [ ] `TenantService.queryAs(tenantId, callback)` allows explicit tenant context (for cron jobs, background tasks)
- [ ] `TenantService.query()` throws `ForbiddenException` if tenant ID is missing from CLS
- [ ] PostgreSQL migration creates `app_user` role and `create_tenant_rls_policy()` helper function
- [ ] Integration test: create temp table with `tenant_id` + RLS, insert as Tenant A, verify Tenant B cannot see Tenant A's rows
- [ ] Integration test: verify INSERT with mismatched `tenant_id` is rejected by `WITH CHECK` policy
- [ ] Integration test: verify queries outside `TenantService.query()` (no `set_config`) return empty results on RLS-enabled tables
- [ ] `tenantColumn` helper in `base.ts` is documented with usage instructions
- [ ] `@RequireOrg()` + `TenantInterceptor` + `TenantService` pipeline works end-to-end in a test request
- [ ] Child org resolution: `TenantInterceptor` resolves child org → parent org `tenant_id`

## Open Questions

1. **Child org → parent org lookup caching:** Should the resolution be cached in CLS (per-request), in a short-TTL in-memory cache, or looked up every time? The org hierarchy changes rarely, so caching is safe, but the strategy needs deciding during implementation.
2. **Postgres role management in managed databases:** Some managed Postgres providers (e.g., Supabase, Neon) have restrictions on `CREATE ROLE`. The migration should handle this gracefully — possibly using `DO $$ BEGIN ... EXCEPTION WHEN ... END $$` blocks.
3. **`FORCE ROW LEVEL SECURITY`:** Should policies apply to the table owner too? If the Drizzle connection uses the table owner role, `FORCE` is needed. If it uses a separate `app_user` role, `FORCE` is optional. Depends on the deployment's Postgres role setup.
4. **Drizzle migration vs raw SQL migration:** Should the `create_tenant_rls_policy()` function be created via a Drizzle custom migration (raw SQL in a migration file), or via a separate SQL script? Drizzle custom migrations are the standard pattern — confirm during implementation.
