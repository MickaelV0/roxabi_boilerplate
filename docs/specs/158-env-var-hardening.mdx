---
title: "Harden Vercel Env Var Handling Across CI/CD Pipeline"
description: Technical specification for 8 improvements to environment variable security, reliability, and developer experience
status: draft
---

## Context

A CI/CD env var audit revealed 8 improvements across security, reliability, and developer experience. All issues are children of [epic #158](https://github.com/MickaelV0/roxabi_boilerplate/issues/158).

**Promoted from:** [Env Var Hardening Analysis](../analyses/158-env-var-hardening)

**Current state:**

- API has Zod env validation but the `BETTER_AUTH_SECRET` guard only checks `NODE_ENV === 'production'`, missing preview/staging
- Web has zero env validation — `API_URL` silently falls back to localhost
- `passThroughEnv` in `apps/api/turbo.json` has 15+ unused Postgres vars
- Env file resolution is inconsistent between web and API
- Neon branch cleanup is manual only
- No CI check for `.env.example` drift
- `VERCEL_ENV` is not in any schema
- No consolidated env var reference docs

## Goal

Ensure every environment variable is validated, documented, and synchronized across the pipeline — with security guards that fail closed in non-development environments and CI gates that catch drift before it reaches production.

## Users &amp; Use Cases

| Actor | Interaction |
|-------|-------------|
| **Developer** | Gets clear startup errors when env vars are missing. Can reference a single doc page for all vars. `bun run check:env` catches drift locally. |
| **CI/CD** | Blocks merges when `.env.example` drifts from Zod schemas. Cleans up Neon branches automatically. |
| **DevOps** | Leaner `passThroughEnv`, consistent env file resolution, `VERCEL_ENV` available for preview-specific config. |
| **Security** | Preview deploys reject insecure default secrets. No silent fallbacks to localhost in production. |

## Technical Decisions

### Web server env validation via `server.ts` import

Import the env validation module as the very first import in `apps/web/src/server.ts`. This fails the server at startup if env vars are invalid. Chosen over Nitro plugins because the project has no existing Nitro plugin infrastructure and the server entry is the simplest, most reliable hook.

### `API_URL` development default

The server env schema provides `API_URL` with a development-only default: `z.string().url().default('http://localhost:4000')`. In production/preview (when `NODE_ENV !== 'development'` or `VERCEL_ENV` is set), `API_URL` must be explicitly configured. This preserves the current DX (`bun run dev` works without explicit `API_URL`) while failing fast in production.

### Vite client env validation via `loadEnv()`

The Vite plugin uses `loadEnv(config.mode, config.envDir, 'VITE_')` in the `configResolved` hook — NOT `config.env`, which only contains Vite internal vars (`MODE`, `BASE_URL`, etc.), not `VITE_*` vars from `.env` files. Zod is imported at the top of `vite.config.ts` (ESM — `require()` is not available).

The Vite plugin inlines its own schema (2 fields) rather than importing from `env.client.ts`, because `env.client.ts` has side effects (`import.meta.env` access at module level) that would crash during config resolution. A code comment notes the schema must stay in sync with `env.client.ts`.

### Env sync check via schema import

The sync check script uses `Object.keys(envSchema.shape)` rather than regex parsing. Zod's `.shape` is a plain object whose keys are the schema field names — zero-regex, perfectly reliable, and won't break on multiline defaults or nested objects. This requires the API schema to export `envSchema` (currently unexported).

### Commented-out vars in `.env.example`

Many vars in `.env.example` are commented out (prefixed with `#`) but represent real, optional env vars that exist in Zod schemas (e.g., `GOOGLE_CLIENT_ID`, `KV_REST_API_URL`). The sync check script must parse both uncommented and commented key-value lines (lines matching `# KEY=value` pattern) as valid entries. This avoids false positives.

### Neon cleanup naming convention

`deploy-preview.yml` uses `$GITHUB_REF_NAME` in a `workflow_dispatch` context, where it resolves to the branch name (e.g., `feat/42-auth`). The cleanup workflow uses `${{ github.head_ref }}` in a `pull_request:closed` context, which also resolves to the source branch name. These produce the same value for branches with associated PRs. Additionally, `deploy-preview.yml` already self-cleans by deleting any existing Neon branch with the same name before creating a new one (lines 129-137), so orphan buildup is naturally limited.

## Expected Behavior

### PR 1 — Security (Phases 1 + 2: #154, #156, #157, #151)

**Implementation order within PR:** #154 and #156 are independent. #157 must land before #151 (the secondary guard references `VERCEL_ENV`). All four can be committed atomically in one PR.

---

#### #154 — Trim `passThroughEnv`

1. Remove all unused Postgres variants and `DATABASE_URL_UNPOOLED` from `apps/api/turbo.json`.
2. Add a JSON comment above the array explaining why Neon/Postgres vars were removed and what to restore if Vercel's native Neon integration is later enabled.
3. `turbo run build` continues to succeed.

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `apps/api/turbo.json` | Modify | Remove 15 unused vars, add explanatory comment |

---

#### #156 — Standardize env file resolution

1. Simplify API `envFilePath` to monorepo root only.
2. Document the standard in configuration docs.

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `apps/api/src/app.module.ts` | Modify | Change `envFilePath` from `['../../.env.local', '../../.env', '.env.local', '.env']` to `['../../.env.local', '../../.env']` |
| `docs/configuration.mdx` | Modify | Add note that `.env` and `.env.local` always live at monorepo root |

---

#### #157 — Add `VERCEL_ENV` to env validation

1. Add `VERCEL_ENV: z.enum(['production', 'preview', 'development']).optional()` to the API Zod schema.
2. Export `envSchema` (currently unexported — needed by #152 sync check).
3. Add corresponding tests.

Note: Vercel auto-injects `VERCEL_ENV` for all deployments (confirmed). No manual configuration needed. `VERCEL_ENV` does not need to be in `passThroughEnv` — it is injected by the platform, not passed through Turbo.

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `apps/api/src/config/env.validation.ts` | Modify | Add `VERCEL_ENV` to `envSchema`, add `export` keyword to `envSchema` |
| `apps/api/src/config/env.validation.test.ts` | Modify | Add tests for `VERCEL_ENV` validation (valid values, optional behavior) |

---

#### #151 — Tighten BETTER_AUTH_SECRET guard

1. Change `NODE_ENV === 'production'` to `NODE_ENV !== 'development'` in the secret guard.
2. Add secondary guard: reject insecure secret whenever `VERCEL_ENV` is set (regardless of `NODE_ENV`).
3. Update existing tests that assert the old behavior.
4. Provide test-specific secret in test configuration and CI workflow.

**Implementation:**

```typescript
// apps/api/src/config/env.validation.ts

// Primary guard: reject insecure secret in any non-development environment
if (
  validatedConfig.NODE_ENV !== 'development' &&
  INSECURE_SECRETS.includes(validatedConfig.BETTER_AUTH_SECRET)
) {
  throw new Error(
    'BETTER_AUTH_SECRET must be set to a secure value in non-development environments. ' +
      'Generate one with: openssl rand -base64 32'
  )
}

// Secondary guard: covers the edge case where NODE_ENV=development but VERCEL_ENV is set
// (misconfigured Vercel deploy that somehow has NODE_ENV=development)
if (
  validatedConfig.VERCEL_ENV &&
  INSECURE_SECRETS.includes(validatedConfig.BETTER_AUTH_SECRET)
) {
  throw new Error(
    'BETTER_AUTH_SECRET must be set to a secure value on Vercel deployments. ' +
      'Generate one with: openssl rand -base64 32'
  )
}
```

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `apps/api/src/config/env.validation.ts` | Modify | Invert guard to `!== 'development'`, add `VERCEL_ENV` secondary guard with explanatory comment |
| `apps/api/src/config/env.validation.test.ts` | Modify | Update test at ~line 123 to assert rejection in test env. Add new tests for `VERCEL_ENV` guard. Add test-specific secret to passing test cases. |
| `apps/api/src/test/setup.ts` | Modify | Add `BETTER_AUTH_SECRET=test-secret-minimum-32-characters-long` to test env |
| `.github/workflows/ci.yml` | Modify | Add `BETTER_AUTH_SECRET: test-secret-minimum-32-characters-long` to the `test` job env block |

**Test plan:**

| Test case | Expected |
|-----------|----------|
| `NODE_ENV=development` + default secret | Passes (allowed) |
| `NODE_ENV=test` + default secret | Throws |
| `NODE_ENV=production` + default secret | Throws |
| `NODE_ENV=test` + explicit secret | Passes |
| `VERCEL_ENV=preview` + default secret | Throws (regardless of `NODE_ENV`) |
| `VERCEL_ENV=preview` + explicit secret | Passes |
| No `VERCEL_ENV` + `NODE_ENV=development` + default secret | Passes |

---

### PR 2 — Validation + Tooling (Phases 3 + 4: #150, #152, #153)

**PR 2 depends on PR 1 being merged first** (the sync check imports the API schema which must have `export envSchema` from #157).

---

#### #150 — Web env validation

1. Create server-side env schema validated at startup in `server.ts`.
2. Create client-side env schema validated at build time via Vite plugin.
3. Export type-safe env objects for use across the web app.
4. Replace all raw `process.env.*` and `import.meta.env.*` accesses with the validated exports.

**Implementation — Server-side:**

```typescript
// apps/web/src/lib/env.server.ts
import { z } from 'zod'

export const envSchema = z.object({
  API_URL: z.string().url().default('http://localhost:4000'),
  APP_URL: z.string().url().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  VERCEL_ENV: z.enum(['production', 'preview', 'development']).optional(),
})

export type ServerEnv = z.infer<typeof envSchema>

// Parse and validate — crashes at import time if invalid
const parsed = envSchema.safeParse(process.env)

if (!parsed.success) {
  throw new Error(
    `Server env validation failed:\n${parsed.error.issues.map(i => `  ${i.path.join('.')}: ${i.message}`).join('\n')}`
  )
}

// In non-development: require explicit API_URL (no silent default)
if (
  parsed.data.NODE_ENV !== 'development' &&
  !process.env.API_URL
) {
  throw new Error('API_URL must be explicitly set in non-development environments')
}

export const env: ServerEnv = parsed.data
```

```typescript
// apps/web/src/server.ts — add as the very first import statement
import './lib/env.server' // validates server env at startup — crashes if invalid
// ... existing imports follow
```

**Implementation — Client-side:**

```typescript
// apps/web/src/lib/env.client.ts
import { z } from 'zod'

export const clientEnvSchema = z.object({
  VITE_ENABLE_DEMO: z.string().optional().default('true'),
  VITE_GITHUB_REPO_URL: z.string().url().optional(),
})

export type ClientEnv = z.infer<typeof clientEnvSchema>

export const clientEnv: ClientEnv = clientEnvSchema.parse({
  VITE_ENABLE_DEMO: import.meta.env.VITE_ENABLE_DEMO,
  VITE_GITHUB_REPO_URL: import.meta.env.VITE_GITHUB_REPO_URL,
})
```

```typescript
// apps/web/vite.config.ts — add imports at top
import { z } from 'zod'
import { loadEnv } from 'vite'

// In the plugins array, add:
{
  name: 'validate-env',
  configResolved(config) {
    if (config.command === 'build') {
      // Note: must stay in sync with apps/web/src/lib/env.client.ts schema
      const envVars = loadEnv(config.mode, config.envDir ?? process.cwd(), 'VITE_')
      const schema = z.object({
        VITE_ENABLE_DEMO: z.string().optional(),
        VITE_GITHUB_REPO_URL: z.string().url().optional(),
      })
      const result = schema.safeParse(envVars)
      if (!result.success) {
        throw new Error(
          `Client env validation failed:\n${result.error.issues.map(i => `  ${i.path.join('.')}: ${i.message}`).join('\n')}`
        )
      }
    }
  },
}
```

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `apps/web/src/lib/env.server.ts` | Create | Server-side Zod schema with dev default for `API_URL`, export `envSchema` and typed `env` |
| `apps/web/src/lib/env.client.ts` | Create | Client-side Zod schema, export `clientEnvSchema` and typed `clientEnv` |
| `apps/web/src/server.ts` | Modify | Add `import './lib/env.server'` as the **very first** import statement |
| `apps/web/vite.config.ts` | Modify | Add `z` and `loadEnv` imports, add `validate-env` Vite plugin |
| `apps/web/src/lib/api-client.server.ts` | Modify | Replace `process.env.API_URL \|\| DEFAULT_API_URL` with import from `env.server` |
| `apps/web/src/lib/config.ts` | Modify | Replace `import.meta.env.VITE_GITHUB_REPO_URL` with import from `env.client` |
| `apps/web/src/lib/layout.shared.tsx` | Modify | Replace `import.meta.env.VITE_GITHUB_REPO_URL` with import from `env.client` |
| `apps/web/src/components/Header.tsx` | Modify | Replace `import.meta.env.VITE_ENABLE_DEMO` with import from `env.client` |
| `apps/web/src/routes/demo.tsx` | Modify | Replace `import.meta.env.VITE_ENABLE_DEMO` with import from `env.client` |
| `apps/web/src/routes/demo/start.server-funcs.tsx` | Modify | Replace `import.meta.env.VITE_ENABLE_DEMO` with import from `env.client` |
| `apps/web/src/routes/demo/api.names.ts` | Modify | Replace `import.meta.env.VITE_ENABLE_DEMO` with import from `env.client` |
| `apps/web/src/routes/demo/api.tq-todos.ts` | Modify | Replace `import.meta.env.VITE_ENABLE_DEMO` with import from `env.client` |

**Test plan:**

| Test case | Expected |
|-----------|----------|
| Dev server starts without explicit `API_URL` | Starts normally (uses default `http://localhost:4000`) |
| Dev server starts with explicit `API_URL` | Uses the provided value |
| Non-dev server starts without `API_URL` | Crashes with "API_URL must be explicitly set" |
| Non-dev server starts with valid `API_URL` | Starts normally, `env.API_URL` is typed |
| Build without `VITE_GITHUB_REPO_URL` | Succeeds (field is optional) |
| Build with invalid `VITE_GITHUB_REPO_URL` (not a URL) | Build fails with validation error |
| `env.server` exports are importable in server routes | Type-safe access works |
| `env.client` exports are importable in client components | Type-safe access works |

---

#### #152 — Env var sync check

1. Create a Bun script that imports schema shapes and compares against `.env.example`.
2. Maintain a tooling-only allowlist for vars not in any Zod schema.
3. Parse both uncommented and commented key-value lines from `.env.example`.
4. Add to the `lint` CI job and as a local `bun run check:env` command.

**Important:** The new schema files (`env.server.ts`, `env.client.ts`) and the CI step must ship in the same PR. The CI step will break if added before the schema files exist.

**Implementation:**

```typescript
// scripts/check-env-sync.ts
import { readFileSync } from 'node:fs'
import { resolve } from 'node:path'

// Import Zod schemas directly — reliable, zero-regex
// Requires: envSchema exported from env.validation.ts (#157)
// Requires: envSchema exported from env.server.ts (#150)
// Requires: clientEnvSchema exported from env.client.ts (#150)
import { envSchema as apiEnvSchema } from '../apps/api/src/config/env.validation'
import { envSchema as webServerEnvSchema } from '../apps/web/src/lib/env.server'
import { clientEnvSchema as webClientEnvSchema } from '../apps/web/src/lib/env.client'

// Vars consumed by tooling scripts or injected by platforms, not app schemas
const TOOLING_ALLOWLIST = new Set([
  'WEB_PORT',
  'CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS',
  'GITHUB_TOKEN',
  'OPENAI_API_KEY',
  'ANTHROPIC_API_KEY',
])

// Parse .env.example keys — both uncommented and commented key=value lines
const envExample = readFileSync(resolve(import.meta.dir, '../.env.example'), 'utf-8')
const envExampleKeys = new Set(
  envExample
    .split('\n')
    .map(line => line.trim())
    .filter(Boolean)
    // Match "KEY=value" and "# KEY=value" (commented optional vars)
    .map(line => line.replace(/^#\s*/, ''))
    .filter(line => /^[A-Z_]+=/.test(line))
    .map(line => line.split('=')[0].trim())
)

// Collect all schema keys
const schemaKeys = new Set([
  ...Object.keys(apiEnvSchema.shape),
  ...Object.keys(webServerEnvSchema.shape),
  ...Object.keys(webClientEnvSchema.shape),
])

let hasErrors = false

// Keys in schemas but missing from .env.example
for (const key of schemaKeys) {
  if (!envExampleKeys.has(key) && !TOOLING_ALLOWLIST.has(key)) {
    console.error(`ERROR: ${key} is in a Zod schema but missing from .env.example`)
    hasErrors = true
  }
}

// Keys in .env.example but not in any schema (and not in allowlist)
for (const key of envExampleKeys) {
  if (!schemaKeys.has(key) && !TOOLING_ALLOWLIST.has(key)) {
    console.warn(`WARN: ${key} is in .env.example but not in any Zod schema`)
  }
}

if (hasErrors) process.exit(1)
console.log('Env sync check passed')
```

**Import side-effect concern:** The `env.server.ts` module parses `process.env` on import, which would crash the sync check script if env vars are missing. Fix: the sync check should import only the schema objects, not the parsed env. Export `envSchema` separately from the `env` value. The schema exports (`envSchema`, `clientEnvSchema`) are pure Zod objects with no side effects. The `env` values are separate exports. Since Bun tree-shakes unused imports, importing only `{ envSchema }` will not trigger the `process.env` parsing.

If tree-shaking is insufficient, fall back to extracting schemas into a separate `env.schema.ts` file or use dynamic import with destructuring.

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `scripts/check-env-sync.ts` | Create | Env sync check script |
| `package.json` | Modify | Add `"check:env": "bun run scripts/check-env-sync.ts"` to scripts |
| `.github/workflows/ci.yml` | Modify | Add `bun run check:env` step to the `lint` job (after install, alongside Biome lint) |

**Test plan:**

| Test case | Expected |
|-----------|----------|
| All schemas and `.env.example` in sync | Script passes with exit 0 |
| Add a key to API schema but not `.env.example` | Script fails with ERROR |
| Extra key in `.env.example` not in any schema | Script warns but does not fail |
| Tooling-only var in `.env.example` | No warning (allowlisted) |
| Commented-out var in `.env.example` matching schema | No error (parsed correctly) |

---

#### #153 — Neon branch cleanup

1. Add `neon-cleanup.yml` triggered on PR close.
2. PR-close trigger uses `github.head_ref` via env block (not direct interpolation) to prevent script injection.

Note: The existing `deploy-preview.yml` already deletes any existing Neon branch with the same name before creating a new one (lines 129-137). This means the next manual preview deploy for the same branch self-cleans. The PR-close workflow handles final cleanup when the branch is done. The existing manual `cleanup` target in `deploy-preview.yml` remains as a fallback.

**Implementation:**

```yaml
# .github/workflows/neon-cleanup.yml
name: Neon Branch Cleanup

on:
  pull_request:
    types: [closed]

permissions:
  contents: read

jobs:
  cleanup-pr-branch:
    name: Cleanup PR Neon Branch
    runs-on: ubuntu-latest
    steps:
      - name: Delete Neon branch for closed PR
        env:
          NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
          NEON_PROJECT_ID: ${{ secrets.NEON_PROJECT_ID }}
          # Store in env block to prevent script injection from fork PR branch names
          BRANCH_REF: ${{ github.head_ref }}
        run: |
          BRANCH_NAME="preview/$BRANCH_REF"
          BRANCH_NAME=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._/-]//g')

          BRANCH_ID=$(curl -sf -H "Authorization: Bearer $NEON_API_KEY" \
            "https://console.neon.tech/api/v2/projects/$NEON_PROJECT_ID/branches" \
            | jq -r --arg name "$BRANCH_NAME" '.branches[] | select(.name == $name) | .id')

          if [ -z "$BRANCH_ID" ]; then
            echo "No Neon branch found for: $BRANCH_NAME (already cleaned up)"
            exit 0
          fi

          curl -sf -X DELETE -H "Authorization: Bearer $NEON_API_KEY" \
            "https://console.neon.tech/api/v2/projects/$NEON_PROJECT_ID/branches/$BRANCH_ID"

          echo "Deleted Neon branch: $BRANCH_NAME ($BRANCH_ID)"
```

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `.github/workflows/neon-cleanup.yml` | Create | Neon branch cleanup on PR close |

**Test plan:**

| Test case | Expected |
|-----------|----------|
| PR closed that had a preview deploy | Neon branch `preview/<branch>` deleted |
| PR closed that never had a preview deploy | "No Neon branch found" — exits 0 |
| Fork PR with malicious branch name | Sanitized via env block + sed (no script injection) |

---

### PR 3 — Documentation (Phase 5: #155)

---

#### #155 — Consolidated env var reference

1. Add a comprehensive reference table to `docs/configuration.mdx`.
2. Group by domain, include all columns (Variable, App, Required, Default, Scope, Description).

**File changes:**

| File | Action | Details |
|------|--------|---------|
| `docs/configuration.mdx` | Modify | Add "Complete Environment Variable Reference" section with grouped tables |

The reference table should include all vars from both API and web Zod schemas plus tooling vars, grouped as:

- **Core** — `NODE_ENV`, `PORT`, `WEB_PORT`, `API_URL`, `APP_URL`, `CORS_ORIGIN`, `LOG_LEVEL`
- **Database** — `DATABASE_URL`
- **Authentication** — `BETTER_AUTH_SECRET`, `BETTER_AUTH_URL`, `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET`, `GITHUB_CLIENT_ID`, `GITHUB_CLIENT_SECRET`, `RESEND_API_KEY`, `EMAIL_FROM`
- **Rate Limiting** — `KV_REST_API_URL`, `KV_REST_API_TOKEN`, `RATE_LIMIT_ENABLED`, `SWAGGER_ENABLED`, `RATE_LIMIT_GLOBAL_TTL`, `RATE_LIMIT_GLOBAL_LIMIT`, `RATE_LIMIT_AUTH_TTL`, `RATE_LIMIT_AUTH_LIMIT`, `RATE_LIMIT_AUTH_BLOCK_DURATION`, `RATE_LIMIT_API_TTL`, `RATE_LIMIT_API_LIMIT`
- **Deployment** — `VERCEL_ENV`
- **Public (Client)** — `VITE_ENABLE_DEMO`, `VITE_GITHUB_REPO_URL`
- **Tooling** — `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS`, `GITHUB_TOKEN`

## Edge Cases

| Scenario | Behavior |
|----------|----------|
| Sync check script fails to import a schema | Script crashes — CI fails. Fix: verify exports are correct. |
| `.env.example` has syntax errors (missing `=`) | Lines without `=` are filtered out and ignored. |
| Developer adds var to schema but forgets to export it | Sync script import fails — CI fails. Actionable error message. |
| `VERCEL_ENV` not in `.env.example` | Not needed — it is platform-injected. Added to `TOOLING_ALLOWLIST` if it appears in schemas but not `.env.example`. |
| Sync check runs before web schemas exist (PR ordering) | Only possible if CI step is added without the schema files. The spec requires both to ship in the same PR. |
| `API_PORT` ghost variable in `vite.config.ts` | Out of scope — pre-existing issue. Can be cleaned up as a follow-up. |

## Constraints

- **Test environment change**: The #151 guard change requires all test environments to provide an explicit `BETTER_AUTH_SECRET`. This affects local dev (`.env.test` or test setup), CI (workflow env block), and any developer running tests.
- **PR ordering**: PR 2 depends on PR 1 being merged first (the sync check imports the API schema which needs `export envSchema` from #157).
- **Vercel CWD**: On Vercel, the CWD is the repo root (TurboRepo build). The API `envFilePath` relative paths resolve above the repo, but this is irrelevant since Vercel injects env vars via the dashboard.
- **Sync script side effects**: Importing `env.server.ts` triggers `process.env` parsing. The script must import only schema exports (not the `env` value). Verify Bun tree-shakes unused exports; if not, extract schemas into separate files.

## Non-goals

- **Automated secret rotation**: Not automating Vercel env var rotation or alerting.
- **Runtime env var reloading**: All validation is at startup/build time.
- **Env var encryption at rest**: Out of scope — Vercel handles this.
- **Blue-green env var switching**: No rollback strategy for env var changes beyond Vercel dashboard.
- **Rate limiting guard change**: The rate limiting `NODE_ENV === 'production'` check is mitigated by `deploy-preview.yml` setting `RATE_LIMIT_ENABLED=false` — no change needed.
- **`API_PORT` cleanup**: Pre-existing ghost variable in `vite.config.ts` — separate issue.

## Success Criteria

### PR 1 — Security
- [ ] Unused Postgres variants removed from `passThroughEnv` (#154)
- [ ] API resolves env files from monorepo root only (#156)
- [ ] `VERCEL_ENV` available in API Zod schema, `envSchema` exported (#157)
- [ ] `BETTER_AUTH_SECRET` guard rejects default in all non-dev environments (#151)
- [ ] `BETTER_AUTH_SECRET` guard rejects default when `VERCEL_ENV` is set (#151)
- [ ] All existing tests pass with updated test secret (including CI)
- [ ] `turbo run build` succeeds

### PR 2 — Validation + Tooling
- [ ] Web server crashes at startup if `API_URL` is missing (non-dev) (#150)
- [ ] Web server starts in dev without explicit `API_URL` (uses default) (#150)
- [ ] Web build fails if client env vars are invalid (#150)
- [ ] All raw `process.env`/`import.meta.env` accesses replaced with typed imports (#150)
- [ ] `bun run check:env` catches schema/`.env.example` drift (#152)
- [ ] Tooling-only vars do not trigger warnings (#152)
- [ ] CI lint job runs env sync check (#152)
- [ ] Neon branches auto-deleted on PR close (#153)
- [ ] Fork PRs cannot inject scripts via branch names (#153)

### PR 3 — Documentation
- [ ] Complete env var reference table in `docs/configuration.mdx` (#155)
- [ ] Grouped by domain with all required columns
- [ ] All vars enumerated (no generic "OAuth vars" placeholders)
