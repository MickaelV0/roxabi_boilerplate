---
title: "RBAC (Roles and Permissions)"
description: Role-Based Access Control with per-tenant roles, flat permissions, and full-stack integration
---

# #24 — RBAC (Roles and Permissions)

## Context

Roxabi's current access control is limited to global user roles (`user | admin | superadmin`) and basic organization membership. There is no way to control what a member can do within an organization — every member has the same access.

B2B multi-tenant SaaS requires fine-grained, per-tenant access control: read-only viewers, editors, billing managers, and custom roles defined by each organization.

The infrastructure is ready:
- **Auth** (#19): Better Auth with sessions, organizations, and membership
- **Multi-tenant RLS** (#21): Row-level security with `TenantService`, `TenantInterceptor`, and CLS-based tenant context
- **AuthGuard**: Global guard with `@Roles()`, `@RequireOrg()`, `@AllowAnonymous()`, `@OptionalAuth()` decorators

**Promoted from:** [RBAC Analysis](../analyses/24-rbac.mdx)

**Dependencies**: #19 (done), #21 (done)
**Blocks**: Admin panel

## Goal

Enable organizations to control member access through roles and permissions. Each organization gets default roles (Owner, Admin, Member, Viewer) and can create custom roles. Permissions are enforced at the API level via guards and reflected in the frontend via session data.

## Users &amp; Use Cases

### Organization Owner
- Creates the organization and is assigned Owner role automatically
- Manages all aspects of the organization including destructive actions (delete org)
- Transfers ownership to another Admin when needed
- Creates custom roles for the organization

### Organization Admin
- Manages members: invite, remove, change roles
- Creates and edits custom roles
- Has full operational permissions but cannot delete the organization or transfer ownership

### Organization Member
- Standard user with read and write access to business data
- Cannot manage other members or roles

### Organization Viewer
- Read-only access to business data
- Cannot modify anything

### Platform Super-Admin
- Has `superadmin` global role on the `users` table
- Bypasses all permission checks at the guard level
- Can access all organizations regardless of membership

## Expected Behavior

### Happy path

#### Organization creation
1. User creates an organization via Better Auth's organization plugin
2. System seeds the four default roles (Owner, Admin, Member, Viewer) with their permission sets
3. The creator's `members` record gets `role_id` set to the Owner role

#### Permission checking (API request)
1. Request arrives → `AuthGuard` validates session
2. `TenantInterceptor` extracts `activeOrganizationId` → sets tenant context in CLS
3. Guard checks for `@Permissions('resource:action')` decorator
4. Guard resolves the user's `role_id` from `members` table for the active org
5. Guard loads the role's permissions from `role_permissions` join
6. If required permission is in the set → allow. Otherwise → 403 Forbidden.
7. If user has `superadmin` global role → skip permission checks entirely

#### Frontend permission rendering
1. Session fetch resolves user's permissions for the active organization
2. Permissions returned as `string[]` in the session response (e.g., `["users:read", "members:write"]`)
3. Frontend utility checks `session.permissions.includes('resource:action')` to show/hide UI elements
4. When user switches organization, session refreshes → new permissions loaded

#### Custom role creation
1. Admin/Owner navigates to role management (API-only for now, UI deferred)
2. Calls `POST /roles` with `{ name, description, permissions: ["users:read", ...] }`
3. System creates the role scoped to the tenant (RLS ensures isolation)
4. Role becomes assignable to members

#### Ownership transfer
1. Current Owner calls `POST /roles/transfer-ownership` with `{ targetMemberId }`
2. System verifies target is an Admin in the same organization
3. Target's role changes to Owner, current Owner's role changes to Admin
4. At least one Owner constraint is maintained (this is a transfer, not removal)

### Edge cases

| Scenario | Behavior |
|----------|----------|
| Last Owner tries to leave org | **Blocked** — 400 error. Must transfer ownership first. |
| Last Owner tries to change own role | **Blocked** — 400 error. At least one Owner must exist. |
| Custom role deleted with assigned members | Members automatically fallback to **Viewer** role. |
| User has no membership in active org | `role_id` is null → all permission checks fail → 403. |
| User switches org | Session refresh → permissions re-resolved for new org. |
| Permission check without `@RequireOrg()` | `@Permissions()` implies `@RequireOrg()` — guard requires active org context. |
| Super-admin accesses org they're not a member of | Allowed — super-admin bypasses permission checks. Tenant context is set if org exists. |
| Role name collision (same name in same org) | **Blocked** — unique constraint on `(tenant_id, slug)`. Return 409 Conflict. |
| Invite with a specific role | Invitation includes `role_id`. On acceptance, member gets that role instead of default Member. |

## Constraints

- **Better Auth owns `members.role`**: The existing `role` text column is managed by Better Auth's organization plugin. We cannot modify it. A new `role_id` FK column is added alongside it.
- **RLS on `roles` and `role_permissions`**: These tables use `tenant_id` and follow the existing RLS pattern. The `permissions` table is global (no RLS).
- **No inheritance**: Flat permission model. Each role explicitly lists its permissions. No role hierarchy.
- **Session-based permissions**: Permissions are resolved server-side and included in the session. No separate permissions endpoint.
- **Existing guard pipeline**: Must integrate with the existing `AuthGuard` → `TenantInterceptor` flow without breaking current decorators.

## Non-goals

- **Admin UI for role management**: No UI for creating, editing, or deleting roles. Deferred to the Admin panel issue. Roles are managed via API endpoints only.
- **Permission groups / composable roles**: No grouping of permissions. Can be layered on later.
- **Hierarchical inheritance**: No role hierarchy or rank-based inheritance.
- **Object-level permissions**: No per-record access control (e.g., "user X can edit project Y but not Z"). RBAC is resource-type level only.
- **Audit logging of permission changes**: Deferred to a separate audit feature.
- **Resources beyond existing entities**: `settings`, `audit`, `billing` permissions are added when those features are built.

## Technical Decisions

### Database schema

#### `permissions` table (global, not tenant-scoped)

| Column | Type | Notes |
|--------|------|-------|
| `id` | `text` (UUID) | Primary key |
| `resource` | `text` | e.g., `users`, `members`, `organizations`, `invitations` |
| `action` | `text` | e.g., `read`, `write`, `delete` |
| `description` | `text` | Human-readable description |
| `created_at` | `timestamp` | |

Unique constraint on `(resource, action)`. Seeded via migration, not editable by tenants.

#### `roles` table (tenant-scoped)

| Column | Type | Notes |
|--------|------|-------|
| `id` | `text` (UUID) | Primary key |
| `tenant_id` | `text` | FK → `organizations.id`, RLS scoped |
| `name` | `text` | Display name (e.g., "Admin", "Billing Manager") |
| `slug` | `text` | Kebab-case identifier |
| `description` | `text` | Optional description |
| `is_default` | `boolean` | True for Owner/Admin/Member/Viewer. Cannot be deleted. |
| `created_at` | `timestamp` | |
| `updated_at` | `timestamp` | |

Unique constraint on `(tenant_id, slug)`. Default roles are seeded per org on creation.

#### `role_permissions` table (tenant-scoped via role FK)

| Column | Type | Notes |
|--------|------|-------|
| `role_id` | `text` | FK → `roles.id`, on delete cascade |
| `permission_id` | `text` | FK → `permissions.id`, on delete cascade |

Composite primary key on `(role_id, permission_id)`.

#### `members` table modification

Add column:

| Column | Type | Notes |
|--------|------|-------|
| `role_id` | `text` (nullable) | FK → `roles.id`, on delete set null |

Existing `role` text column is **kept** for Better Auth compatibility. `role_id` is the source of truth for RBAC. When `role_id` is null (e.g., role was deleted), the member is treated as Viewer.

### Default permission matrix

| Permission | Owner | Admin | Member | Viewer |
|------------|:-----:|:-----:|:------:|:------:|
| `users:read` | x | x | x | x |
| `users:write` | x | x | x | |
| `users:delete` | x | x | | |
| `organizations:read` | x | x | x | x |
| `organizations:write` | x | x | | |
| `members:read` | x | x | x | x |
| `members:write` | x | x | | |
| `members:delete` | x | x | | |
| `invitations:read` | x | x | x | x |
| `invitations:write` | x | x | | |
| `invitations:delete` | x | x | | |
| `roles:read` | x | x | | |
| `roles:write` | x | x | | |
| `roles:delete` | x | x | | |

Owner always has all permissions (enforced by code, not by the permission table — Owner gets `*` or all permissions are auto-included).

### NestJS guard integration

#### `@Permissions()` decorator

```typescript
// Usage on controller methods:
@Permissions('members:write')
@Post('members/invite')
inviteMember() { ... }

// Multiple permissions (all required):
@Permissions('members:write', 'invitations:write')
@Post('members/invite')
inviteMember() { ... }
```

#### AuthGuard evaluation order (updated)

1. `@AllowAnonymous()` → allow
2. Fetch session → 401 if missing
3. `@OptionalAuth()` → allow if no session
4. `@Roles()` → check global user role
5. `@RequireOrg()` or `@Permissions()` → require active organization
6. If `user.role === 'superadmin'` → skip permission check, allow
7. `@Permissions()` → resolve member's `role_id` → load permissions → check

#### Permission resolution service

```typescript
@Injectable()
export class PermissionService {
  // Resolve permissions for a user in an org (used by guard and session)
  async getPermissions(userId: string, organizationId: string): Promise&lt;string[]>

  // Check if a user has a specific permission
  async hasPermission(userId: string, organizationId: string, permission: string): Promise&lt;boolean>

  // Get all available permissions (for role management UI)
  async getAllPermissions(): Promise&lt;Permission[]>
}
```

### API endpoints

| Method | Path | Permission Required | Description |
|--------|------|-------------------|-------------|
| `GET` | `/roles` | `roles:read` | List roles for current org |
| `POST` | `/roles` | `roles:write` | Create custom role |
| `PATCH` | `/roles/:id` | `roles:write` | Update role permissions |
| `DELETE` | `/roles/:id` | `roles:delete` | Delete custom role (fallback members to Viewer) |
| `GET` | `/roles/:id/permissions` | `roles:read` | Get permissions for a role |
| `GET` | `/permissions` | `roles:read` | List all available permissions |
| `POST` | `/roles/transfer-ownership` | Owner only | Transfer ownership to another Admin |
| `PATCH` | `/members/:id/role` | `members:write` | Change a member's role |

### Frontend integration

A `usePermission` utility (or similar pattern matching existing frontend conventions):

```typescript
// Check a single permission
const canInvite = hasPermission(session, 'members:write')

// Guard a route or component
if (!hasPermission(session, 'members:read')) {
  return &lt;Forbidden />
}
```

Permissions are available on `session.permissions` as `string[]`. No additional API calls needed.

### Migration strategy

1. Create `permissions` table and seed with the initial permission set
2. Create `roles` table with RLS policy via `create_tenant_rls_policy('roles')`
3. Create `role_permissions` table with RLS (inherits via `role_id` FK)
4. Add `role_id` column to `members` table (nullable FK to `roles.id`)
5. Data migration: for each organization, seed default roles and assign members:
   - Members with `role = 'owner'` → Owner role
   - Members with `role = 'admin'` → Admin role
   - Members with `role = 'member'` → Member role
   - All others → Viewer role
6. Add `@Permissions()` decorator and update AuthGuard
7. Add `PermissionService` for permission resolution
8. Extend session response to include resolved permissions
9. Add frontend `hasPermission` utility

## Success Criteria

- [ ] `roles`, `permissions`, and `role_permissions` tables exist with RLS on tenant-scoped tables
- [ ] `members` table has `role_id` FK column populated for all existing members
- [ ] Default roles (Owner, Admin, Member, Viewer) are seeded for every organization
- [ ] `@Permissions('resource:action')` decorator works on controller methods
- [ ] AuthGuard enforces permissions — returns 403 when permission is missing
- [ ] Super-admin bypasses all permission checks
- [ ] Session response includes resolved `permissions: string[]` for the active organization
- [ ] Frontend can read `session.permissions` and conditionally render UI elements
- [ ] Custom roles can be created, edited, and deleted via API
- [ ] Deleting a custom role falls back affected members to Viewer
- [ ] Ownership transfer works with at-least-one-Owner constraint
- [ ] Role CRUD endpoints are protected by `roles:read/write/delete` permissions
- [ ] Integration tests cover permission enforcement, role CRUD, and edge cases

## Open Questions

- **Better Auth session extension**: What is the cleanest way to inject `permissions[]` into the Better Auth session response? May need a session hook or custom session endpoint wrapper.
- **Permission caching**: Should resolved permissions be cached per-request (CLS) or per-session? Per-request is simpler but re-queries on every request. Per-session requires cache invalidation on role changes.
- **`role_permissions` RLS**: This table references `roles` which is tenant-scoped. Should it have its own `tenant_id` column and RLS policy, or rely on the FK join to `roles`? Own column is simpler for RLS but denormalized.
- **Org creation hook**: Better Auth creates organizations. Where do we hook in to seed default roles? A database trigger, a Better Auth plugin hook, or a NestJS event listener?
