---
title: "License Checker — Dependency License Compliance"
description: Custom Bun script that scans all monorepo dependencies and enforces license compliance via an allowlist policy
---

## Context

The Roxabi Boilerplate is a SaaS framework targeting open-source distribution and enterprise adoption. As the monorepo grows (web, api, packages/ui, packages/config, packages/types), the transitive dependency tree expands with zero visibility into what licenses are being pulled in.

This is driven by legal compliance, open-source readiness, preventive hygiene, and enterprise procurement requirements. No tooling or process exists today.

**Promoted from:** [License Checker Analysis](../analyses/license-checker.mdx)

## Goal

Provide a single command (`turbo run license:check`) that scans every dependency (direct and transitive) across all monorepo workspace packages, checks each license against a configurable allowlist, and produces a human-readable summary plus a machine-readable JSON report — with an exit code suitable for CI gating.

## Users &amp; Use Cases

| User | Workflow |
|------|----------|
| **Developer** | Runs `turbo run license:check` locally after adding a new dependency to verify compliance |
| **CI pipeline** | Runs the check automatically on PR validation; blocks merge if violations are found |
| **Project maintainer** | Reviews the JSON report to audit the full dependency license landscape |
| **Legal / compliance** | Uses the JSON report for procurement audits and open-source license reviews |

## Expected Behavior

### Happy path

1. Developer runs `turbo run license:check`
2. Script reads `license-policy.json` from the repo root
3. Script walks `node_modules` directories (root + all workspace-specific) and reads each `package.json` for the `license` field
4. For packages missing the `license` field, falls back to reading `LICENSE` / `LICENCE` / `LICENSE.md` / `LICENCE.md` files and attempts to identify the license
5. Deduplicates packages (same name@version counted once regardless of workspace)
6. Compares each license against the `allowedLicenses` array and `overrides` map
7. Outputs a CLI summary to stdout:
   ```
   License Check — 342 packages scanned

   Licenses found:
     MIT          285
     ISC           32
     Apache-2.0    18
     BSD-3-Clause   5
     BSD-2-Clause   2

   ✅ No violations found
   ⚠  2 packages with unknown license (see report)

   Report written to reports/licenses.json
   ```
8. Writes full JSON report to `reports/licenses.json`
9. Exits with code 0

### Violation output

When violations are found, the CLI shows them:

```
License Check — 342 packages scanned

❌ 2 violations:
  some-package@1.2.3    GPL-3.0
  another-pkg@0.4.1     AGPL-3.0

⚠  1 package with unknown license:
  mystery-lib@2.0.0     UNKNOWN

Report written to reports/licenses.json
```

Exit code: 1

### Edge cases

| Case | Behavior |
|------|----------|
| `node_modules` not installed | Error: "Run `bun install` first" — exit 1 |
| `license-policy.json` missing | Error: "No license-policy.json found at repo root" — exit 1 |
| `license-policy.json` has empty `allowedLicenses` | Treat every license as a violation (strict mode) |
| Package has `licenses` array (deprecated field) | Read the first entry from the array |
| Package has SPDX expression (e.g., `MIT OR Apache-2.0`) | Check if ANY license in the expression is in the allowlist |
| Package listed in `overrides` | Use the override license instead of detected one |
| Scoped packages (`@org/pkg`) | Handle normally — no special treatment needed |
| Symlinked workspace packages | Skip — they are project code, not third-party dependencies |
| `reports/` directory doesn't exist | Create it automatically |

## Constraints

- **Bun-only** — uses Bun APIs for filesystem operations and script execution
- **No external dependencies** — the license checker itself must have zero npm dependencies (uses only Bun built-ins and Node.js `fs`/`path`)
- **Must handle large dependency trees** — expect 300-500+ packages in the monorepo
- **Must run in CI** — no interactive prompts, deterministic output

## Non-goals

- Per-package (per-workspace) reports — unified only
- Denylist support — allowlist is sufficient; anything not allowed is denied
- Support for non-Bun package managers (npm, yarn, pnpm)
- License text extraction or NOTICE file generation
- Dependency vulnerability scanning (separate concern)
- CI pipeline integration (deferred to a future issue)

## Technical Decisions

### File structure

```
tools/
  license-checker.ts       # Main script entry point
license-policy.json        # Policy config at repo root
reports/
  licenses.json            # Generated report (gitignored)
```

The `tools/` directory is new — created for monorepo-level tooling scripts.

### Policy config schema (`license-policy.json`)

```json
{
  "allowedLicenses": [
    "MIT",
    "ISC",
    "Apache-2.0",
    "BSD-2-Clause",
    "BSD-3-Clause",
    "0BSD",
    "CC0-1.0",
    "Unlicense"
  ],
  "overrides": {
    "some-package@1.2.3": "MIT"
  }
}
```

- `allowedLicenses` — array of SPDX license identifiers that are permitted
- `overrides` — map of `package@version` to SPDX identifier for packages with missing or incorrect license metadata

### JSON report schema (`reports/licenses.json`)

```json
{
  "timestamp": "2026-02-09T12:00:00Z",
  "summary": {
    "totalPackages": 342,
    "licenses": { "MIT": 285, "ISC": 32 },
    "violations": 0,
    "warnings": 2
  },
  "packages": [
    {
      "name": "lodash",
      "version": "4.17.21",
      "license": "MIT",
      "status": "allowed",
      "source": "package.json"
    },
    {
      "name": "mystery-lib",
      "version": "2.0.0",
      "license": null,
      "status": "unknown",
      "source": null
    }
  ],
  "violations": [],
  "warnings": [
    {
      "name": "mystery-lib",
      "version": "2.0.0",
      "reason": "No license field or LICENSE file found"
    }
  ]
}
```

- `status` values: `"allowed"` | `"violation"` | `"unknown"` | `"override"`
- `source` values: `"package.json"` | `"LICENSE file"` | `"override"` | `null`

### TurboRepo integration

Add a `license:check` task to `turbo.json` and a script entry to the root `package.json`:

```json
// package.json
{
  "scripts": {
    "license:check": "bun run tools/license-checker.ts"
  }
}
```

```json
// turbo.json — add to tasks
{
  "license:check": {
    "cache": false
  }
}
```

Cache is disabled because results depend on the current `node_modules` state, not source code.

### License detection priority

1. `overrides` in `license-policy.json` (highest priority)
2. `license` field in `package.json` (string)
3. `licenses` field in `package.json` (deprecated array — take first entry)
4. `LICENSE` / `LICENCE` / `LICENSE.md` / `LICENCE.md` file in package directory (attempt to identify via common patterns)
5. If none found → `"unknown"` with warning

### SPDX expression handling

For compound expressions like `(MIT OR Apache-2.0)`:

- Parse the expression and check if **any** license in the expression is in the allowlist
- If at least one is allowed, the package passes
- Store the full expression in the report for transparency

## Success Criteria

- [ ] `bun run tools/license-checker.ts` scans all `node_modules` and produces correct output
- [ ] CLI table shows summary stats and lists only violations/warnings
- [ ] JSON report written to `reports/licenses.json` with full package data
- [ ] Exit code 0 when no violations, exit code 1 when violations exist
- [ ] `overrides` in `license-policy.json` correctly override detected licenses
- [ ] SPDX compound expressions are handled (OR logic)
- [ ] Unknown licenses produce warnings, not failures
- [ ] Workspace symlinks (project packages) are skipped
- [ ] `turbo run license:check` works as a Turbo task
- [ ] Script has zero external dependencies

## Open Questions

- What should the initial `allowedLicenses` list contain? (To be decided by the team before CI integration)
- Should `reports/licenses.json` be committed or gitignored? (Recommend gitignored — generated artifact)
- Should the script support a `--ci` flag that treats warnings as errors? (Defer to CI integration phase)
