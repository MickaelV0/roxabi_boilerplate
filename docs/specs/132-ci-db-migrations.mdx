---
title: "CI/CD Database Migrations"
description: Automate Drizzle DB migrations in the CI/CD pipeline with drift detection and preview database branching
status: implemented
---

## Context

Database migrations (Drizzle Kit) are not part of the CI/CD pipeline today. When schema changes merge to `main`, Vercel auto-deploys the new code but the database schema is **not updated** — migrations must be run manually. This is error-prone and causes runtime failures when code expects a schema that doesn't exist yet.

**Promoted from:** [CI/CD Database Migrations Strategy](../analyses/132-ci-db-migrations)

**Current state:**

- CI workflow (`ci.yml`): lint → typecheck (includes Drizzle schema validation) → test → build → e2e. No migration step.
- Deploy preview (`deploy-preview.yml`): Vercel build + deploy via `workflow_dispatch`. No migration step.
- Vercel production: auto-deploys on push to `main` via `turbo-ignore`. No migration hook.
- Migration files: `apps/api/drizzle/migrations/` (SQL files from `drizzle-kit generate`).
- Migration command: `bun run db:migrate` (runs `drizzle-kit` via `tsx` wrapper to resolve ESM imports — see PR #139).
- Database: Neon serverless PostgreSQL via `DATABASE_URL`.
- **Resolved**: #106 / PR #139 — drizzle-kit ESM .js extension issue fixed via `tsx` wrapper. All `db:*` scripts now use `tsx node_modules/drizzle-kit/bin.cjs`.

## Goal

Ensure database schema changes are applied **automatically and atomically** with code deployments. Catch schema drift early in PRs. Provide isolated database environments for preview deployments.

## Users &amp; Use Cases

| User | Workflow |
|------|----------|
| **Developer** | Changes Drizzle schema files, runs `db:generate` locally, pushes PR. Expects migrations to run automatically on deploy. |
| **CI/CD system** | Validates migration completeness on PRs (drift check). Runs migrations during production deploy (Vercel build). |
| **DevOps / Lead** | Monitors deploy failures caused by migration issues. Handles manual rollback if a migration is destructive or incorrect. |

## Expected Behavior

### Happy path

#### Phase 1 — Production migrations (Vercel build command)

1. Developer merges PR with schema changes + migration files to `main`.
2. Vercel detects the push and starts building the API project.
3. The `buildCommand` in `apps/api/vercel.json` runs `bun run db:migrate` **before** `turbo run build`.
4. `drizzle-kit migrate` applies any pending migrations to the production Neon database.
5. If no pending migrations exist, the command completes instantly (idempotent).
6. The build proceeds and the new code goes live with the updated schema.

#### Phase 2 — Schema drift detection (CI)

1. Developer opens a PR that modifies files in `apps/api/src/database/schema/`.
2. CI workflow (`ci.yml`) runs a drift detection step.
3. The step compares the current schema TypeScript files against existing migration files.
4. If the schema has changed but no new migration was generated, CI **fails** with an actionable message: _"Schema drift detected. Run `bun run db:generate` locally and commit the migration."_
5. If migrations are in sync, the check passes silently.

#### Phase 3 — Neon branch databases (preview deploys)

1. Developer opens a PR.
2. A GitHub Actions workflow creates a Neon database branch from production.
3. The branch connection string is set as `DATABASE_URL` for the preview deployment.
4. Preview deploy runs migrations against the branch database (isolated from production).
5. When the PR is merged or closed, the Neon branch is deleted automatically.

### Edge cases

| Scenario | Behavior |
|----------|----------|
| Migration fails during Vercel build | Build fails → deploy is blocked → old code continues serving. Failure visible in Vercel dashboard and GitHub commit status. |
| Multiple PRs with migrations merge simultaneously | `drizzle-kit migrate` processes migrations sequentially by index. Conflicts must be resolved manually (re-index migration files). |
| Migration is destructive (DROP TABLE, DROP COLUMN) | Migration runs as-is — no guardrails. Developers must review migration SQL carefully before merging. |
| No pending migrations on deploy | `db:migrate` completes instantly with no changes. Zero overhead. |
| `drizzle-kit check` unavailable or requires DB connection | Fall back to a generate-and-diff approach: generate to a temp directory and compare with existing migrations. |
| Neon API rate limit or failure | Preview deploy proceeds without a branch database. Log a warning but don't block the preview. |
| PR closed without merge | Neon branch is deleted via the cleanup workflow. No orphaned branches. |

## Constraints

- ~~**Dependency on #106**~~: Resolved — PR #139 merged. `drizzle-kit` commands now work reliably via `tsx` wrapper.
- **`tsx` devDependency**: `tsx` must be installed in the Vercel build environment. This is handled automatically since `bun install` includes devDependencies.
- **Neon API access**: Phase 3 requires a Neon API key stored as a GitHub secret (`NEON_API_KEY`).
- **No built-in rollback**: Drizzle Kit does not support down migrations. Rollback is a manual process (apply a corrective migration or revert the commit).
- **Single production database**: All migrations run against the same Neon production instance. No blue-green database strategy.
- **Vercel build environment**: Migrations must work within Vercel's build step (Bun + tsx runtime, network access to Neon).

## Non-goals

- **Automated rollback / down migrations**: Out of scope. Document the manual rollback process instead.
- **Blue-green database deployments**: Not needed at current scale.
- **Migration for non-API projects**: Only `apps/api` has a database. Web project is unaffected.
- **Migration linting or SQL review**: Not automating SQL quality checks beyond drift detection.
- **Database seeding in CI**: Seed data management is a separate concern.

## Technical Decisions

### Vercel build command over GitHub Actions workflow

Run migrations inside Vercel's `buildCommand` rather than a separate GH Actions workflow. This ensures:
- **Zero race condition**: migration and build are atomic — new code only goes live after both succeed.
- **No extra secrets**: `DATABASE_URL` is already in Vercel's environment variables.
- **Simplest change**: one line in `vercel.json`.

**Change to `apps/api/vercel.json`:**

```json
{
  "buildCommand": "bun run db:migrate && turbo run build"
}
```

The web project's `vercel.json` is unchanged — only the API project runs migrations.

### Drift detection via drizzle-kit

CI already has a "Validate Drizzle schema loading" step (added in PR #139) that runs `bun run db:generate` with a dummy `DATABASE_URL` to verify schema files parse correctly. This validates syntax but does **not** detect drift (missing migration files).

Add a **separate** drift detection step to `ci.yml`:

- Preferred: `drizzle-kit check` (if it works without a live DB connection).
- Fallback: Generate migrations to a temp directory and diff against `drizzle/migrations/`. Since PR #139 already runs `db:generate` with a dummy URL, this approach is proven to work in CI.
- Only runs when `apps/api/src/database/schema/**` files are modified (use path filter).

### Neon database branching

Use the [Neon API](https://api-docs.neon.tech/) to manage branch databases:

- **Create branch**: On PR open or `deploy-preview` trigger.
- **Set `DATABASE_URL`**: Pass the branch connection string to the Vercel preview deploy.
- **Run migrations**: As part of the preview build (same `buildCommand` mechanism).
- **Delete branch**: On PR close/merge via a cleanup job.

Requires:
- `NEON_API_KEY` GitHub secret.
- `NEON_PROJECT_ID` GitHub variable (or secret).
- Neon branch naming convention: `preview/pr-{number}`.

## Success Criteria

- [ ] Production migrations run automatically on every push to `main` (via Vercel build)
- [ ] Migration failure blocks the deployment (build fails, old code stays live)
- [ ] `drizzle-kit migrate` is idempotent (safe to re-run with no pending migrations)
- [ ] Schema drift is detected on PRs when migration files are missing
- [ ] Drift check CI step fails with an actionable error message
- [ ] Preview deploys use isolated Neon branch databases
- [ ] Neon branches are cleaned up when PRs are closed or merged
- [ ] Manual rollback process is documented

## Open Questions

1. **Does `drizzle-kit check` work without a live database connection?** PR #139 proved `db:generate` works with a dummy `DATABASE_URL` in CI, so the generate-and-diff fallback is viable. Investigate if `drizzle-kit check` also works this way.
2. **Neon API key provisioning**: Who creates the API key and adds it as a GH secret? Is there a shared Neon account or per-developer access?
3. **Concurrent migrations**: If two PRs merge to `main` simultaneously, can `drizzle-kit migrate` handle the race? (Likely yes — it uses a migrations journal table with sequential ordering, but worth verifying.)
4. **Vercel build timeout**: Does running `db:migrate` before `turbo run build` risk hitting Vercel's build timeout? (Unlikely — migrations are fast, but worth monitoring.)
5. **Phase 3 cost**: Neon branch databases have compute costs. What's the budget consideration for many open PRs?
