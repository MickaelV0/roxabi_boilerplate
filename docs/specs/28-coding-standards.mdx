---
title: "Coding Standards & Best Practices"
description: Specification for documenting coding standards, testing workflow, code review guidelines, and testing patterns
---

## Overview

Create 4 standards documents + 1 AI agent rule file that codify existing codebase patterns and fill documentation gaps. These serve as actionable references for developers and AI agents alike.

**Approach**: Option C (Balanced) from [analysis](/docs/analyses/28-coding-standards), refined by a [challenge review](#challenge-review-decisions) that validated patterns against 2025-2026 best practices and corrected 17 items.

## Goals

- Codify implicit coding patterns already used in the codebase
- Document testing workflow and philosophy (currently undocumented)
- Establish code review guidelines (currently missing)
- Catalog testing patterns per layer with real examples
- Make standards AI-agent consumable (compressed rules in `.claude/processes/`)

## Files to Create

| File | Est. Lines | Purpose |
|------|-----------|---------|
| `docs/standards/meta.json` | ~10 | Navigation config |
| `docs/standards/frontend-patterns.mdx` | ~150 | React/TanStack: hooks, components, error boundaries, code org |
| `docs/standards/backend-patterns.mdx` | ~150 | NestJS: DI, modules, filters, middleware, code org |
| `docs/standards/testing.mdx` | ~250 | Testing philosophy (Trophy), TDD cycle, per-layer patterns, mocks, coverage |
| `docs/standards/code-review.mdx` | ~200 | Checklist, security, Conventional Comments, approval criteria |
| `.claude/processes/coding-standards.md` | ~80 | Compressed AI-agent rules (no examples, just imperatives) |

## Files to Update

| File | Change |
|------|--------|
| `docs/meta.json` | Add `standards` section to navigation |
| `CLAUDE.md` | Add reference to standards docs + AI rules file in Documentation table |

---

## Document 1: Frontend Patterns

**File**: `docs/standards/frontend-patterns.mdx`

### TypeScript Preamble (~20 lines)

Short section covering shared TypeScript rules (link to backend doc for full overlap):

**Type safety patterns**:

| Pattern | Example | Source |
|---------|---------|--------|
| Const assertions | `const LOCALES = ['en', 'fr'] as const` | `types.ts` |
| Derived unions | `type Locale = (typeof LOCALES)[number]` | `types.ts` |
| Type guards | `function isValidLocale(s): s is Locale` | `server.ts` |
| Assertion functions | `function assertLocale(s): asserts s is Locale` | (new pattern to adopt) |
| `satisfies` validation | `config satisfies Record&lt;Locale, ...>` | (new pattern to adopt) |
| `as const satisfies` | Validated literals: `['en', 'fr'] as const satisfies readonly string[]` | (new pattern to adopt) |
| Generic responses | `ApiResponse&lt;T>` (discriminated union preferred) | `packages/types` |
| Mapped types | `Record&lt;Locale, { native: string; english: string }>` | `LanguageSwitcher.tsx` |
| Type-only imports | `import type { Locale }` | Enforced by Biome |
| Template literal types | `type LocalizedRoute = \`/\${Locale}/\${string}\`` | (new pattern to adopt) |

**Anti-patterns**: `any` (use `unknown`), `!` (use null checks / optional chaining / assertion functions), `as X` (use `satisfies` for validation or type guards for narrowing)

**`type` vs `interface`**: Use `type` as default for props and data shapes (prevents declaration merging, supports unions). Use `interface extends` when composing deep type hierarchies for compiler performance.

**Auto-enforced**: Reference `biome.json` + `tsconfig.json` — don't repeat rules.

### Sections

#### 1.1 Code Organization

Feature structure template:
```
lib/feature/
├── types.ts        # Type definitions
├── hooks.ts        # React hooks
├── client.ts       # Client-side utilities
├── server.ts       # Server-side utilities (createServerFn)
└── __tests__/      # Tests (alternative to colocated)
```

Rules:
- **No barrel files in app code** — import directly from source files (`@/lib/i18n/hooks`, not `@/lib/i18n`)
- Barrel files are allowed only in `packages/*/src/index.ts` (public API boundary for shared packages)
- Client/server separation for isomorphic features
- Hooks in dedicated file, not mixed with utilities
- Follow TanStack Start conventions: `$param` for dynamic route segments, `_` prefix for pathless layouts

#### 1.2 Design Patterns

| Pattern | Example File | Description |
|---------|-------------|-------------|
| Hook Composition | `hooks.ts` | `useTranslation`, `useLocale` — focused, single-purpose hooks |
| Companion Hook | `LanguageSwitcher.tsx` | `useLanguageSwitcher` co-located with its component |
| Error Boundary | `react-error-boundary` package | `&lt;ErrorBoundary>` with `fallbackRender` + `useErrorBoundary()` hook |
| Component Composition | `LanguageSwitcher.tsx` | Variant props + companion hook |
| Module Namespace | `i18n/` directory | Related files in dedicated directory |

Design principles (React vocabulary):
- **Focused hooks**: Each hook does one thing (`useLocale` reads locale, `useTranslation` translates)
- **Minimal props**: Props types include only what the component needs (`ButtonProps`, `LanguageSwitcherProps`)
- **Extension via composition**: Components support variants without internal modification (`variant?: 'dropdown' | 'buttons'`)
- If a component accumulates more than 4-5 configuration props, consider refactoring to a compound component pattern

#### 1.3 Error Handling

Document existing patterns:
- Error boundaries via `react-error-boundary` package at route/feature level
- `null` return for graceful degradation (e.g., `getLocaleFromPath`)
- `console.warn` for non-critical failures (e.g., missing translations)
- Try/catch in hooks with `undefined` fallback (`useI18nContext`)

Rules:
- Use `react-error-boundary` — no hand-written class components for error boundaries
- React 19: errors in `useTransition` async callbacks automatically propagate to error boundaries
- Utility/UI helpers may return `null`/`undefined` for failures
- For business logic, consider Result types (discriminated unions) for forced error handling
- Never throw from functions called during rendering

#### 1.4 Component Patterns

- Functional components only — no exceptions (class components eliminated by `react-error-boundary`)
- Props type as `type` (not `interface`) with PascalCase + `Props` suffix
- Extract logic into companion hooks when component grows complex
- Use named exports, never default exports (exception: follow framework conventions where required)
- Variant pattern for multi-mode components (`variant?: 'dropdown' | 'buttons'`)
- React Compiler handles memoization — do not add manual `React.memo`, `useMemo`, or `useCallback` unless profiling proves it necessary

---

## Document 2: Backend Patterns

**File**: `docs/standards/backend-patterns.mdx`

### TypeScript Preamble (~20 lines)

Same shared TypeScript rules as frontend doc (link rather than duplicate), plus backend-specific additions:

| Pattern | Example | Source |
|---------|---------|--------|
| Symbol injection tokens | `const DRIZZLE = Symbol('DRIZZLE')` | `drizzle.provider.ts` |
| Decorator validation | `@IsEnum()`, `@IsString()`, `@IsOptional()` | `env.validation.ts` |

**Note on `class-validator`**: Currently used for environment validation. `class-validator` is effectively in maintenance mode — plan to migrate to Zod when validation needs grow beyond env config. For new DTO validation, prefer Zod with a custom `ZodValidationPipe`.

### Sections

#### 2.1 Code Organization

Module structure template:
```
feature/
├── feature.module.ts      # NestJS module registration
├── feature.controller.ts  # HTTP routes
├── feature.service.ts     # Business logic
├── exceptions/            # Domain exception classes (pure TS, no NestJS imports)
├── dto/                   # Request/response types
├── entities/              # Database schemas
└── feature.test.ts        # Colocated tests
```

Rules:
- One module per domain feature
- Controllers handle HTTP only — delegate to services
- Providers for infrastructure (database, external APIs)
- **No barrel files** in application code — import directly from source files
- Barrel exports allowed only in `common/index.ts` for cross-cutting concerns shared across modules

#### 2.2 Design Patterns

| Pattern | Example File | Description |
|---------|-------------|-------------|
| Dependency Injection | `drizzle.provider.ts` | Symbol tokens + `useFactory` |
| Factory | `drizzle.provider.ts` | `useFactory` creates instances from config |
| Middleware | (to migrate from `correlation-id.interceptor.ts`) | Request-level pre-processing (correlation IDs, logging) |
| Exception Filter | `all-exceptions.filter.ts` | Global fallback error formatting |
| Domain Exception Filter | (to create) | Maps domain exceptions → HTTP responses |
| Lifecycle Hook | `database.module.ts` | `OnModuleDestroy` for cleanup |

Design principles (backend vocabulary):
- **Focused providers**: `AllExceptionsFilter` only formats errors, correlation ID middleware only adds IDs
- **Extension via modules**: Add new providers/modules without modifying existing ones
- **Interface contracts**: Filters implement `ExceptionFilter`, interceptors implement `NestInterceptor`
- **Dependency inversion**: `DatabaseModule` injects via `DRIZZLE` Symbol token, not concrete postgres instance

**NestJS lifecycle ordering** (critical for understanding where to place cross-cutting concerns):
Middleware → Guards → Interceptors → Pipes → Handler → Interceptors (response) → Filters (on error)

#### 2.3 Error Handling

**Layered exception architecture:**

1. **Domain exceptions** (pure TypeScript, no NestJS imports):
```typescript
// feature/exceptions/user-not-found.exception.ts
export class UserNotFoundException extends Error {
  constructor(public readonly userId: string) {
    super(`User ${userId} not found`)
  }
}
```

2. **Domain-to-HTTP mapping filter**:
```typescript
@Catch(UserNotFoundException)
export class UserNotFoundFilter implements ExceptionFilter {
  catch(exception: UserNotFoundException, host: ArgumentsHost) {
    // Map to 404 with structured response
  }
}
```

3. **`AllExceptionsFilter`** remains as the global fallback for truly unexpected errors

Structured response format: `{ statusCode, timestamp, path, correlationId, message }`

**Forward-looking**: Consider RFC 9457 (Problem Details for HTTP APIs) format before public API release. Adds `type` (URI for error class) and `detail` (specific occurrence) fields.

Rules:
- Services throw **domain exceptions** (pure TS `Error` subclasses, no NestJS imports)
- Controllers and filters map domain exceptions to HTTP responses
- Never throw raw untyped `Error` — use typed domain exception classes
- Always include correlation ID in error logs
- Validate all input at controller boundary (ValidationPipe + DTOs)

#### 2.4 Provider & Module Patterns

- Use `Symbol()` for injection tokens (not strings)
- Global modules only for read-only infrastructure (`@Global()` on `DatabaseModule`, `ConfigModule`). Feature modules must never be `@Global()`
- `useFactory` + `inject` for providers that depend on config
- `ConfigurableModuleBuilder` for modules needing `forRoot()`/`forRootAsync()` patterns
- Handle nullable dependencies (`PostgresClient | null` pattern)
- Implement lifecycle hooks: `OnModuleDestroy` for resource cleanup, `BeforeApplicationShutdown` for graceful drain

#### 2.5 Correlation ID

- Implement as **middleware** (not interceptor) so the ID is available before guards and interceptors
- Generate UUID if no `x-correlation-id` header present; reuse incoming header if present
- Set on request and response headers
- Future enhancement: consider `nestjs-cls` (AsyncLocalStorage) for propagating correlation ID through async chains without parameter passing

---

## Document 3: Testing (merged TDD + Testing Patterns)

**File**: `docs/standards/testing.mdx`

### Sections

#### 3.1 Testing Philosophy — The Testing Trophy

Adopt the Testing Trophy model (not the traditional pyramid):

```
        /  E2E  \         ← Small: critical user flows only
       / Integr. \        ← LARGEST: real modules working together
      /   Unit    \       ← Focused: pure functions, utilities
     / Static Anal.\      ← Foundation: TypeScript strict + Biome
```

- **Static Analysis** (foundation): TypeScript strict mode + Biome catch a huge class of bugs automatically. This is the foundation — not a separate "testing" activity.
- **Unit Tests**: For pure functions, utilities, type guards. Fast and focused.
- **Integration Tests** (largest layer): NestJS `Test.createTestingModule()` for backend, Testing Library with real hooks/context for frontend. These provide the most confidence.
- **E2E Tests**: Playwright for critical user journeys. Expensive to set up — test workflows, not individual behaviors.

#### 3.2 Red-Green-Refactor Cycle

Step-by-step with a concrete example (writing a new NestJS service test):

1. **Red**: Write a failing test that describes the expected behavior
2. **Green**: Write the minimum code to make the test pass
3. **Refactor**: Clean up while keeping tests green (most commonly skipped — emphasize this step)

Include a small walkthrough example (creating a `UserService.findById` with test-first approach).

Note: "Test-after" is acceptable for exploratory/prototyping work, but proper tests must exist before merge.

#### 3.3 Test Structure (AAA Pattern)

Document the Arrange-Act-Assert pattern as the standard:

```typescript
import { describe, it, expect } from 'vitest'

it('should handle HttpException with string response', () => {
  // Arrange
  const { host, statusFn, getSentBody } = createMockHost()
  const exception = new HttpException('Not found', HttpStatus.NOT_FOUND)

  // Act
  filter.catch(exception, host as never)

  // Assert
  expect(statusFn).toHaveBeenCalledWith(404)
  expect(getSentBody().message).toBe('Not found')
})
```

Note: Existing tests follow AAA structure implicitly. The `// Arrange/Act/Assert` comments are the new standard for clarity.

Rules:
- One behavior per test (for unit tests). For integration/E2E tests, testing a coherent user scenario in a single test is acceptable.
- Descriptive test names (`should X when Y`)
- Prefer explicit factory/helper functions for test-specific setup. Use `beforeEach` for shared teardown and mock resets only. Avoid mutable variables assigned in `beforeEach` that are later read in tests.
- Don't test private methods directly — if a private method is too complex to test through the public API, extract it into a separate module (this signals an SRP violation)

#### 3.4 Test Organization

- **Naming**: `.test.ts` for unit/integration, `.spec.ts` for E2E (Playwright)
- **Location**: Colocated with source (same directory) as default. `__tests__/` subdirectory for test helpers and fixtures.
- **Config**: Per-package Vitest configs extending `vitest.shared.ts`
- **Environments**: `node` for backend, `jsdom` for frontend/UI (consider `happy-dom` for speed-sensitive utility tests)
- **Imports**: Use explicit imports — `import { describe, it, expect, vi } from 'vitest'` (not `globals: true`)

#### 3.5 Coverage Guidelines

- **Threshold**: 80% (lines, functions, branches, statements) — raised from 70%
- **Ratcheting**: Enable `thresholds.autoUpdate: true` in Vitest config to prevent coverage regression
- **Provider**: V8 with text/json/html reporters
- **Exclusions**: Infrastructure files, generated code, framework bootstrap (list from `vitest.config.ts`)
- **Per-directory thresholds**: Business logic modules aim for 90%+, framework glue code 80%, generated/config files excluded

#### 3.6 Backend Testing Patterns

**Filter/Interceptor/Middleware testing** (from `all-exceptions.filter.test.ts`):
- Direct instantiation (no NestJS test module needed for unit tests)
- Factory helpers for mock objects: `createMockHost()`, `createMockContext()`
- Test both happy path and error paths
- Verify response structure matches API contract

**Provider/Factory testing** (from `drizzle.provider.test.ts`):
- Mock `ConfigService` with `createMockConfig()`
- Test factory `useFactory` functions directly
- Verify null handling for optional dependencies

**When to use `Test.createTestingModule()`** (integration tests — the largest layer):
- Testing multiple providers working together
- Testing module initialization and lifecycle hooks
- Testing dependency injection wiring

#### 3.7 Frontend Testing Patterns

**Setup** (from `apps/web/src/test/setup.ts`):
- `@testing-library/jest-dom/vitest` for DOM matchers
- Automatic `cleanup()` after each test
- `jsdom` environment

**Component testing** (from `packages/ui`):
- `render()` + `screen` queries for finding elements
- **Role-based selectors first**: `getByRole('button', { name: 'Submit' })`, `getByLabel('Email')`, `getByText('Welcome')`
- `data-testid` as **last resort** when no semantic selector works
- `fireEvent` / `userEvent` for interaction
- Assert on visible text, roles, and attributes (not DOM structure)

**Utility testing** (from `i18n/__tests__/server.test.ts`):
- Comprehensive edge case testing (null, empty, invalid)
- Group tests by function under `describe` blocks
- Type guard testing with valid and invalid inputs

#### 3.8 E2E Testing Patterns

**Configuration** (from `playwright.config.ts`):
- Base URL: `http://localhost:3000`
- Reuse existing dev server locally, start fresh in CI (`reuseExistingServer: !process.env.CI`)
- HTML reporter, trace on first retry
- Parallel execution enabled

**Test structure**:
```typescript
test.describe('Feature Name', () => {
  test('should perform user action', async ({ page }) => {
    await page.goto('/path')
    await page.getByRole('button', { name: 'Submit' }).click()
    await expect(page).toHaveTitle(/Expected/)
  })
})
```

**Selector priority** (same as component tests):
1. `page.getByRole()` — validates accessibility
2. `page.getByLabel()` — for form inputs
3. `page.getByText()` — for content
4. `page.getByTestId()` — last resort

**Recommended patterns**:
- Page Object Model for complex pages (evolve to Component Page Object Model as shared UI elements emerge)
- Fixtures for authenticated state
- Do NOT put assertions inside page objects — keep them in tests

#### 3.9 Mocking Strategies

**Factory helper pattern** (preferred):
```typescript
import { vi } from 'vitest'

function createMockHost(headers: Record&lt;string, string> = {}) {
  const sendFn = vi.fn()
  const statusFn = vi.fn().mockReturnValue({ send: sendFn })
  // ... return structured mock
  return { host, statusFn, getSentBody }
}
```

Rules:
- Use factory functions with `Partial&lt;T>` overrides for test-specific setup
- Keep mocks close to tests (in same file or `__tests__/helpers/`)
- **Backend**: Prefer DI over module mocking. Use `vi.fn()` for mock implementations passed through DI. Avoid `vi.mock()` entirely.
- **Frontend**: Prefer `vi.fn()` + `vi.spyOn()`. Use `vi.mock()` when mocking third-party modules that can't be injected.
- Use `vi.spyOn()` for observing behavior without replacing it (integration tests)
- Use `vi.stubEnv()` for environment variables

#### 3.10 Test Data Management

- **Inline data**: For simple, self-contained tests
- **Factory functions**: For complex entities (future `createTestUser()`)
- **Fixtures**: JSON files for large datasets (in `__tests__/fixtures/`)
- **Database**: Use Testcontainers (`testcontainers` npm package) for integration tests with real PostgreSQL
- **Cleanup**: Each test responsible for its own data (no shared state)

#### 3.11 AI-Assisted TDD Workflow

How to use Claude Code for test-first development:

1. Describe the feature/function you need
2. Ask Claude to write the test first (explicitly say "write the test FIRST, do not create implementation code")
3. Review the test — does it capture the right behavior? (most critical step)
4. Ask Claude to implement the code to pass the test
5. Run `bun run test` to verify
6. Refactor together
7. **Validate**: Human reviews both tests and implementation to ensure tests capture intended behavior, not just "approval tests" of whatever was produced

Tips:
- Provide context files (existing tests, types) for consistent patterns
- Ask for edge cases after the happy path
- Use the `/interview` skill for complex feature specs before TDD
- Watch for circular validation: Claude writes test → Claude writes code that passes → but does the test actually capture the requirement?

#### 3.12 Advanced Testing (Brief Mentions)

**Property-based testing** (fast-check): For utility functions, validators, and type guards — generate thousands of random inputs to catch edge cases. One property test can replace dozens of manual edge case tests.

**Mutation testing** (Stryker): For critical business logic — verifies tests catch real mutations. Run on core packages only, not project-wide. Use incremental mode for CI.

**Contract testing** (Pact): When frontend and backend API integration is established — consumer-driven contracts catch API breaking changes faster than E2E tests.

**Snapshot testing**: Intentionally not recommended for UI components (leads to blind updates, couples to DOM structure). Inline snapshots (`toMatchInlineSnapshot()`) are acceptable for small data structures.

---

## Document 4: Code Review Guidelines

**File**: `docs/standards/code-review.mdx`

### Sections

#### 4.1 Review Checklist

Categorized checklist for reviewers:

**Correctness**:
- [ ] Logic handles edge cases (null, empty, invalid input)
- [ ] Error paths are handled (error boundaries, domain exceptions, filters)
- [ ] Types are correct (no `any`, no unsafe `as` assertions — use `satisfies`)
- [ ] API contracts match (request/response types, discriminated unions)

**Security**:
- [ ] No secrets in code (API keys, tokens, passwords — use env vars)
- [ ] No secrets in error messages or logs
- [ ] User input validated (class-validator/Zod on DTOs, type guards on frontend)
- [ ] No SQL injection — verify no `sql.raw()` with user-supplied input (Drizzle query builder and `sql` tagged templates are safe; `sql.raw()` is NOT)
- [ ] No XSS vectors:
  - No `dangerouslySetInnerHTML` without DOMPurify sanitization
  - No `javascript:` or `data:` URLs in `href`/`src` attributes
  - No `eval()`, `Function()`, or direct `innerHTML` usage
  - User-supplied data in route params sanitized before rendering
- [ ] CORS configured with explicit origin allowlist (never `*` in production)
- [ ] Auth guards applied to protected endpoints (`@UseGuards()`)
- [ ] Rate limiting on public-facing endpoints (`@nestjs/throttler`)
- [ ] Sensitive tokens stored in `httpOnly` cookies, not `localStorage`

**Performance**:
- [ ] React Compiler is enabled — no manual `React.memo`/`useMemo`/`useCallback` unless profiling proves it necessary
- [ ] Components follow Rules of React (pure render, immutable props/state, no side effects in render)
- [ ] No N+1 queries — check for queries inside loops, missing joins
- [ ] No blocking operations in hot paths
- [ ] New dependencies justified — check bundle size impact
- [ ] Route-level code splitting / lazy loading for new routes
- [ ] No memory leaks — uncleared intervals, event listeners, `useEffect` without cleanup

**Architecture**:
- [ ] Follows module structure (see frontend-patterns.mdx / backend-patterns.mdx)
- [ ] No circular dependencies
- [ ] Shared types in `packages/types`, not duplicated
- [ ] Uses existing patterns (DI, hooks, direct imports)
- [ ] No barrel files in application code
- [ ] Services throw domain exceptions (not HttpException directly)

**Tests**:
- [ ] New public functions have tests
- [ ] Tests cover happy path + at least one error path
- [ ] Tests use explicit `import { describe, it, expect } from 'vitest'`
- [ ] No flaky assertions (no timing-dependent tests)
- [ ] Mocks use factory helpers, not inline complex objects
- [ ] Selectors use `getByRole`/`getByLabel`/`getByText` first, `data-testid` last

**Readability**:
- [ ] Code is understandable without extensive comments
- [ ] Naming is clear and consistent
- [ ] No over-engineering or speculative abstractions

**Observability**:
- [ ] New endpoints have structured logging
- [ ] Error paths include correlation IDs
- [ ] External service calls have timeout and retry configuration

**PR Size**:
- [ ] PR is under ~400 lines changed (excluding auto-generated files, lock files, test fixtures)
- [ ] If over 400 lines, justified by atomic feature that cannot be split

#### 4.2 Review Criteria by Layer

| Layer | Focus Areas |
|-------|-------------|
| **Backend (NestJS)** | DI correctness, domain exception usage, DTO validation, SQL safety (`sql.raw()` check), middleware ordering |
| **Frontend (React)** | Hook rules, component props, error boundaries, a11y (semantic HTML, ARIA), React Compiler compatibility |
| **Shared packages** | Backward compatibility, type exports, no runtime dependencies, barrel file is the only entry point |
| **Tests** | AAA structure, role-based selectors, meaningful assertions, no implementation coupling, explicit imports |
| **Documentation** | Frontmatter present, MDX valid, meta.json updated |
| **Database migrations** | No destructive operations without review, indexes for new query patterns, reversible migrations |

#### 4.3 Feedback Guidelines — Conventional Comments

Adopt [Conventional Comments](https://conventionalcomments.org/) for all code review feedback:

**Labels:**

| Label | Usage | Example |
|-------|-------|---------|
| `praise:` | Highlight something positive | `praise: Great use of the factory helper pattern here!` |
| `nitpick:` | Trivial, preference-based | `nitpick: Prefer `const` over `let` here.` |
| `suggestion:` | Proposes improvement | `suggestion: Consider using a discriminated union for this response type.` |
| `issue:` | Highlights a specific problem | `issue: This `sql.raw()` call with user input is a SQL injection vector.` |
| `question:` | Invites clarification | `question: Why is this module marked as @Global()? It seems feature-specific.` |
| `thought:` | Non-blocking idea | `thought: A factory helper would make this test more readable.` |
| `todo:` | Small required change | `todo: Add the missing correlation ID to this error log.` |

**Decorators:**

| Decorator | Meaning |
|-----------|---------|
| `(blocking)` | Must resolve before merge |
| `(non-blocking)` | Should not prevent acceptance |

Example: `suggestion(blocking): This needs a domain exception instead of throwing HttpException directly.`

**Tone guidelines:**
- Security issues and correctness bugs are direct statements, not suggestions
- Suggest for style and approach; be direct about correctness and security
- Frame feedback as: "This code has X issue" not "You wrote X wrong"

#### 4.4 Approval Criteria

| Condition | Action |
|-----------|--------|
| All checks pass + no blocking comments | Approve |
| Minor nitpicks only | Approve with comments |
| Missing tests for new logic | Request changes |
| Security concern | Block until resolved |
| Architecture violation (documented standard) | Block + discuss approach |
| Architecture preference (undocumented) | Discuss and document the pattern, don't block |

---

## AI Agent Rules File

**File**: `.claude/processes/coding-standards.md`

Compressed rule extract (~80 lines) for Claude Code consumption. No examples, no rationale — just imperative rules. Content derived from the 4 standards documents above.

Structure:
```markdown
## TypeScript
- [compressed rules from preamble sections]

## Frontend
- [compressed rules from frontend-patterns.mdx]

## Backend
- [compressed rules from backend-patterns.mdx]

## Testing
- [compressed rules from testing.mdx]

## Code Review
- [compressed rules from code-review.mdx]
```

Referenced from `CLAUDE.md` Documentation table as: `Coding standards (AI) | [.claude/processes/coding-standards.md]`

---

## Navigation Setup

### `docs/standards/meta.json`

```json
{
  "title": "Standards",
  "pages": [
    "frontend-patterns",
    "backend-patterns",
    "testing",
    "code-review"
  ]
}
```

### `docs/meta.json` update

Add `standards` entry after existing sections (between `guides` and `analyses`, or as appropriate).

### `CLAUDE.md` update

Add to Documentation table:

| Topic | Documentation |
|-------|---------------|
| Coding standards | [docs/standards/](docs/standards/) |
| Coding standards (AI) | [.claude/processes/coding-standards.md](.claude/processes/coding-standards.md) |

---

## Acceptance Criteria

- [ ] 4 MDX documents created in `docs/standards/`
- [ ] 1 AI rules file created in `.claude/processes/`
- [ ] `meta.json` created for standards section navigation
- [ ] `docs/meta.json` updated with standards section
- [ ] `CLAUDE.md` references both standards docs and AI rules file
- [ ] All code examples reference actual project files (verified against codebase)
- [ ] No duplication of Biome/TypeScript auto-enforced rules
- [ ] `bun docs` renders all 4 pages correctly
- [ ] Standards are prescriptive ("Do X", not "Consider X")
- [ ] Anti-patterns included where relevant
- [ ] React Compiler setup documented or created as prerequisite task

## Implementation Checklist

- [ ] Create `docs/standards/meta.json`
- [ ] Create `docs/standards/frontend-patterns.mdx`
  - [ ] TypeScript preamble (type safety, satisfies, anti-patterns, auto-enforced rules)
  - [ ] Code organization (feature structure, no barrel files in app code)
  - [ ] Design patterns (hooks, react-error-boundary, composition)
  - [ ] Error handling (boundaries, null returns, Result types for business logic)
  - [ ] Component patterns (functional only, React Compiler, variants)
- [ ] Create `docs/standards/backend-patterns.mdx`
  - [ ] TypeScript preamble (symbols, decorators, class-validator/Zod note)
  - [ ] Code organization (module structure, no barrel files)
  - [ ] Design patterns (DI, factory, middleware, filter, lifecycle)
  - [ ] Error handling (domain exceptions → HTTP mapping, AllExceptionsFilter as fallback)
  - [ ] Provider & module patterns (symbols, @Global constraints, ConfigurableModuleBuilder)
  - [ ] Correlation ID as middleware with lifecycle ordering
- [ ] Create `docs/standards/testing.mdx` (merged TDD + testing patterns)
  - [ ] Testing Trophy philosophy
  - [ ] Red-Green-Refactor with walkthrough
  - [ ] AAA pattern with explicit comments (new standard)
  - [ ] Test organization (naming, location, explicit Vitest imports)
  - [ ] Coverage: 80% + ratcheting
  - [ ] Backend testing patterns
  - [ ] Frontend testing patterns (role-based selectors first)
  - [ ] E2E testing patterns (Playwright, POM, corrected config description)
  - [ ] Mocking strategies (DI for backend, vi.mock for frontend third-party)
  - [ ] Test data management (Testcontainers for DB)
  - [ ] AI-assisted TDD with validation step
  - [ ] Advanced testing brief mentions (property-based, mutation, contract, snapshot omission)
- [ ] Create `docs/standards/code-review.mdx`
  - [ ] Expanded review checklist (correctness, security, performance, architecture, tests, readability, observability, PR size)
  - [ ] Full security expansion (sql.raw, XSS vectors, CORS, auth, rate limiting)
  - [ ] React Compiler memoization guidance (not manual)
  - [ ] Per-layer review criteria (including migrations, a11y)
  - [ ] Conventional Comments (labels + decorators)
  - [ ] Approval criteria with documented-vs-undocumented architecture distinction
- [ ] Create `.claude/processes/coding-standards.md`
  - [ ] Compressed rules from all 4 standards documents
  - [ ] ~80 lines, imperatives only, no examples
- [ ] Update `docs/meta.json` navigation
- [ ] Update `CLAUDE.md` documentation table (both references)

## Prerequisites / Related Tasks

- [ ] **React Compiler setup**: Configure `babel-plugin-react-compiler` via Vite React plugin in TanStack Start
- [ ] **Correlation ID migration**: Move from interceptor to middleware (code change)
- [ ] **Vitest globals migration**: Remove `globals: true`, add explicit imports to existing tests
- [ ] **Coverage threshold update**: Raise from 70% to 80% in `vitest.config.ts`, enable `autoUpdate`
- [ ] **Biome rule**: Enable `noBarrelFile` for `apps/` directories
- [ ] **Domain exceptions**: Create base domain exception pattern in `apps/api/src/common/exceptions/`

## Challenge Review Decisions

This spec was refined through a systematic challenge review against 2025-2026 best practices. 17 items were identified and resolved:

| # | Decision | Category |
|---|----------|----------|
| 1 | Barrel files: packages only, banned in app code | Critical |
| 2 | Domain exceptions in services, HTTP mapping in filters | Critical |
| 3 | Correlation ID: middleware, not interceptor | Critical |
| 4 | Security checklist: full expansion (sql.raw, XSS, CORS, auth, rate limiting) | Critical |
| 5 | React Compiler adoption, remove manual memoization | Critical |
| 6 | 4 docs + AI file (merged TDD+testing, kept frontend/backend separate) | Important |
| 7 | `satisfies` operator as first-class TypeScript pattern | Important |
| 8 | Coverage: 80% + ratcheting (from 70%) | Important |
| 9 | Role-based selectors first, data-testid as last resort | Important |
| 10 | Conventional Comments (from nit/suggestion/blocker) | Important |
| 11 | `react-error-boundary` package (from hand-written class) | Important |
| 12 | Testing Trophy model (from implicit pyramid) | Important |
| 13 | Explicit Vitest imports (from globals: true) | Important |
| 14 | Fix 3 factual errors (file references, Playwright config) | Minor |
| 15 | Add brief mentions: property testing, Testcontainers, contract testing, PR size, assertion functions, template literals, discriminated unions | Minor |
| 16 | Add `type` vs `interface` rationale | Minor |
| 17 | React-native vocabulary, SOLID as supplementary | Minor |

## Dependencies

**Blocked by**: None (blocker #8 CI/CD is closed)

**Blocks**: #12 (Claude Code Agents — needs standards for agent reference)

## References

- [Analysis: Issue #28](/docs/analyses/28-coding-standards)
- [Dev Process](.claude/processes/dev-process.md)
- [Contributing Guide](/docs/contributing)
- [Testing Infrastructure Spec](/docs/specs/09-testing-infrastructure)
- [Conventional Comments](https://conventionalcomments.org/)
- [Testing Trophy (Kent C. Dodds)](https://kentcdodds.com/blog/the-testing-trophy-and-testing-classifications)
- [React Compiler](https://react.dev/blog/2025/10/07/react-compiler-1)
- [react-error-boundary](https://www.npmjs.com/package/react-error-boundary)
- [RFC 9457: Problem Details for HTTP APIs](https://www.rfc-editor.org/rfc/rfc9457)
