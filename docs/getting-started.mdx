---
title: Getting Started
description: Quick start guide to use the Roxabi Boilerplate
---

Quick start guide to use the Roxabi Boilerplate.

## Prerequisites

- [Bun](https://bun.sh/) >= 1.3
- [Git](https://git-scm.com/)
- [GitHub CLI](https://cli.github.com/) (`gh`)
- [Docker](https://www.docker.com/) (for local PostgreSQL)
- [Claude Code](https://claude.ai/claude-code) (optional but recommended)

## 1. Create the Project

### Clone the boilerplate

```bash
# Option A: Direct clone (to contribute to the boilerplate)
git clone https://github.com/MickaelV0/roxabi_boilerplate.git my-project
cd my-project

# Option B: Use as template (for a new project)
gh repo create my-project --template MickaelV0/roxabi_boilerplate --private
gh repo clone my-project
cd my-project
```

### Configure the remote (if direct clone)

```bash
# Remove the boilerplate's origin remote
git remote remove origin

# Create your own GitHub repo
gh repo create my-project --private --source=. --push
```

## 2. Configure GitHub Project

### Create the project

```bash
# Create a GitHub project to track issues and PRs
gh project create --owner @me --title "My Project"
```

### Enable auto-add

1. Go to https://github.com/users/YOUR_USERNAME/projects/N/settings
2. In **Workflows** > **Auto-add to project**
3. Enable the workflow
4. Configure the filter: `is:issue,pr repo:YOUR_USERNAME/my-project`
5. Save

Or via API:
```bash
# List projects to find the ID
gh project list --owner @me

# The auto-add workflow must be configured via GitHub UI
# as the API doesn't support this feature yet
```

### Configure project columns

Recommended columns:
- **Backlog** - Issues to prioritize
- **Todo** - Ready to be picked up
- **In Progress** - Currently being developed
- **In Review** - PR open, awaiting review
- **Done** - Completed

### Add custom fields

In the project settings, add:

| Field | Type | Values |
|-------|------|--------|
| Priority | Single select | P1, P2, P3 |
| Size | Single select | XS, S, M, L, XL |
| Sprint | Iteration | 2 weeks |

## 3. Configure Labels

Labels are already created if you use the template. Otherwise:

```bash
# Type labels
gh label create setup --color "0E8A16" --description "Infrastructure & setup"
gh label create feature --color "A2EEEF" --description "New feature"
gh label create bug --color "D73A4A" --description "Bug fix"
gh label create dx --color "1D76DB" --description "Developer Experience"
gh label create docs --color "D4C5F9" --description "Documentation"
gh label create ai --color "FBCA04" --description "AI agents & skills"
gh label create workflow --color "C2E0C6" --description "Workflow & processes"

# Priority labels
gh label create P1 --color "B60205" --description "Priority 1 - Critical"
gh label create P2 --color "D93F0B" --description "Priority 2 - Important"
gh label create P3 --color "FBCA04" --description "Priority 3 - Nice to have"

# Size labels
gh label create XS --color "E6E6E6" --description "Size: Extra Small"
gh label create S --color "C5DEF5" --description "Size: Small"
gh label create M --color "BFD4F2" --description "Size: Medium"
gh label create L --color "7057FF" --description "Size: Large"
gh label create XL --color "D876E3" --description "Size: Extra Large"
```

## 4. Configure GitHub Repository

### Rename default branch to main

If your repository uses `master` as the default branch, rename it to `main`:

```bash
# Rename master to main on GitHub
gh api repos/OWNER/REPO/branches/master/rename -f new_name=main

# Update local repository
git fetch origin
git branch -m master main
git branch -u origin/main main
git remote set-head origin -a
```

### Enable GitHub Discussions

```bash
# Enable discussions on the repository
gh repo edit --enable-discussions
```

Or via **Settings** > **General** > **Features** > check **Discussions**.

### Configure branch protection

In **Settings** > **Branches** > **Add rule** for `main`:

- [x] Require a pull request before merging
- [x] Require approvals (1)
- [x] Dismiss stale pull request approvals when new commits are pushed
- [x] Require conversation resolution before merging
- [x] Require status checks to pass before merging
  - [x] ci (when CI is configured)
- [x] Do not allow bypassing the above settings

Or via API:

```bash
gh api repos/OWNER/REPO/branches/main/protection -X PUT \
  --input - <<'EOF'
{
  "required_status_checks": null,
  "enforce_admins": false,
  "required_pull_request_reviews": {
    "dismiss_stale_reviews": true,
    "require_code_owner_reviews": false,
    "required_approving_review_count": 1
  },
  "restrictions": null,
  "allow_force_pushes": false,
  "allow_deletions": false,
  "required_conversation_resolution": true
}
EOF
```

## 5. Configure CI/CD (Optional)

CI/CD workflows are included and work out of the box. For faster builds, configure Turbo Remote Cache:

### Turbo Remote Cache (~50% faster CI)

1. Create a free [Vercel](https://vercel.com) account
2. Go to **Settings** > **Tokens** > **Create token**
3. In your GitHub repo: **Settings** > **Secrets and variables** > **Actions**
4. Add secret: `TURBO_TOKEN` (your Vercel token)
5. Add variable: `TURBO_TEAM` (your Vercel team name)

### CI Pipeline

The CI pipeline runs automatically on:
- Pull requests to `main`
- Pushes to `main`

Jobs: `install` → `lint` / `typecheck` / `test` (parallel) → `build` → `e2e` (conditional)

To run E2E tests on a PR, add the `e2e` label.

### CD Pipeline

Deployment runs automatically on pushes to `main` via Vercel:

- **Web** (TanStack Start) — auto-deploys to **Vercel** (SSR, edge caching, Fluid compute)
- **API** (NestJS) — auto-deploys to **Vercel** (zero-config NestJS, Fluid compute)

No Docker or SSH needed — Vercel watches the GitHub repo directly.

> **First-time setup:** Create two Vercel projects (web + API) from the same repo. See the [Deployment Guide](/docs/guides/deployment).

## 6. Install Dependencies

```bash
# Install all monorepo dependencies
bun install
```

## 7. Configure Environment

```bash
# Copy the example file
cp .env.example .env

# Edit with your values
# DATABASE_URL, API keys, etc.
```

## 8. Start the Database

```bash
# Start PostgreSQL via Docker Compose
bun db:up

# Verify it's running and healthy
docker compose ps
```

> **Note:** Data persists across restarts. To stop: `bun db:down`. To reset data: `docker compose down -v`.

> **Troubleshooting:** If port 5432 is already in use, stop your local PostgreSQL first (`sudo systemctl stop postgresql` or `brew services stop postgresql`).

## 9. Run the Project

```bash
# Run all apps in dev mode
bun dev

# Or individually
bun --filter @repo/web dev
bun --filter @repo/api dev
```

## 10. Verify Installation

- Frontend: http://localhost:3000
- API: http://localhost:3001
- API Docs (Swagger): http://localhost:3001/docs
- Documentation: http://localhost:3000/docs (served by `bun docs`)

## Useful Commands

| Command | Description |
|---------|-------------|
| `bun dev` | Run all apps in dev mode |
| `bun build` | Build all packages |
| `bun lint` | Lint with Biome |
| `bun format` | Format with Biome |
| `bun typecheck` | TypeScript type checking |
| `bun run test` | Run all tests (via turbo + vitest) |
| `bun test:coverage` | Tests with coverage |
| `bun docs` | Start documentation server (runs apps/web) |
| `bun db:up` | Start PostgreSQL (Docker Compose) |
| `bun db:down` | Stop PostgreSQL (preserves data) |

## Next Steps

1. Read the [Vision](./vision) to understand the project
2. Check the [Architecture](./architecture)
3. Check the [open issues](https://github.com/MickaelV0/roxabi_boilerplate/issues)
4. Set up [VPS Deployment](./guides/deployment) when ready for production
