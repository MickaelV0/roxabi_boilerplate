---
title: Frontend Patterns
description: React and TanStack Start coding standards, design patterns, and best practices
---

## TypeScript Preamble

Use the TypeScript compiler as a safety net, not a suggestion engine. Every pattern below exists in
or is derived from the codebase.

| Pattern | Example | Source |
|---------|---------|--------|
| Const assertions | `const LOCALES = ['en', 'fr'] as const` | `apps/web/src/lib/i18n/types.ts` |
| Derived unions | `type Locale = (typeof LOCALES)[number]` | `apps/web/src/lib/i18n/types.ts` |
| Type guards | `function isValidLocale(s): s is Locale` | `apps/web/src/lib/i18n/server.ts` |
| Assertion functions | `function assertLocale(s): asserts s is Locale` | New pattern |
| `satisfies` validation | `config satisfies Record&lt;Locale, ...>` | New pattern |
| `as const satisfies` | `['en', 'fr'] as const satisfies readonly string[]` | New pattern |
| Generic responses | `ApiResponse&lt;T>` (discriminated union preferred) | `packages/types/src/index.ts` |
| Mapped types | `Record&lt;Locale, { native: string; english: string }>` | `LanguageSwitcher.tsx` |
| Type-only imports | `import type { Locale }` | Enforced by Biome |
| Template literal types | `` type LocalizedRoute = `/${Locale}/${string}` `` | New pattern |

**Anti-patterns:**

- **`any`** -- Use `unknown` instead. Biome enforces this via `noExplicitAny: "warn"`.
- **`!` non-null assertion** -- Use null checks, optional chaining, or assertion functions. Biome enforces via `noNonNullAssertion: "warn"`.
- **`as X` type casting** -- Use `satisfies` for compile-time validation or type guards for runtime narrowing.

**`type` vs `interface`:** Use `type` as default. It prevents accidental declaration merging and supports unions/intersections directly. Use `interface extends` only for deep type hierarchies where compiler performance matters (rare).

**Auto-enforced:** `biome.json` enables `useImportType: "error"` and `noExplicitAny: "warn"`. `tsconfig.json` sets `strict: true` across all packages.

## 1.1 Monorepo Component Strategy

### Where to Put Components

| Location | Use Case | Examples |
|----------|----------|----------|
| `packages/ui/src/components/` | Reusable primitives, design system | Button, Card, Input, Select |
| `apps/web/src/components/` | App-specific, business logic | LocaleSwitcher, Header, ResumeAssistant |

**Decision tree:**

```
Is it a generic UI primitive with no business logic?
  └─ YES → packages/ui
  └─ NO → Does it need app-specific context (i18n, auth, routing)?
           └─ YES → apps/web/src/components
           └─ NO → Could other apps in the monorepo use it?
                    └─ YES → packages/ui
                    └─ NO → apps/web/src/components
```

**Rules:**

- **`packages/ui`**: Zero business logic. Only styling, variants, and accessibility. No imports from `apps/*`.
- **`apps/web/src/components`**: Can import from `@repo/ui`. Can use app context (router, i18n, auth).
- **Composition over modification**: Wrap `@repo/ui` components in app components rather than forking them.

### Consuming `@repo/ui`

```tsx
// Import components
import { Button, Card, CardContent } from '@repo/ui'

// Import utility
import { cn } from '@repo/ui'

// Import styles in your app's root (e.g., root layout or CSS entry)
import '@repo/ui/styles.css'
```

## 1.2 Code Organization

Structure feature directories consistently:

```
lib/feature/
├── types.ts        # Type definitions
├── hooks.ts        # React hooks
├── client.ts       # Client-side utilities
├── server.ts       # Server-side utilities (createServerFn)
└── __tests__/      # Tests (alternative to colocated .test.ts)
```

See `apps/web/src/lib/i18n/` for a canonical example of this structure.

**Rules:**

- **No barrel files in app code.** Import directly from the source file: `@/lib/i18n/hooks`, not `@/lib/i18n`. Barrel files increase bundle size and create circular dependency risks.
- **Barrel files allowed only in `packages/*/src/index.ts`** for public API surfaces of shared packages.
- **Separate client and server files** for isomorphic features. Never import server-only code (e.g., cookie parsing, database calls) into client modules.
- **Hooks in a dedicated file.** Do not mix hook definitions with utility functions. `hooks.ts` contains React hooks; `client.ts` and `server.ts` contain plain functions.
- **TanStack Start conventions:** Use `$param` for dynamic route segments (e.g., `$locale/dashboard.tsx`), `_` prefix for pathless layouts (e.g., `$locale/_layout.tsx`), and `__root.tsx` for the root route.

## 1.3 Design Patterns

| Pattern | Source | Example |
|---------|--------|---------|
| Hook Composition | `apps/web/src/lib/i18n/hooks.ts` | `useTranslation`, `useLocale` -- focused, single-purpose hooks |
| Companion Hook | `apps/web/src/components/LanguageSwitcher.tsx` | `useLanguageSwitcher` co-located with the component it serves |
| Error Boundary | `react-error-boundary` package | `&lt;ErrorBoundary>` with `fallbackRender` prop |
| Component Composition | `apps/web/src/components/LanguageSwitcher.tsx` | Variant props + companion hook for flexible rendering |
| Module Namespace | `apps/web/src/lib/i18n/` directory | Related files grouped in a dedicated directory |

**Design principles:**

- **Focused hooks.** Each hook does one thing. `useTranslation` returns translation functions; `useLocale` returns locale and formatting utilities. Do not combine unrelated concerns.
- **Minimal props.** Pass only what the component needs. Derive internal state from props rather than requiring callers to pre-compute it.
- **Extension via composition.** Add variants without modifying internals. The `LanguageSwitcher` uses a `variant` prop to switch between `'dropdown'` and `'buttons'` rendering.
- **Compound components over config props.** If a component accumulates more than 4-5 configuration props, refactor it into a compound component pattern with subcomponents.

## 1.4 Error Handling

**Existing patterns in the codebase:**

- Error boundaries via `react-error-boundary` at route and feature level.
- `null` return for graceful degradation (e.g., `getLocaleFromPath` returns `null` when no locale is found).
- `console.warn` for non-critical failures (e.g., missing translation files in `loadTranslations`).
- Try/catch in hooks with `undefined` fallback (e.g., `useI18nContext` catches missing router context).

**Rules:**

- **Use `react-error-boundary`.** Do not write hand-rolled class components for error boundaries.
- **React 19 behavior:** Errors thrown in `useTransition` async callbacks propagate to the nearest error boundary automatically.
- **Utility and UI helpers may return `null` or `undefined`** for expected failure cases. Callers handle the absent value.
- **Business logic: use Result types.** For operations that can fail in expected ways, return discriminated unions instead of throwing:

```ts
type Result<T, E = string> =
  | { success: true; data: T }
  | { success: false; error: E }
```

- **Never throw from functions called during rendering.** Thrown errors in the render path crash the component tree. Return fallback UI or `null` instead.

## 1.5 Component Patterns

- **Functional components only.** No class components, no exceptions.
- **Props type as `type`, not `interface`.** Use PascalCase with a `Props` suffix:

```tsx
type LanguageSwitcherProps = {
  className?: string
  variant?: 'dropdown' | 'buttons'
}
```

- **Extract logic into companion hooks** when a component's logic grows beyond simple event handlers. See `useLanguageSwitcher` in `LanguageSwitcher.tsx`.
- **Named exports only.** Never use default exports. Exception: framework conventions that require them (e.g., route components if mandated by the framework).
- **Variant pattern** for multi-mode components. Use a `variant` prop with a union type rather than separate components or boolean flags:

```tsx
variant?: 'dropdown' | 'buttons'  // Good
isDropdown?: boolean              // Avoid
```

- **Avoid premature memoization.** Do not add manual `React.memo`, `useMemo`, or `useCallback` unless profiling proves a measurable performance problem. Most components don't need memoization, and it adds complexity without benefit.

## 1.6 Shared UI Library (`packages/ui`)

The `@repo/ui` package uses **shadcn/ui** patterns: Radix UI primitives + CVA + Tailwind CSS.

### Core Dependencies

| Package | Purpose |
|---------|---------|
| `radix-ui` | Accessible, unstyled primitives |
| `class-variance-authority` | Type-safe variant management |
| `clsx` + `tailwind-merge` | Conditional class composition via `cn()` |
| `lucide-react` | Icons |

### The `cn()` Utility

Always use `cn()` for className composition. It merges Tailwind classes intelligently:

```tsx
import { cn } from '@repo/ui'

// Merges and deduplicates Tailwind classes
cn('px-4 py-2', 'px-6')           // → 'py-2 px-6'
cn('text-red-500', isActive && 'text-blue-500')  // conditional
cn(baseStyles, className)          // allow className override
```

### CVA (Class Variance Authority) Pattern

Use CVA for components with multiple variants:

```tsx
import { cva, type VariantProps } from 'class-variance-authority'

const buttonVariants = cva(
  // Base styles (always applied)
  'inline-flex items-center justify-center rounded-md font-medium',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground',
        outline: 'border bg-background',
        ghost: 'hover:bg-accent',
      },
      size: {
        default: 'h-9 px-4 py-2',
        sm: 'h-8 px-3',
        lg: 'h-10 px-6',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

// Export variants for external use (composition)
export { buttonVariants }
```

### Props Pattern for Primitives

Extend native HTML props and add variant types:

```tsx
import type * as React from 'react'
import type { VariantProps } from 'class-variance-authority'

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps&lt;'button'> &
  VariantProps&lt;typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot.Root : 'button'
  return (
    &lt;Comp
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}
```

**Key points:**

- `React.ComponentProps&lt;'button'>` — inherit all native button props
- `VariantProps&lt;typeof buttonVariants>` — type-safe variant props
- `className` in CVA call — allows consumer override
- `asChild` + `Slot` — Radix pattern for composing with other elements

### Data Attributes Convention

Add data attributes for CSS targeting and testing:

```tsx
&lt;button
  data-slot="button"
  data-variant={variant}
  data-size={size}
  // ...
/>
```

### Adding New shadcn/ui Components

**Method 1: CLI Installation (Recommended)**

The shadcn CLI doesn't work directly in `packages/ui` (no framework detected), but works from `apps/web`:

```bash
# 1. Install from apps/web (has components.json)
cd apps/web
bunx shadcn@latest add button dialog accordion --yes

# 2. Move to packages/ui
mv src/components/ui/*.tsx ../../packages/ui/src/components/

# 3. Rename to PascalCase (our convention)
cd ../../packages/ui/src/components
mv button.tsx Button.tsx
mv dialog.tsx Dialog.tsx

# 4. Export from packages/ui/src/index.ts
```

**Method 2: Manual Copy**

1. **Visit**: [ui.shadcn.com](https://ui.shadcn.com/docs/components)
2. **Copy** the component code
3. **Create** `packages/ui/src/components/ComponentName.tsx`
4. **Adapt** imports:
   - Change `@/lib/utils` → `@/lib/utils` (same path alias)
   - Use `radix-ui` instead of individual `@radix-ui/*` packages
5. **Export** from `packages/ui/src/index.ts`
6. **Test**: Add `ComponentName.test.tsx` with basic render test

**Both methods require:**

```tsx
// packages/ui/src/index.ts
export { NewComponent } from './components/NewComponent'
```

### Compound Components

For complex components (Select, Dialog), export all sub-components:

```tsx
export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from './components/Select'
```

## 1.7 AI Quick Reference

Compressed imperative rules for AI agent consumption. No examples, no rationale.

**TypeScript:**

- Use `unknown` over `any`
- Use `satisfies` over `as` for type validation
- Use `type` over `interface` as default
- Enforce type-only imports (`import type`)
- No `!` non-null assertions -- use optional chaining or assertion functions
- Use const assertions with derived union types
- Use discriminated unions for API responses
- Escape `&lt;` as `&amp;lt;` in MDX text (not in code blocks)

**Frontend (App Components):**

- No barrel files in app code -- import directly from source files
- Functional components only -- no class components
- Named exports only (exception: framework conventions)
- Use `react-error-boundary` for error boundaries
- No manual `React.memo`/`useMemo`/`useCallback` unless profiling proves necessary
- Extract complex logic into companion hooks
- Variant pattern for multi-mode components (`variant?: 'a' | 'b'`, not `isA?: boolean`)
- Client/server file separation for isomorphic features
- Props as `type` with `Props` suffix
- Never throw from render path
- TanStack Start: `$param` for dynamic segments, `_` prefix for pathless layouts

**Shared UI (`packages/ui`):**

- Generic primitives only -- no business logic, no app imports
- Use CVA (`class-variance-authority`) for variant management
- Use `cn()` for all className composition
- Extend `React.ComponentProps&lt;'element'>` for native props
- Use `VariantProps&lt;typeof variants>` for type-safe variants
- Support `asChild` prop with Radix `Slot` for composition
- Add `data-slot`, `data-variant` attributes
- Export component + variants (e.g., `Button`, `buttonVariants`)
- Export compound component parts separately
- Copy shadcn/ui components manually (no CLI) and adapt imports
