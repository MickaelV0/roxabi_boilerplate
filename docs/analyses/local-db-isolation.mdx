---
title: "Local Database Isolation per Worktree"
description: Analysis of approaches for isolating local PostgreSQL databases per git worktree to prevent migration conflicts between feature branches
---

## Context

All local development shares a single `roxabi` PostgreSQL database (Docker Compose, `postgres:16-alpine`). When working on feature branches that include schema changes, running `db:migrate` modifies the shared database — breaking other worktrees that expect a different schema state.

**Current state:**

- **Docker Compose** (`docker-compose.yml`): single Postgres container, single `roxabi` database, port 5432.
- **Environment**: `DATABASE_URL=postgresql://roxabi:roxabi@localhost:5432/roxabi` in root `.env`.
- **No `.env` in `apps/api/`**: drizzle-kit commands fail unless `DATABASE_URL` is passed explicitly or inherited from root.
- **Migration scripts** (`apps/api/package.json`): `db:generate`, `db:migrate`, `db:studio` — all operate on whatever `DATABASE_URL` points to.
- **No seed script**: fresh databases are empty after migration. Developers must manually create test data through the UI.
- **Worktree convention**: `git worktree add ../roxabi-<issue> -b feat/<issue>-<slug> staging`.
- **Worktree lifecycle**: created by `/scaffold` (Step 3d) or manually; removed by `/cleanup` or manually.

**Problem scenario:**

1. Developer works on `feat/150-add-billing` — runs `db:migrate`, which adds a `billing` table.
2. Developer switches to `feat/155-fix-auth` — the shared DB now has the `billing` table, which doesn't exist in that branch's schema. Runtime checks warn about drift.
3. Developer returns to billing branch — another migration may have run, schema state is unpredictable.

## Questions Explored

1. How should each worktree get its own isolated database?
2. Should branch databases be seeded or cloned from a template?
3. How should DB creation/teardown integrate with existing worktree lifecycle (scaffold, cleanup)?
4. What seed data is needed for a usable development baseline?

## Analysis

### Database Isolation Strategy: Branch-Named Databases

Create a separate database **per worktree** within the existing Postgres container. Database name is `roxabi_<issue_number>`, derived from the branch convention (`feat/150-billing` → `roxabi_150`):

| Worktree | Database Name | DATABASE_URL |
|----------|--------------|--------------|
| Main repo (staging) | `roxabi` | `postgresql://roxabi:roxabi@localhost:5432/roxabi` |
| `../roxabi-150` | `roxabi_150` | `postgresql://roxabi:roxabi@localhost:5432/roxabi_150` |
| `../roxabi-155` | `roxabi_155` | `postgresql://roxabi:roxabi@localhost:5432/roxabi_155` |

**Naming convention:** Always `roxabi_<issue_number>`. The issue number is the unique identifier in the branch naming convention and is always present per `docs/processes/dev-process.mdx`. Short names avoid Postgres' 63-character identifier limit. If no issue number is extractable (e.g., a `docs/` branch without an issue), the script should fail with a clear error rather than silently falling back to a sanitized name.

**Rationale:**

- **Lightweight**: no extra Docker containers, no port mapping, ~0 resource overhead.
- **Fast**: `CREATE DATABASE` is instant for an empty database.
- **Familiar**: same Postgres instance, same credentials, just a different database name.
- **Isolated**: each worktree has its own schema state — migrations in one branch don't affect others.

**Drizzle journal behavior:** Each branch has its own migration files in `drizzle/migrations/`. When branch A adds migration `0003_billing` and branch B adds a different `0003_auth_fix`, the fresh-migrate approach handles this correctly — each branch only applies its own migrations to its own database. The `__drizzle_migrations` table tracks what was applied per database, not globally.

**Infrastructure assumption:** The Docker Compose `POSTGRES_USER` (`roxabi`) is the container superuser with `CREATE DATABASE` privileges. If this ever changes to a restricted user, the `createdb` command will fail. This is documented here as a known dependency.

### Database Initialization: Fresh Migrate + Seed

Two approaches were evaluated:

| Approach | Speed | Reproducibility | Coupling | Seed needed? |
|----------|-------|-----------------|----------|-------------|
| **Fresh migrate + seed** | ~2-3s | Deterministic, same result every time | None — independent of other branches | Yes |
| **Template clone** (`createdb -T`) | Instant | Depends on template state | High — template DB must exist and have no active connections | No |

**Decision: Fresh migrate + seed.**

- Matches the CI/CD pipeline (Neon preview branches run migrations fresh).
- Reproducible — every branch starts from the same baseline.
- No coupling to the state of the staging database.
- Template clone has a Postgres limitation: the template database cannot have active connections during cloning. With multiple worktrees running simultaneously, this is a blocker.

### Seed Data: Dev Essentials

A seed script that creates the minimum data needed to log in and navigate:

| Entity | Data | Purpose |
|--------|------|---------|
| User | `dev@roxabi.local` / password `password123` | Login immediately |
| Account | `providerId: 'credential'`, hashed password | Better Auth requires an `accounts` row for email/password login |
| Organization | "Roxabi Dev" | Multi-tenant context |
| Member | User linked to organization | Access org features |
| Roles | Admin, Member (default roles) | RBAC baseline |
| Permissions | Standard permission set | RBAC baseline |
| Role assignments | User → Admin role | Full access for testing |

This covers the auth + RBAC schema (`users`, `accounts`, `organizations`, `members`, `sessions`, `roles`, `permissions`, `role_permissions`) without bloating the seed with demo-specific data.

**RBAC seeding approach:** Default roles and permissions are normally created per-org via `RbacListener` on the `ORGANIZATION_CREATED` event. The seed script should decide between: (a) triggering the event programmatically after creating the organization (maintains coupling to business logic, stays in sync), or (b) directly inserting roles/permissions (simpler, no runtime dependency). This decision should be made in the spec.

**Password hashing:** The seed must hash passwords through Better Auth's password utility, not insert cleartext. The spec should define the exact hashing call.

### Worktree Lifecycle Integration

Worktrees are created and removed in three places:

| Where | Create | Remove |
|-------|--------|--------|
| `/scaffold` (Step 3d) | `git worktree add` + `cp .env.example .env` + `bun install` | Abort path |
| `/cleanup` | — | `git worktree remove` + `git branch -d` |
| Manual (dev-process.mdx) | `git worktree add` + `cd` | `git worktree remove` |

**Recommendation: Extend existing scripts, not a new wrapper.**

Rather than creating a separate `worktree:add` / `worktree:remove` wrapper (which duplicates git worktree management and risks diverging from the canonical flow), add DB lifecycle scripts and hook them into the existing touch points:

**New scripts in `apps/api/package.json`:**

| Script | Purpose |
|--------|---------|
| `db:branch:create` | Create a branch database, run migrations, run seed |
| `db:branch:drop` | Drop a branch database |
| `db:seed` | Seed the current database (reusable for any context) |
| `db:branch:list` | List all `roxabi_*` databases (for visibility) |

**Integration points:**

1. **`/scaffold` Step 3d** — after `bun install`, run `bun run db:branch:create` with the issue number. Update the worktree's `.env` with the branch-specific `DATABASE_URL`.
2. **`/cleanup` Step 5** — before `git worktree remove`, run `bun run db:branch:drop` to drop the associated database.
3. **Dev process docs** — update worktree creation/removal instructions to include the DB step.
4. **`CLAUDE.md`** — update the worktree section to mention DB isolation.

**`.env` handling:**

The scaffold already copies `.env.example` to `.env` in the worktree. The `db:branch:create` script should:
1. Create the database.
2. Run migrations against it.
3. Run seed.
4. Update the worktree's `.env` file to point `DATABASE_URL` to the branch database.

This way, `bun run dev` in any worktree automatically uses the correct database.

### Script Implementation Approach

The scripts should be shell scripts (or Bun scripts) in `apps/api/` that:

1. **Derive the DB name** from the current git branch or an explicit argument:
   - Extract issue number from branch name (`feat/150-billing` → `roxabi_150`)
   - If no issue number is extractable, fail with a clear error message.

2. **Check container liveness** before any operation — verify `roxabi-postgres` is running via `docker exec roxabi-postgres pg_isready -U roxabi`. If not running, print: "Postgres container is not running. Run `bun run db:up` first."

3. **Use `docker exec -U roxabi`** to run `createdb` / `dropdb` against the running Postgres container — no need for `psql` installed locally. The `-U roxabi` flag is required (the default container user has no Postgres role).

4. **Pass `DATABASE_URL` explicitly** as an env var prefix for migrate/seed commands — drizzle-kit does not load `.env` files:
   - `DATABASE_URL=postgresql://roxabi:roxabi@localhost:5432/roxabi_150 bun run db:migrate`
   - `DATABASE_URL=postgresql://roxabi:roxabi@localhost:5432/roxabi_150 bun run db:seed`

5. **Safety guard**: the `db:branch:drop` script must refuse to drop the default `roxabi` database. Only databases matching `roxabi_<number>` are eligible for automated removal.

6. **Rollback on failure**: if migrations succeed but seeding fails, drop the database and report the error. A half-initialized database is worse than no database.

### Cleanup Integration

The existing `/cleanup` skill removes worktrees and branches. It should also:

1. **Discover existing branch databases** — query Postgres for all databases matching `roxabi_%` via `docker exec roxabi-postgres psql -U roxabi -t -c "SELECT datname FROM pg_database WHERE datname ~ '^roxabi_[0-9]+$'"`.
2. **Cross-reference with `git worktree list`** — map each database to an active worktree/branch. Databases with no matching branch are orphans.
3. **Include databases in the summary table** — show which databases exist alongside branches and worktrees (and flag orphans).
4. **Drop databases** as part of the cleanup — after user confirmation, before `git worktree remove`.
5. **List orphaned databases** — databases that exist but have no corresponding branch (leftover from manual cleanup). Present these separately for explicit confirmation.

### Operational Considerations

- **Connection pool limits**: the Drizzle provider is configured with `max: 10` connections per database. With 5 simultaneous worktrees running `bun run dev`, that's 50 connections out of Postgres' default 100. Not a problem in practice (idle connections are released after 20s), but worth monitoring if many worktrees run concurrently.
- **Disk space**: empty databases after migration are tiny (~5-10 MB). Dozens of branch databases are negligible. `db:branch:list` serves as a diagnostic tool.
- **CI/CD impact**: none. CI uses its own `DATABASE_URL` (the CI Postgres service). Vercel uses Neon. These scripts are local-dev only.

## Conclusions

1. **Branch-named databases** in the same Postgres container provide lightweight, zero-overhead isolation per worktree.
2. **Fresh migrate + seed** is the right initialization strategy — reproducible, decoupled, matches CI/CD behavior.
3. **Extend existing lifecycle hooks** (`/scaffold`, `/cleanup`) rather than creating a new worktree wrapper — reduces duplication, maintains a single source of truth for worktree management.
4. **Dev essentials seed** (user, org, roles, permissions) provides a usable baseline without over-engineering.
5. **`.env` per worktree** with branch-specific `DATABASE_URL` ensures `bun run dev` just works in any worktree.

## Next Steps

- Create a spec for implementation details (scripts, seed data, scaffold/cleanup integration)
- Decide on seed script format (TypeScript using Drizzle ORM vs. raw SQL)
- Create a GitHub issue to track this work
