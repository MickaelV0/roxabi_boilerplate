---
title: "Brainstorm: Seline Analysis"
description: Analysis of tercumantanumut/seline for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#221](https://github.com/roxabi/boilerplate/issues/221)
**Repository:** [tercumantanumut/seline](https://github.com/tercumantanumut/seline)
**Stars / Activity:** 131 stars, last commit 2026-02-17 (very active â€” multiple commits per day)

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Local-first AI desktop app with agent orchestration, multi-channel bots, and visual generation |
| How it works | ðŸŸ¢ | Electron + Next.js hybrid with deferred tool loading and 6-phase deep research pipeline |
| Architecture | ðŸŸ¡ | Flat monolith but with deeply domain-segmented `lib/` modules |
| File structure | ðŸŸ¡ | Dense feature-per-folder `lib/` structure; no monorepo |
| Tech stack | ðŸŸ¡ | Next.js + Electron + Drizzle + LanceDB vs. TanStack Start + NestJS + Neon |
| DX | ðŸ”´ | npm-only, no git hooks, no formatter enforcement, heavier native rebuild steps |
| Testing | ðŸŸ¡ | Vitest with unit + integration split, but no coverage gates and no CI to enforce it |
| CI/CD | ðŸ”´ | No CI pipeline whatsoever â€” zero GitHub Actions workflows |
| Documentation | ðŸŸ¡ | Minimal docs directory but a rich README with architecture references |
| Unique ideas | ðŸŸ¢ | Smart tool discovery (40+ tools on-demand), prompt caching observability, multi-channel inbox |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

Seline is a **local-first AI desktop application** targeting power users and developers who want a single interface to:

- Chat with multiple LLM providers (Anthropic, OpenRouter, Kimi, Ollama, Codex, Antigravity)
- Generate images (Flux, GPT-5, Gemini, WAN, local FLUX.2 Klein via ComfyUI)
- Assemble AI-driven videos with scene planning and Remotion
- Run deep research (6-phase autonomous pipeline)
- Turn agents into always-on bots on WhatsApp, Telegram, Slack, and Discord
- Manage persistent agent memory with user-controlled categorization
- Index and search local folders with hybrid vector + lexical retrieval (LanceDB)
- Execute scheduled cron tasks with channel delivery

**Problem solved:** Fragmented AI tooling â€” replaces a dozen separate AI services with one persistent desktop app that owns the data locally.

**Comparison to roxabi:** The problem domains are almost entirely different. Roxabi is a SaaS boilerplate for building web products; Seline is an end-user AI desktop product. The rating is ðŸŸ¡ (different approach) rather than ðŸ”´ because Seline's agentic architecture patterns are directly relevant to what roxabi might build.

### 2. How It Works ðŸŸ¢

Core runtime flow:

1. **Electron shell** wraps a **Next.js** app running locally. The app dir (`app/`) uses the Next.js App Router with route groups `(auth)`, `agents`, `chat`, `dashboard`, `settings`, `skills`, `usage`.
2. **API routes** in `app/api/` handle all backend logic â€” no separate server process. SQLite (`better-sqlite3`) stores sessions, messages, agent configs, and memory. PostgreSQL is optionally used for auth/user data (Drizzle ORM with `DATABASE_URL`).
3. **Vector search** uses LanceDB (`@lancedb/lancedb`) with configurable local or API-based embeddings (ONNX Runtime + HuggingFace Transformers.js for local models).
4. **Smart tool discovery:** Instead of loading all 40+ tools into every LLM context, Seline exposes a `searchTools` meta-tool. The LLM describes what it needs, and only the matching tools are injected â€” saving ~70% of tokens per request. This is a genuinely novel pattern.
5. **Deep Research pipeline:** 6 sequential phases (plan â†’ search â†’ analyze â†’ draft â†’ refine â†’ finalize) using multiple specialized models running in parallel within phases.
6. **Multi-channel inbox:** WhatsApp via Baileys, Telegram via Grammy, Slack via Bolt, Discord via discord.js. Each channel connection is assigned to an agent; inbound messages are routed and responses flow back through the same channel.
7. **MCP integration:** Per-agent MCP server configuration with dynamic path variables (`${SYNCED_FOLDER}`, `${SYNCED_FOLDERS_ARRAY}`). Node.js is bundled in the Electron app so `npx`-based MCP servers work without system Node.

**Why ðŸŸ¢:** The smart tool discovery pattern and the 6-phase research pipeline are more sophisticated than anything in roxabi today.

### 3. Architecture & Layers ðŸŸ¡

Seline is a **monolith** (no monorepo, no package boundaries) but with strong domain separation inside `lib/`:

```
seline/
â”œâ”€â”€ electron/               # Main process (main.ts, preload.ts)
â”œâ”€â”€ app/                    # Next.js App Router (UI + API routes)
â”‚   â”œâ”€â”€ (auth)/             # Auth route group
â”‚   â”œâ”€â”€ agents/             # Agent management UI
â”‚   â”œâ”€â”€ chat/               # Chat UI
â”‚   â”œâ”€â”€ api/                # Next.js API routes (backend)
â”‚   â””â”€â”€ settings/           # Settings UI
â”œâ”€â”€ components/             # React UI components
â”œâ”€â”€ lib/                    # Domain logic modules
â”‚   â”œâ”€â”€ ai/                 # LLM provider abstraction, tool registry
â”‚   â”œâ”€â”€ agent-memory/       # Persistent memory CRUD
â”‚   â”œâ”€â”€ background-tasks/   # Task scheduler + cron
â”‚   â”œâ”€â”€ channels/           # WhatsApp, Telegram, Slack, Discord
â”‚   â”œâ”€â”€ mcp/                # MCP client + server config
â”‚   â”œâ”€â”€ vectordb/           # LanceDB client, indexing, search
â”‚   â”œâ”€â”€ scheduler/          # Cron job engine
â”‚   â”œâ”€â”€ session/            # Chat session management
â”‚   â”œâ”€â”€ db/                 # Drizzle schema + migrations
â”‚   â””â”€â”€ ...                 # 25+ other domain modules
â”œâ”€â”€ hooks/                  # React hooks
â”œâ”€â”€ rtk/                    # Redux Toolkit slices
â”œâ”€â”€ models/                 # TypeScript model types
â”œâ”€â”€ comfyui_backend/        # Docker-based ComfyUI for local image gen
â”œâ”€â”€ drizzle/                # Migration files
â””â”€â”€ tests/                  # Unit + integration tests
```

**Patterns observed:**
- Domain-per-folder in `lib/` with clear single-responsibility boundaries
- Redux Toolkit (RTK) for client-side state with dedicated `rtk/` directory
- Drizzle for database schema and migrations (co-located in project root)
- No hexagonal architecture, no DDD aggregates â€” pragmatic layering

**Comparison to roxabi:** Roxabi uses a proper monorepo (TurboRepo + `apps/` + `packages/`) with a separate NestJS API and TanStack Start frontend. Seline's flat Next.js monolith is simpler to start but harder to scale. Rating ðŸŸ¡ because both approaches are valid for their respective use cases.

### 4. File / Project Structure ðŸŸ¡

**Strengths:**
- `lib/` is exceptionally well-organized with 25+ domain folders, each self-contained
- `tests/` mirrors `lib/` structure with separate `api/` and `lib/` sub-trees
- Multiple `tsconfig.*.json` files for targeted compilation (`app`, `electron`, `lib`, `tooling`)
- `models/` directory for shared TypeScript types (similar to roxabi's `packages/types`)
- `vitest.integration.config.ts` separate from `vitest.config.ts` â€” clean unit/integration split

**Weaknesses:**
- No monorepo structure â€” everything lives at the root
- `components/` is flat (not co-located with features)
- `rtk/` is top-level rather than co-located with UI
- Some naming inconsistencies (`session/` vs `sessions/` both exist in `lib/`)

**Comparison to roxabi:** Roxabi's monorepo with `apps/web`, `apps/api`, `packages/ui`, `packages/types`, `packages/config` is a cleaner separation of concerns. But Seline's `lib/` domain organization is worth borrowing. Rating ðŸŸ¡.

### 5. Tech Stack & Tooling ðŸŸ¡

| Category | Seline | Roxabi Boilerplate |
|----------|--------|-------------------|
| Runtime | Node.js 20+ (npm) | Bun 1.3.9 |
| Frontend | Next.js 16.1 (App Router) | TanStack Start |
| UI Components | Radix UI + Tailwind | (own `packages/ui`) |
| State | Redux Toolkit | (TanStack Query / Context) |
| Backend | Next.js API routes | NestJS + Fastify |
| Database ORM | Drizzle (PostgreSQL + SQLite) | Drizzle (Neon/PostgreSQL) |
| Vector DB | LanceDB | none |
| Desktop | Electron 39 | none (web only) |
| Linter/Formatter | ESLint only | Biome (lint + format) |
| Package manager | npm | Bun |
| Monorepo | None | TurboRepo |
| Type system | TypeScript 5.7 (strict) | TypeScript 5.9 (strict) |
| AI SDK | Vercel AI SDK v6 + AI SDK providers | none (app-level) |
| i18n | next-intl | custom (i18n scripts) |
| Video | Remotion | none |

**Notable observations:**
- Seline uses **Vercel AI SDK** (`ai@^6.0.7`, `@ai-sdk/anthropic`, `@ai-sdk/google`, `@ai-sdk/openai`) aggressively â€” an approach roxabi hasn't adopted yet at the framework level
- The `@assistant-ui/react` + `@assistant-ui/react-ai-sdk` combo provides a turnkey chat UI built on top of AI SDK â€” worth evaluating for roxabi
- `@modelcontextprotocol/sdk@^1.25.2` â€” first-party MCP SDK usage
- LanceDB + ONNX Runtime for local embeddings is a mature local-AI stack

### 6. Developer Experience (DX) ðŸ”´

**Seline DX profile:**
- Package manager: `npm` (slower than Bun, no workspace-level tooling)
- No git hooks (no Lefthook, no Husky)
- No formatter enforcement (ESLint but no Biome/Prettier config checked in)
- Dev command: `npm run electron:dev` â€” chains typecheck â†’ native rebuild â†’ bundle â†’ launch Electron
- Native module rebuilds (`electron-rebuild`) add significant friction on every setup
- Requires Node.js 20+; no explicit `engines` field in `package.json`
- `.env.example` is present â€” good onboarding signal
- Internationalization ready out of the box (next-intl + locales/)

**Compared to roxabi:**
- Roxabi uses Bun (faster installs), Lefthook (pre-commit/push hooks), Biome (opinionated format+lint), commitlint (conventional commits), and TurboRepo (incremental builds).
- Seline has none of these guardrails. A contributor can push broken code or badly formatted files without any friction.
- Rating ðŸ”´: roxabi clearly wins on DX tooling.

### 7. Testing Strategy ðŸŸ¡

**What Seline has:**
- Vitest for both unit and integration tests
- Separate configs: `vitest.config.ts` (unit) and `vitest.integration.config.ts` (integration)
- Coverage via v8 provider, reporters: text, json, html
- Integration tests cover real system boundaries: MCP stdio transport, HuggingFace hub download, Whisper transcription, Electron bundle
- Unit tests for: chat tool persistence, MCP result formatting, MCP synced folders
- `tests/fixtures/` for test data

**What Seline lacks:**
- No coverage thresholds enforced (no `coverage.thresholds` in vitest config)
- No e2e tests (no Playwright or Cypress)
- No CI to run tests automatically
- No `@testing-library` for UI component tests
- Test file count is small relative to the codebase size

**Compared to roxabi:**
- Roxabi has Playwright e2e + Vitest unit + coverage enforcement (run on pre-push via Lefthook) + Testing Library for React
- The **integration test design** in Seline is notably mature â€” testing real MCP server connections, real Whisper transcription, real Electron bundle integrity. Roxabi could learn from this level of infrastructure testing.
- Rating ðŸŸ¡: Seline has good integration test ideas; roxabi has better coverage enforcement and e2e.

### 8. CI/CD Pipelines ðŸ”´

Seline has **no GitHub Actions workflows at all** â€” no `.github/` directory was found.

- No automated lint, typecheck, or test on PRs
- No preview deployments (desktop app distributed as installer, not web service)
- No branch protection (inferred)
- Commits go directly to `main` (127 PRs merged, but no CI enforcing quality)
- Release cadence appears manual (version bumped in `package.json` and electron-builder config)

**Compared to roxabi:**
- Roxabi has `ci.yml` (lint + typecheck + tests), `deploy-preview.yml` (Vercel preview + Neon branch), `neon-cleanup.yml` (branch cleanup)
- This is a major gap in Seline. For a desktop app, the pipeline would be: lint â†’ typecheck â†’ test â†’ build installers â†’ draft GitHub Release
- Rating ðŸ”´: Roxabi clearly wins.

### 9. Documentation Quality ðŸŸ¡

**What exists in Seline:**
- Excellent `README.md`: covers highlights, LLM providers table, MCP docs, multi-channel inbox setup, platform support, prerequisites, install, dev workflow, build commands, model placement guide, troubleshooting, and documentation links
- References to `docs/ARCHITECTURE.md`, `docs/AI_PIPELINES.md`, `docs/DEVELOPMENT.md`, `docs/API.md` â€” but the `docs/` directory returns 404 on the GitHub API (docs may exist in the Electron app's packaged files or were not committed)
- `THANKS.md` credits all open-source dependencies
- `components.json` (shadcn/ui config) is self-documenting

**What's missing:**
- No contributing guide
- No changelog
- No architecture diagrams (referenced but files not found)
- No API reference
- No versioning/release notes visible in the repo

**Compared to roxabi:**
- Roxabi has `docs/` with 20+ MDX files covering architecture, standards, processes, contributing, changelog
- Seline's README is better than average but the supporting docs are absent
- Rating ðŸŸ¡: Seline README is strong; roxabi's overall docs ecosystem is stronger.

### 10. Unique / Novel Ideas ðŸŸ¢

Several patterns in Seline are genuinely novel and worth bringing to roxabi:

**1. Smart Tool Discovery (`searchTools`)**
Instead of listing all available tools in every LLM context (expensive), Seline exposes a single `searchTools` function. The model calls it to find the tools it needs, then those tools are dynamically injected. Claims ~70% token savings. This is directly applicable to any roxabi agent orchestration.

**2. Prompt Caching Observability Dashboard**
Seline tracks Claude API and OpenRouter cache hits/misses in an observability dashboard (`lib/observability/`). It also supports explicit cache breakpoints with configurable TTL (5m or 1h) for direct Claude API calls. Roxabi has no prompt caching strategy yet.

**3. MCP Dynamic Path Variables**
`${SYNCED_FOLDER}`, `${SYNCED_FOLDERS}`, `${SYNCED_FOLDERS_ARRAY}` are resolved at runtime when MCP server configs are evaluated. This lets a single MCP server config template work across multiple agents with different workspaces. Elegant.

**4. Multi-Phase Deep Research Workflow**
The 6-phase pipeline (plan â†’ search â†’ analyze â†’ draft â†’ refine â†’ finalize) with parallel multi-model routing per phase is a production-tested agentic research pattern. The phases are implemented as discrete state machine steps with streaming output.

**5. Zombie Run Detection**
Background task scheduler checks for "zombie" tasks (started but never finished) on startup and cleans them up. A practical reliability pattern for long-running agent workloads.

**6. Plan Tool with Inline Collapsible UI**
Models create multi-step task plans that render inline in the chat with collapsible status tracking. Tool calls are grouped into compact badge rows supporting 15+ concurrent calls cleanly. This is a UX pattern for agentic work that roxabi's frontend could adopt.

**7. Drag-and-Drop Skills Loading from Chat**
Recent commit (2026-02-16): `feat/drag and drop skills loading from chat sessions` â€” users can drag skill files directly into a chat session to load them. A zero-friction skill management UX.

**8. EMFILE Watcher Resilience with Polling Fallback**
File watcher falls back to polling when the OS file descriptor limit (`EMFILE`) is hit. Production-hardened for large codebases with many files.

### 11. What They Do Better Than roxabi_boilerplate

**1. LLM/AI SDK integration depth**
Seline uses Vercel AI SDK v6 (`ai`, `@ai-sdk/anthropic`, `@ai-sdk/google`, `@ai-sdk/openai`) with a clean provider-agnostic abstraction layer in `lib/ai/`. Roxabi has no first-class AI SDK integration at the boilerplate level. Roxabi should adopt the AI SDK as a standard dependency in `packages/types` or a new `packages/ai` package.

**2. Observability for AI costs**
`lib/observability/` tracks prompt caching hits, token usage, and cost by provider. Roxabi has no AI cost observability. This is increasingly important as agentic workloads grow.

**3. Vector search as a first-class module**
`lib/vectordb/` is a complete, production-tested vector search module: background sync, file watching with EMFILE resilience, ignore patterns, path validation, hybrid search router (dense + lexical), search synthesis with AI. Roxabi has no vector search infrastructure at all.

**4. MCP client integration**
`lib/mcp/` provides per-agent MCP server configuration with dynamic variables, auto-reconnect, and health monitoring. With MCP becoming the standard for AI tool ecosystems, roxabi should have an MCP client abstraction in its API layer.

**5. Multiple tsconfig targets**
Seline uses 4 separate `tsconfig.*.json` files (`app`, `electron`, `lib`, `tooling`) allowing targeted type-checking per compilation unit. Roxabi's single-tsconfig approach works but the split allows faster incremental checks (the `typecheck.ts` script in Seline runs them in parallel).

### 12. What They Do Better Than 2ndBrain

2ndBrain (Python, Claude Code skills, Telegram bot) differs fundamentally in stack and purpose, but relevant comparisons:

**1. Structured vector search vs ad-hoc**
Seline's `lib/vectordb/` with LanceDB, background sync, file watching, ignore patterns, and hybrid retrieval is far more production-grade than 2ndBrain's SQLite-vec + BM25 implementation. The background sync service and EMFILE resilience are patterns 2ndBrain lacks.

**2. Multi-provider LLM abstraction**
Seline routes across 6 LLM providers with a unified abstraction. 2ndBrain has a simpler single-provider model with manual model switching (haiku/sonnet/opus) in the Telegram bot. Seline's approach is more composable.

**3. Cron-based task scheduling with channel delivery**
Seline's `lib/scheduler/` with zombie detection, pause/resume, and automatic channel delivery of results is more robust than 2ndBrain's supervisor-based process management.

**4. Inline plan tracking UI**
2ndBrain works entirely through text-based CLI/Telegram interfaces. Seline's inline plan tracking with collapsible multi-step status UI is a significant UX advantage for complex agentic tasks.

**Where 2ndBrain is stronger:**
- Deeper Google Workspace integration (Calendar, Tasks, Gmail) not present in Seline
- More mature knowledge base with BM25 + embeddings hybrid (Seline's search is newer)
- Telegram bot is more feature-rich (19 commands, multi-device pairing, auto model switching)
- Testing: 2ndBrain has pytest coverage on shared modules; Seline has sparse tests

### 13. Key Takeaways

**Priority 1 â€” Must Have:**

1. **Adopt Vercel AI SDK as the standard AI layer in roxabi** (`packages/ai` or direct app dep). Seline demonstrates that the AI SDK v6 + provider-specific packages (`@ai-sdk/anthropic`, `@ai-sdk/google`) provide a clean, type-safe, streaming-first abstraction. Add `@assistant-ui/react` as the chat UI primitive.
   - Create issue: "feat: add @ai-sdk and @assistant-ui as standard AI dependencies"

2. **Add `packages/vectordb` or `apps/api` vector search module** using LanceDB or similar. Seline's `lib/vectordb/` with background sync, file watching, hybrid retrieval, and AI synthesis is a production reference. Start with a basic LanceDB integration in the NestJS API.
   - Create issue: "feat: add vector search infrastructure (LanceDB + hybrid retrieval)"

**Priority 2 â€” Should Have:**

3. **Smart tool discovery pattern for agent orchestration.** When roxabi adds agent capabilities, implement the `searchTools` meta-tool pattern to avoid bloating LLM contexts with all available tools.
   - Create issue: "feat: implement searchTools meta-tool for agent context optimization"

4. **AI cost and prompt caching observability.** Add a simple dashboard (or admin API endpoint) tracking token usage, cache hit rates, and cost by provider/model. Even a basic implementation would be valuable.
   - Create issue: "feat: add AI observability dashboard (token usage, cache hits, cost)"

5. **MCP client abstraction in NestJS API.** Add `@modelcontextprotocol/sdk` to `apps/api` with per-user or per-agent MCP server configuration and dynamic path variable support.
   - Create issue: "feat: integrate MCP client SDK into NestJS API"

**Priority 3 â€” Nice to Have:**

6. **Multiple tsconfig targets for faster incremental type-checking.** Split `apps/web` and `apps/api` into targeted tsconfig files and run typechecks in parallel. Minor gain but improves CI speed.

7. **Plan tracking UI component.** A collapsible multi-step plan component in `packages/ui` for surfacing agentic task progress in real time.

## What's next?

- **Issue to create:** "feat: add @ai-sdk + @assistant-ui as standard AI layer" â€” roxabi is missing a first-class AI SDK; Seline demonstrates the pattern at scale
- **Issue to create:** "feat: vector search infrastructure (LanceDB + hybrid retrieval)" â€” Seline's `lib/vectordb/` is a direct reference implementation
- **Issue to create:** "feat: AI cost observability (token usage, cache hits, prompt caching TTL)" â€” Seline's observability dashboard is the reference
- **Issue to create:** "feat: MCP client integration in NestJS API" â€” Seline's per-agent MCP with dynamic variables is the reference
- **Experiment:** Clone Seline and run locally to evaluate the smart tool discovery and deep research pipeline in practice â€” these are the two most transferable agentic patterns
