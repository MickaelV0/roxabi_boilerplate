---
title: "Brainstorm: HKUDS/nanobot Analysis"
description: Analysis of HKUDS/nanobot for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#213](https://github.com/roxabi/boilerplate/issues/213)
**Repository:** [HKUDS/nanobot](https://github.com/HKUDS/nanobot)
**Stars / Activity:** 20,614 stars, last commit 2026-02-17 (extremely active â€” multiple PRs merged daily)

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Ultra-lightweight AI agent framework for personal assistant use cases |
| How it works | ðŸŸ¢ | Clean event-bus + agent loop + skill system â€” elegant minimal design |
| Architecture | ðŸŸ¡ | Flat Python monolith with well-separated modules; different domain from roxabi |
| File structure | ðŸŸ¢ | Exceptionally clean module layout; workspace-as-config pattern is novel |
| Tech stack | ðŸŸ¡ | Python/uv/ruff/hatchling vs Bun/TS/Biome/TurboRepo â€” parallel ecosystems |
| DX | ðŸŸ¢ | 3-step onboarding (`onboard` â†’ config â†’ `agent`); Docker-ready out of the box |
| Testing | ðŸ”´ | Sparse tests (6 files, no coverage enforcement, no CI test stage) |
| CI/CD | ðŸ”´ | No CI pipeline at all â€” only a Dockerfile; no lint/test/deploy automation |
| Documentation | ðŸŸ¡ | Good README + SOUL/AGENTS/TOOLS markdown conventions; no changelog |
| Unique ideas | ðŸŸ¢ | HEARTBEAT.md periodic tasks, SOUL.md persona config, ClawHub skill registry |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

nanobot is an ultra-lightweight personal AI assistant framework built in Python (~4,000 lines of core code). It positions itself as a radically minimal alternative to heavier agent frameworks.

**Purpose:** Give individuals and developers a self-hosted AI assistant that runs across 9+ chat platforms (Telegram, Discord, WhatsApp, Slack, email, DingTalk, Feishu, QQ, Mochat) with agentic capabilities: file manipulation, shell execution, web search, scheduled tasks, and extensible skills.

**Target audience:** Developers who want a hackable personal AI bot without heavyweight infrastructure. Also targeted at the Chinese developer ecosystem given native DingTalk/Feishu/QQ support.

**Problem it solves:** Most AI agent frameworks are overengineered for simple personal use. nanobot proves you can deliver a production-quality agent in ~4,000 lines with clean architecture.

**Relevance to roxabi:** Low direct overlap â€” roxabi is a SaaS web framework, nanobot is a personal AI agent runtime. However, nanobot's design philosophy (minimal core, skill extensions, workspace-driven config) has high transferability to the AI integration layer roxabi might build.

### 2. How It Works ðŸŸ¢

The system uses a clean event-bus architecture:

1. **Channel adapters** (Telegram, Discord, etc.) receive messages and publish `InboundMessage` events to a `MessageBus`.
2. The **`AgentLoop`** consumes `InboundMessage` events, builds context (long-term memory + conversation history + SOUL persona + skill instructions), calls the configured LLM provider, and executes tool calls in a loop (up to `max_iterations=20`).
3. **Tool calls** are dispatched to registered `Tool` subclasses: `ReadFileTool`, `WriteFileTool`, `ExecTool`, `WebSearchTool`, `WebFetchTool`, `SpawnTool`, `CronTool`, `MCP tools`.
4. **Skills** are loaded from `SKILL.md` files in the workspace â€” they inject system-prompt instructions rather than code, making them purely declarative.
5. **Subagents** (`SpawnTool`) run background tasks by spawning a child `AgentLoop` with its own session.
6. A **heartbeat service** reads `HEARTBEAT.md` every 30 minutes and runs any listed `[ ]` tasks as agent prompts.

The LLM abstraction uses `litellm` as a universal backend, supporting 50+ providers through a single interface â€” a very elegant choice.

### 3. Architecture & Layers ðŸŸ¡

nanobot is a **single-package Python monolith** (no monorepo, no microservices):

```
nanobot/
â”œâ”€â”€ agent/          # Core loop, context, memory, subagents, tools/
â”œâ”€â”€ bus/            # Event queue + message types
â”œâ”€â”€ channels/       # Platform adapters (telegram, discord, slack, ...)
â”œâ”€â”€ cli/            # Typer CLI commands
â”œâ”€â”€ config/         # Pydantic schema + loader
â”œâ”€â”€ cron/           # Scheduled task service
â”œâ”€â”€ heartbeat/      # Periodic heartbeat service
â”œâ”€â”€ providers/      # LLM backend abstraction (litellm, codex, ...)
â”œâ”€â”€ session/        # Conversation session manager
â”œâ”€â”€ skills/         # Built-in SKILL.md instructions
â””â”€â”€ utils/          # Helpers
bridge/             # Node.js TypeScript WhatsApp bridge (separate process)
workspace/          # Runtime files: SOUL.md, AGENTS.md, TOOLS.md, HEARTBEAT.md, memory/
tests/              # 6 test files
```

**Design patterns:**
- **Ports & Adapters**: Channels and providers are adapters behind abstract base classes (`channels/base.py`, `providers/base.py`).
- **Event bus**: Loose coupling between channels and the agent loop via `MessageBus`.
- **Convention over configuration**: The workspace directory acts as a runtime config store â€” markdown files replace YAML/JSON configuration for persona and behavior.
- **Mixed-language boundary**: The WhatsApp bridge is TypeScript (Node.js), communicating with the Python agent over WebSocket. This is the only multi-language seam.

Compared to roxabi's full-stack monorepo (frontend + backend + packages), nanobot is radically simpler and single-domain. No shared type packages, no database, no auth layer.

### 4. File / Project Structure ðŸŸ¢

nanobot's file structure is notably clean and purposeful:

- **Module names match responsibilities precisely** â€” `channels/telegram.py`, `providers/litellm_provider.py`, `agent/tools/shell.py`. Zero ambiguity.
- **`workspace/` as a runtime config directory** is a clever pattern: `SOUL.md` (persona), `AGENTS.md` (instructions), `TOOLS.md` (tool docs), `HEARTBEAT.md` (periodic tasks), `memory/` (persistent state). These are human-editable markdown files that the agent reads as part of its context â€” blurring the line between config and documentation.
- **`skills/` as installable markdown instructions** â€” skills are `SKILL.md` files loaded at startup. No code deployment, just text injection into the system prompt.
- **`bridge/`** is a clear separation for the WhatsApp Node.js component with its own `package.json` and `tsconfig.json`.
- **`case/`** contains animated GIF demos â€” a nice "show don't tell" documentation approach.

Compared to roxabi's monorepo (`apps/`, `packages/`, `tools/`, `scripts/`, `docs/`), nanobot is flatter and simpler. The `workspace/` pattern is worth borrowing for AI-augmented projects.

### 5. Tech Stack & Tooling ðŸŸ¡

| Aspect | nanobot | roxabi_boilerplate |
|--------|---------|-------------------|
| Runtime | Python 3.11+ | Bun 1.3.9 + Node 24 |
| Package manager | uv | bun |
| Language | Python (strict ruff) | TypeScript 5.x (strict) |
| Linter/formatter | ruff | Biome |
| Build backend | hatchling | TurboRepo |
| CLI framework | Typer | N/A |
| LLM abstraction | litellm | N/A (not yet) |
| Config | Pydantic settings | N/A (env vars) |
| Packaging | PyPI-ready (nanobot-ai) | Private monorepo |

Both stacks are idiomatic for their language ecosystems. The stacks are complementary rather than competing â€” nanobot is Python, roxabi is TypeScript. Notable picks worth considering for roxabi:

- **litellm**: Universal LLM provider abstraction â€” if roxabi ever adds AI features, `litellm` (or its JS equivalent) is the right pattern.
- **Typer**: Elegant Python CLI framework with auto-help generation. Roxabi has no CLI equivalent.
- **Pydantic settings**: Type-safe config validation at startup. Roxabi could benefit from similar env-var schema enforcement (currently uses custom `check-env-sync.ts`).

### 6. Developer Experience (DX) ðŸŸ¢

nanobot has genuinely excellent onboarding friction â€” arguably better than roxabi for its use case:

**3-step quick start:**
```bash
pip install nanobot-ai  # or uv add nanobot-ai
nanobot onboard         # creates ~/.nanobot/config.json interactively
nanobot agent           # start the CLI assistant
```

Or for chat integration:
```bash
nanobot gateway         # start multi-channel gateway
```

**Docker:** Single `Dockerfile` with Python + Node.js in one image, exposing port 18790. `docker run` is straightforward.

**Config approach:** One JSON file at `~/.nanobot/config.json` â€” no `.env` file proliferation. The `nanobot onboard` interactive wizard generates it.

**Workspace customization:** The `workspace/SOUL.md`, `AGENTS.md`, etc. are directly editable markdown files that the agent reads. No restart required for persona changes â€” the context is re-read each session.

**Weaknesses:** No hot-reload for development. No `docker-compose.yml` (you run it standalone). No dev vs prod config separation.

Compared to roxabi (which requires `bun install`, Docker for postgres, multiple env files, codegen steps), nanobot's DX is simpler â€” but it's solving a simpler problem.

### 7. Testing Strategy ðŸ”´

nanobot's testing is minimal and not enforced:

- **6 test files** in `tests/`: `test_cli_input.py`, `test_commands.py`, `test_consolidate_offset.py`, `test_docker.sh`, `test_email_channel.py`, `test_tool_validation.py`.
- **No CI test stage** â€” tests are not run in any automated pipeline.
- **No coverage targets** â€” `pytest-cov` is in dev dependencies but no `--cov` in pytest config.
- **No integration test infrastructure** â€” despite having many channel integrations and LLM providers, no mocking framework is visible.
- **Framework:** pytest with asyncio mode, which is appropriate.

This is a significant weakness. A project with 20k+ stars shipping without test automation creates risk for contributors.

Compared to roxabi's mature testing setup (Vitest + Playwright, coverage reports on PRs, postgres service in CI, schema drift detection), nanobot's testing is underdeveloped.

### 8. CI/CD Pipelines ðŸ”´

nanobot has **no CI/CD pipeline**. There are no `.github/workflows/` files in the repository.

The only automation artifact is a `Dockerfile` for manual deployment. No automated:
- Lint checks
- Type checks (ruff handles lint, but no `mypy` in CI)
- Test runs
- Version bumping or release automation
- Docker image publishing

Given the project's 20k+ stars and active community (multiple PRs merged daily), the absence of CI is a significant quality risk. Contributors cannot verify their changes don't break existing functionality.

Compared to roxabi's comprehensive CI (Biome lint, typecheck, Vitest unit+integration, Playwright E2E, Turbo build, coverage reports, schema drift detection, preview deploys), nanobot is dramatically behind.

### 9. Documentation Quality ðŸŸ¡

**Strengths:**
- **README** is well-structured with animated GIF demos (`case/` directory), platform icons, installation steps, and provider configuration examples.
- **`workspace/` markdown files** serve as living documentation that the agent itself reads â€” `TOOLS.md` documents all available tools, `AGENTS.md` documents agent behavior guidelines. This "documentation as agent context" pattern is novel.
- **`SKILL.md` files** in each skill directory serve as both documentation and the actual skill implementation (system prompt injection).
- **`SECURITY.md`** exists with vulnerability reporting instructions.
- **`COMMUNICATION.md`** provides community QR codes (WeChat/Feishu).

**Weaknesses:**
- No `CHANGELOG.md` or release notes.
- No architecture documentation (beyond a single `nanobot_arch.png` image).
- No contributing guide.
- No API documentation.
- Code comments exist but are sparse.

Compared to roxabi's extensive `docs/` (MDX, architecture, standards, processes, contributing guide, changelog), nanobot's documentation is lighter but more focused on the user-facing README.

### 10. Unique / Novel Ideas ðŸŸ¢

nanobot has several genuinely clever ideas worth studying:

1. **HEARTBEAT.md as a periodic task scheduler** â€” The agent checks a markdown file every 30 minutes and executes any unchecked `[ ]` items as agent prompts. This is a brilliant human-readable cron system: no YAML, no cron syntax, just markdown checkboxes edited directly by the user or the agent itself.

2. **SOUL.md as agent persona configuration** â€” Externalizing the agent's personality, values, and communication style into a user-editable markdown file (rather than hardcoding it in prompts) enables personalization without code changes. Analogous to a character sheet.

3. **workspace-as-runtime-state** â€” The `workspace/` directory serves as the agent's "brain": `SOUL.md` (persona), `AGENTS.md` (instructions), `TOOLS.md` (tool reference), `HEARTBEAT.md` (periodic tasks), `memory/MEMORY.md` (long-term facts), `memory/HISTORY.md` (event log). This convention transforms a directory into a fully human-inspectable and editable agent state.

4. **SKILL.md as a zero-code extension system** â€” Skills are pure markdown instructions injected into the system prompt. No Python code required to add a skill. Combined with ClawHub (a public skill registry browsable by natural language), this creates a viral skill marketplace without code dependencies.

5. **ClawHub skill registry** â€” A public NPM-based registry (`npx clawhub@latest search "web scraping"`) for distributing agent skills. Skills install to the workspace directory and are immediately active. The registry uses vector search for natural language discovery.

6. **`core_agent_lines.sh`** â€” A script that counts lines in the core agent modules to verify the "under 4,000 lines" promise is not broken. This is a self-imposed architectural constraint enforced by tooling â€” unusual and admirable.

7. **litellm as a universal LLM backend** â€” Using litellm gives access to 50+ providers through one interface. Switching providers requires changing one config value, not updating API call code.

8. **Mixed-language bridge pattern** â€” The WhatsApp integration requires Baileys (a Node.js library). Rather than reimplementing it in Python, nanobot ships a TypeScript bridge process that communicates over WebSocket. This is a pragmatic "use the right tool" decision that keeps the Python core clean.

### 11. What They Do Better Than roxabi_boilerplate

1. **Onboarding simplicity** â€” `pip install nanobot-ai && nanobot onboard` is dramatically simpler than roxabi's multi-step setup (bun install, Docker, env files, codegen). For a framework targeting developers, this is an important lesson.

2. **Convention-based workspace config** (`workspace/SOUL.md`, `AGENTS.md`, `HEARTBEAT.md`) â€” roxabi has no equivalent pattern for AI-agent configuration. If roxabi adds AI features, this directory-as-state convention is worth adopting.

3. **Skill system extensibility** â€” The `SKILL.md` convention (zero-code skill injection) is more accessible than code-level extensions. Roxabi's `.claude/skills/` uses a similar pattern for Claude Code skills, but nanobot applies it to the runtime agent itself.

4. **LLM provider abstraction via litellm** â€” roxabi has no LLM abstraction layer. If AI features are added, nanobot's litellm-backed `LLMProvider` interface (with `providers/base.py` + `providers/registry.py`) is a clean reference implementation.

5. **Packaged as a CLI tool** (`pip install nanobot-ai`) â€” nanobot is installable and runnable as a system tool. Roxabi has no installable CLI equivalent.

6. **Self-imposed size constraint enforced by tooling** (`core_agent_lines.sh`) â€” A novel way to prevent architecture drift. Roxabi has no equivalent mechanism for preventing complexity creep in a specific module.

### 12. What They Do Better Than 2ndBrain

2ndBrain (`/home/mickael/projects/2ndBrain/`) is a personal productivity system with Google Workspace automation, knowledge management, and a Telegram bot â€” overlapping significantly with nanobot's domain.

nanobot outperforms 2ndBrain in:

1. **Platform breadth** â€” nanobot supports 9 chat channels (Telegram, Discord, WhatsApp, Slack, email, DingTalk, Feishu, QQ, Mochat). 2ndBrain supports only Telegram.

2. **Packaged distribution** â€” nanobot is installable via `pip install nanobot-ai`. 2ndBrain requires cloning the repo, `uv sync`, and manual setup.

3. **LLM abstraction** â€” nanobot supports 50+ providers via litellm. 2ndBrain uses the Anthropic SDK directly with no provider abstraction.

4. **Skill registry** â€” nanobot's ClawHub registry enables community-contributed skills. 2ndBrain's Claude skills are local `.claude/skills/` scripts with no registry concept.

5. **Subagent spawning** â€” nanobot's `SpawnTool` enables parallel background tasks. 2ndBrain has no equivalent.

6. **HEARTBEAT.md pattern** â€” nanobot's periodic task system is more elegant than 2ndBrain's supervisor-based background processes.

**Where 2ndBrain is stronger than nanobot:**
- **Testing**: 2ndBrain has `tests/unit/`, `tests/integration/`, `tests/benchmarks/` with pytest markers. nanobot has 6 minimal test files with no CI enforcement.
- **CI/CD**: 2ndBrain has `.github/workflows/lint.yml` and `.github/workflows/tests.yml`. nanobot has neither.
- **Knowledge management**: 2ndBrain has sqlite-vec embeddings and sentence-transformers for semantic search. nanobot's memory is flat markdown files.
- **Google Workspace integration**: 2ndBrain has deep Google Calendar/Gmail/Drive integration. nanobot has no equivalent.

### 13. Key Takeaways

**Top actionable items ranked by priority:**

#### Must-Have

1. **Adopt the HEARTBEAT.md pattern for periodic AI tasks** â€” A markdown file checked on a schedule, with `[ ]` items executed as agent prompts, is a beautifully simple task scheduler. Roxabi could use this for automated background AI tasks (e.g., "review open PRs daily", "summarize new issues weekly"). Propose: create a `workspace/HEARTBEAT.md` convention in the roxabi AI integration layer.

2. **Evaluate litellm for the AI integration layer** â€” If roxabi plans any AI features (code generation, PR summaries, issue triage), use litellm as the LLM provider abstraction. The nanobot `providers/base.py` + `providers/registry.py` pattern is a clean 50-line reference implementation. Avoids vendor lock-in from day one.

#### Nice-to-Have

3. **Adopt SOUL.md / workspace persona convention for AI agent configuration** â€” The pattern of storing agent persona, instructions, and long-term memory as human-editable markdown files in a `workspace/` directory is more transparent and hackable than JSON config. Roxabi's `.claude/` directory already uses a similar convention; formalizing it as `workspace/` could improve the AI team story.

4. **Add a `core_lines.sh` budget enforcer for critical modules** â€” The idea of a shell script that counts lines in a specific module and fails if exceeded is a lightweight way to enforce architectural constraints. Roxabi could apply this to `packages/types/` or critical shared modules to prevent them from becoming God objects.

5. **Study ClawHub's skill registry architecture** â€” If roxabi evolves toward an AI integration marketplace or plugin system, ClawHub's NPM-based skill registry (vector search, `install to workspace` semantics) is a proven distribution model worth examining before designing roxabi's own plugin architecture.

## What's next?

- **Create GitHub issue**: "Explore litellm for AI provider abstraction layer" â€” evaluate litellm as the LLM backend if/when roxabi adds AI features.
- **Create GitHub issue**: "Design HEARTBEAT.md convention for scheduled AI tasks" â€” define the workspace-as-runtime-state pattern for the roxabi AI team integration.
- **Reference nanobot's `providers/`** when designing roxabi's AI integration: `providers/base.py`, `providers/registry.py`, `providers/litellm_provider.py` are clean 100-line reference implementations.
- **Note:** nanobot's absence of CI/CD is a warning against fast-moving projects shipping without automation. Roxabi's CI investment is validated by contrast.
