---
title: "Brainstorm: NanoClaw Analysis"
description: Analysis of qwibitai/nanoclaw for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#217](https://github.com/roxabi/boilerplate/issues/217)
**Repository:** [qwibitai/nanoclaw](https://github.com/qwibitai/nanoclaw)
**Stars / Activity:** 8,956 stars, 1,200 forks, last commit 2026-02-16

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Personal AI assistant via WhatsApp/containers â€” different domain than SaaS boilerplate |
| How it works | ðŸŸ¢ | Single-process container isolation model is elegant and understandable in minutes |
| Architecture | ðŸŸ¢ | Radical minimalism with per-group container sandboxing is novel and inspiring |
| File structure | ðŸŸ¡ | Flat single-app layout vs roxabi monorepo â€” different scale, both well-organized |
| Tech stack | ðŸŸ¡ | Node/npm/Prettier vs Bun/TurboRepo/Biome â€” comparable TypeScript-first stacks |
| DX | ðŸŸ¢ | AI-native setup via `/setup` skill is a paradigm shift; zero onboarding friction |
| Testing | ðŸŸ¡ | Vitest with co-located test files; lighter than roxabi but appropriate for scope |
| CI/CD | ðŸŸ¡ | Minimal CI for a single-user tool; skills-only enforcement workflow is novel |
| Documentation | ðŸŸ¢ | Architecture docs, SECURITY.md, REQUIREMENTS.md, debug checklist â€” highly structured |
| Unique ideas | ðŸŸ¢ | Skills-over-features philosophy, token count badge, per-repo context budget, AI-native UX |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

NanoClaw is a personal Claude AI assistant that runs in OS-level containers for security. It connects to WhatsApp (via the Baileys library), routes messages to Claude Agent SDK instances running in isolated Linux containers, supports per-group memory, scheduled tasks, and web access.

- **Purpose:** Replace bloated multi-user AI assistants (targets OpenClaw/Clawdbot specifically) with a codebase small enough to read, understand, and customize in under 10 minutes
- **Target audience:** Individual power users who want AI automation via chat but distrust opaque, complex software
- **Problem it solves:** "I can't sleep well running software I don't understand with access to my life" â€” the software minimalism and auditability problem in AI tooling

**Vs roxabi:** Different domain. Roxabi is a multi-tenant SaaS framework; NanoClaw is a single-user personal automation tool. The goals are orthogonal, but NanoClaw contains philosophy and patterns highly applicable to roxabi's agent team and skills infrastructure.

**Vs 2ndBrain:** Closer comparison. Both are personal AI assistant platforms. 2ndBrain uses Python + Telegram; NanoClaw uses TypeScript + WhatsApp. NanoClaw's container isolation model is significantly more secure than 2ndBrain's in-process Python execution.

### 2. How It Works ðŸŸ¢

Core flow: `WhatsApp (baileys) --> SQLite --> Polling loop --> Container (Claude Agent SDK) --> Response`

Single Node.js process that:
1. Maintains a persistent WhatsApp connection
2. Stores messages in SQLite
3. Polls for new messages matching a trigger pattern (default: `@Andy`)
4. Spawns an isolated container per message group, mounting only that group's directory
5. Runs Claude Code inside the container via the Anthropic Agent SDK
6. Reads responses via IPC filesystem watching
7. Routes responses back to WhatsApp

Key architectural decisions:
- **Per-group concurrency control** via `GroupQueue` prevents message flooding
- **IPC via filesystem** (`src/ipc.ts`) keeps the architecture simple and debuggable
- **Session persistence** in SQLite keeps full conversation context across restarts
- **Ephemeral containers** (`--rm`) mean fresh execution environment per invocation

This is noticeably simpler and more auditable than roxabi's multi-tier architecture, which is appropriate given the single-user scope.

### 3. Architecture & Layers ðŸŸ¢

**Architecture type:** Single-process monolith with container-per-agent sandboxing

**Layers:**
- Transport: WhatsApp Baileys library in `src/channels/`
- Orchestration: `src/index.ts` â€” state machine, message loop
- Routing: `src/router.ts` â€” message formatting + outbound
- Queue: `src/group-queue.ts` â€” per-group concurrency
- Agent runtime: `src/container-runner.ts` â€” spawns containers with Claude Code
- Scheduling: `src/task-scheduler.ts`
- Persistence: `src/db.ts` â€” SQLite via better-sqlite3
- IPC: `src/ipc.ts` â€” filesystem watcher for agent output
- Security boundary: OS container isolation (Apple Container / Docker)

**Notable pattern: Trust-by-mount.** Rather than application-level permission checks, security is enforced by what directories are physically mounted into each container. The main channel gets full project access; non-main groups only see their own folder. This is a fundamentally different security model than roxabi's JWT + RLS approach.

**Notable pattern: Agent Swarms.** NanoClaw claims to be the first personal assistant supporting Agent Teams â€” multiple Claude Code instances collaborating on a task. The `.claude/skills/add-parallel/` skill enables this.

### 4. File / Project Structure ðŸŸ¡

```
nanoclaw/
  src/                    # All TypeScript source (flat â€” ~12 files + 1 subdir)
    channels/             # Channel implementations (whatsapp.ts)
    *.ts                  # index, db, ipc, router, queue, scheduler, container-runner...
    *.test.ts             # Co-located test files
  container/              # Docker/Apple Container definitions
    Dockerfile
    build.sh
    agent-runner/         # Container runtime entry point
    skills/               # Container-level skills (agent-browser)
  .claude/skills/         # Claude Code skills (setup, debug, customize, add-*)
  groups/                 # Per-group CLAUDE.md memory (created at runtime)
  docs/                   # SECURITY.md, REQUIREMENTS.md, SPEC.md, SDK_DEEP_DIVE.md
  config-examples/        # Sample mount configurations
  repo-tokens/            # Token count badge automation
  launchd/                # macOS LaunchAgent plist
  assets/                 # Logo
```

**Strengths:**
- Extremely flat â€” everything in `src/` is visible at a glance
- Test files co-located with source (no separate `tests/` directory)
- Clear separation between host code (`src/`) and container code (`container/`)

**Vs roxabi:** Roxabi's monorepo with `apps/` + `packages/` is appropriate for a multi-app, multi-tenant SaaS. NanoClaw's flat structure is appropriate for a single-user single-process tool. Both are well-matched to their scope.

### 5. Tech Stack & Tooling ðŸŸ¡

| Dimension | NanoClaw | roxabi |
|-----------|----------|--------|
| Runtime | Node.js 20+ | Bun 1.x |
| Language | TypeScript 5.7 strict | TypeScript 5.x strict |
| Package manager | npm (package-lock.json) | Bun |
| Formatter | Prettier | Biome |
| Linter | (none explicit â€” Prettier only) | Biome |
| Bundler | tsc | tsc + Vite (Nitro) |
| Test framework | Vitest | Vitest + Playwright |
| Monorepo | None (single app) | TurboRepo |
| Database | SQLite (better-sqlite3) | PostgreSQL + Drizzle |
| Frontend | None | TanStack Start |
| Backend | None (single process) | NestJS + Fastify |

Notable difference: NanoClaw has no linter. Prettier formats but doesn't catch code quality issues. Roxabi's Biome gives both. This is a small gap for a project this size but would matter more at scale.

NanoClaw uses npm while roxabi uses Bun â€” for a project this small the difference is negligible, but it's a conscious "widest compatibility" choice.

### 6. Developer Experience (DX) ðŸŸ¢

**AI-native setup** is the standout DX feature. The entire onboarding is:

```bash
git clone https://github.com/gavrielc/nanoclaw.git
cd nanoclaw
claude
```

Then run `/setup`. Claude Code handles: dependency installation, WhatsApp authentication, container build, service configuration (launchd/systemd). There is no installation wizard, no documentation to follow step-by-step. This is a fundamentally different philosophy than roxabi's documented setup process.

**Customization as AI conversation:** Want to change behavior? Tell Claude Code in natural language. The codebase is small enough that Claude can safely modify it. No config file system to learn.

**Skills as guided transformations:** `/add-gmail`, `/add-telegram`, `/customize`, `/debug` â€” these are markdown instruction files that Claude Code executes. Users get clean code that does exactly what they need, not a bloated system with feature flags.

**Token count badge in README:** A live badge showing `34.9k tokens, 17% of context window`. This is a signal to AI agents about the budget they're consuming. Novel and practical for AI-native repos.

**Repo-tokens GitHub Action:** Automatically updates the token count badge on every push to main when source files change. A workflow we haven't seen elsewhere.

**`/debug` skill:** A dedicated debugging skill that Claude runs to diagnose issues â€” rather than a troubleshooting doc, it's an executable investigation procedure.

**Vs roxabi:** Roxabi's DX is strong (Biome auto-format, lefthook hooks, comprehensive docs) but still human-driven. NanoClaw's DX is AI-driven â€” a paradigm shift worth exploring for roxabi's onboarding flow.

### 7. Testing Strategy ðŸŸ¡

Tests are co-located with source in `src/*.test.ts`:

- `src/container-runner.test.ts`
- `src/db.test.ts`
- `src/formatting.test.ts`
- `src/group-queue.test.ts`
- `src/ipc-auth.test.ts`
- `src/routing.test.ts`

Uses Vitest with `@vitest/coverage-v8`. The vitest config is minimal:

```typescript
export default defineConfig({
  test: {
    include: ['src/**/*.test.ts'],
  },
});
```

No coverage thresholds, no e2e tests (appropriate â€” the "e2e" is WhatsApp itself). CI runs `npx vitest run` on PRs to main.

**Vs roxabi:** Roxabi has unit tests, integration tests with real Postgres, e2e with Playwright, coverage reporting on PRs, and enforced via pre-push hooks. NanoClaw's testing is lighter but appropriate for its scope and single-user audience.

**Vs 2ndBrain:** 2ndBrain uses pytest with similar lightweight coverage. NanoClaw is comparable but in TypeScript.

### 8. CI/CD Pipelines ðŸŸ¡

Three GitHub Actions workflows:

**`test.yml`** â€” Runs on PRs to main:
- Checkout, Node 20 setup, npm ci
- TypeScript check (`tsc --noEmit`)
- Vitest run

**`skills-only.yml`** â€” Enforces contribution model:
- Detects if a PR adds new skill files AND modifies source
- Blocks such PRs with a descriptive comment: "A skill PR should not change source files"
- Posts automated PR comment explaining the policy

**`update-tokens.yml`** â€” Maintains token count badge:
- Triggers on push to main when source files change
- Uses a custom GitHub Action (`repo-tokens/`) to count tokens
- Commits updated badge and README automatically via GitHub App token

No deployment pipeline â€” NanoClaw runs as a local service managed by launchd/systemd, not cloud-deployed.

**The `skills-only.yml` workflow is uniquely valuable** â€” it enforces the project's contribution philosophy at the CI level. Roxabi has no equivalent enforcement for its skills/agents contribution model.

**Vs roxabi:** Roxabi's CI is significantly more comprehensive (lint + typecheck + test + build + e2e, Turbo caching, schema drift detection, coverage reporting). NanoClaw's CI is minimal but entirely appropriate for a personal tool with no deployment pipeline.

### 9. Documentation Quality ðŸŸ¢

NanoClaw's documentation is well-structured for its size and philosophically coherent:

**`README.md`:**
- Clear "Why I Built This" section naming the competitor (OpenClaw) with specific criticism
- "Philosophy" section with 6 named principles (Small enough to understand, Secure by isolation, Built for one user, etc.)
- Architecture diagram in ASCII
- Key files table with one-line descriptions
- FAQ addressing likely user questions preemptively
- "Request for Skills" section driving community contributions

**`docs/` directory:**
- `SECURITY.md` â€” Full threat model with trust levels, security diagrams, privilege comparison tables, and honest known limitations ("PRs welcome if you have ideas for credential isolation")
- `REQUIREMENTS.md` â€” Architecture decision records
- `SPEC.md` â€” Feature specification
- `SDK_DEEP_DIVE.md` â€” In-depth documentation on the Anthropic Agent SDK behavior
- `DEBUG_CHECKLIST.md` â€” Diagnostic procedure

**`CLAUDE.md`** â€” Concise AI-context file with key file table, skills table, and development commands. Less comprehensive than roxabi's but tightly focused.

**`CONTRIBUTING.md`** â€” One page. "Don't add features. Add skills." Extremely clear contribution philosophy.

**`README_zh.md`** â€” Chinese translation of the README.

**Token count badge in README** â€” Unique signal for AI consumers of the repo.

**Vs roxabi:** Roxabi's documentation is more comprehensive for a multi-developer team (architecture docs, standards docs, dev process). NanoClaw's is more opinionated and memorable for a single-user tool. NanoClaw's SECURITY.md is notably more thorough than anything in roxabi's docs dir.

**Vs 2ndBrain:** 2ndBrain has extensive docs (`docs/` with architecture, configuration, deployment, monitoring). NanoClaw is comparable in structure; 2ndBrain goes deeper on operational topics while NanoClaw has the superior security documentation.

### 10. Unique / Novel Ideas ðŸŸ¢

**1. Skills-over-features contribution model**
Contributors submit SKILL.md files (AI instructions) rather than code. A CI check enforces this. Users run `/add-telegram` and get clean code that does exactly what they need, not a system supporting every use case. This prevents feature bloat at the architectural level.

**2. Token count badge as first-class repo metadata**
`repo-tokens/badge.svg` is auto-generated and displayed in the README: `34.9k tokens, 17% of context window`. This communicates AI context budget to any agent working with the repo. Implemented as a reusable GitHub Action in `repo-tokens/`.

**3. AI-native onboarding (`/setup` skill)**
No installation wizard. No documentation to follow. `claude` + `/setup` is the entire onboarding. Claude Code handles everything. This is the correct end-state for AI-native tools.

**4. Trust-by-mount security model**
Security enforced by filesystem mount policy rather than application-level permission checks. The security boundary is the OS container, not a middleware layer. Simpler, more auditable, harder to accidentally bypass.

**5. Per-group memory isolation (`groups/*/CLAUDE.md`)**
Each conversation context (WhatsApp group) has its own `CLAUDE.md`, its own mounted filesystem, and its own container session. Groups are isolated from each other at the OS level â€” one group cannot read another's memory.

**6. `SDK_DEEP_DIVE.md`**
A document that captures deep behavioral knowledge about the Anthropic Agent SDK (not just public docs) â€” how sessions work, how containers interact with it, undocumented behaviors. This is community knowledge documentation of the kind that's hard to find.

**7. `/debug` as executable diagnostic rather than documentation**
Rather than a troubleshooting FAQ, the `/debug` skill runs an investigation procedure. Claude diagnoses the issue rather than the user reading docs.

**8. Chinese README (`README_zh.md`)**
Internationalization of documentation at the community contribution level.

### 11. What They Do Better Than roxabi_boilerplate

**A. Skills enforcement in CI (`skills-only.yml`)**
NanoClaw's CI blocks PRs that mix skill additions with source changes. Roxabi has a skills system but no automated enforcement of skills-vs-source discipline. Adopting a similar check would strengthen roxabi's contribution model.

**B. Token count badge / repo-tokens automation**
Roxabi has no awareness of its own AI-context footprint. Adding a token count badge to the README and an auto-update workflow would be immediately useful for agents working in the codebase. The `repo-tokens/` GitHub Action is open source.

**C. Security.mdx documentation**
Roxabi has no dedicated security documentation. NanoClaw's `SECURITY.md` with trust model tables, security diagrams, mount policies, and honest limitations is exemplary. Roxabi should have an equivalent covering auth, RLS, API security, and secrets management.

**D. `/debug` skill paradigm**
Roxabi's troubleshooting is in static docs. Adopting the executable debug skill pattern would let Claude diagnose issues rather than users reading docs. A `debug` skill covering DB connection issues, service failures, and CI problems would be high-value.

**E. `CLAUDE.md` key-files table**
NanoClaw's CLAUDE.md has a compact `| File | Purpose |` table as the first section. Roxabi's CLAUDE.md is comprehensive but navigating it to find a specific file's purpose requires reading through multiple sections. A key-files table at the top would improve agent efficiency.

### 12. What They Do Better Than 2ndBrain

**A. Security model depth**
2ndBrain runs agents in-process (Python subprocess or inline execution). NanoClaw sandboxes every agent invocation in a separate container with explicit mount policies. The security boundary is fundamentally stronger. 2ndBrain's docs have no equivalent of NanoClaw's `SECURITY.md`.

**B. Skills-over-features philosophy**
2ndBrain adds features to the codebase (Gmail integration, Telegram bot, knowledge base, CV generation are all first-class code). NanoClaw's architecture keeps the core minimal and adds capabilities via skills. As 2ndBrain scales, this difference will compound â€” NanoClaw's approach produces less coupling and more user-specific customization.

**C. Per-session isolation**
2ndBrain uses a single global knowledge base and session store. NanoClaw isolates each group's memory, session history, and filesystem. This prevents cross-context contamination and improves privacy.

**D. AI-native UX (`/setup` + customization via conversation)**
2ndBrain's setup requires reading documentation and configuring environment variables manually. NanoClaw's `/setup` skill handles the full setup flow. This is a meaningful DX gap.

**Cross-reference with roxabi comparison:** The security, skills philosophy, and AI-native UX strengths are the same across both comparisons. These are NanoClaw's core innovations.

### 13. Key Takeaways

**Priority 1 â€” Must Have**

**A. Token count badge + `repo-tokens` automation**
Add a token count badge to roxabi's README tracking how much context the codebase consumes. Implement the update-tokens CI workflow from `qwibitai/nanoclaw`. This is immediately useful for every agent session and takes ~2 hours to implement.
- Candidate issue: "chore: add repo-token-count badge and CI automation"

**B. Skills-only CI check**
Add a GitHub Actions workflow that blocks PRs mixing skill additions with source changes. Adapt nanoclaw's `skills-only.yml` for roxabi's `.claude/skills/` directory. Enforces the contribution model without relying on documentation alone.
- Candidate issue: "ci: add skills-vs-source PR enforcement workflow"

**Priority 2 â€” High Value**

**C. `SECURITY.mdx` documentation**
Produce a security documentation page covering roxabi's threat model: JWT authentication, RLS policies, API security, secrets management, dependency audit. Modeled after nanoclaw's `SECURITY.md` with trust-level tables, security diagrams, and honest known limitations.
- Candidate issue: "docs: add security model documentation"

**D. Executable `/debug` skill**
Create a `debug` skill in `.claude/skills/debug/SKILL.md` that Claude runs to diagnose common issues (DB connection, API/web service startup, migration state, CI failures). Replaces static troubleshooting docs with an AI-executable investigation procedure.
- Candidate issue: "feat(skills): add /debug diagnostic skill"

**Priority 3 â€” Nice to Have**

**E. Key-files table in CLAUDE.md**
Add a `| File | Purpose |` quick-reference table near the top of `CLAUDE.md` covering the most important files across `apps/` and `packages/`. Reduces agent navigation time when first loading context.
- Candidate issue: "docs: add key-files quick reference table to CLAUDE.md"

## What's next?

- Create GitHub issue for token-count badge + `repo-tokens` CI automation (Priority 1A â€” highest ROI, minimal effort)
- Create GitHub issue for skills-only CI enforcement (Priority 1B â€” enforces existing contribution model)
- Evaluate adopting the `repo-tokens` GitHub Action directly from the nanoclaw repo vs building an equivalent
- Review NanoClaw's `docs/SDK_DEEP_DIVE.md` for Anthropic Agent SDK behavioral insights that could inform roxabi's agent team implementation
- Consider whether roxabi's skills philosophy warrants the same contribution-enforcement discipline as NanoClaw
