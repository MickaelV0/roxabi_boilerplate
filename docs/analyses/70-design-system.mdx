---
title: "#70 Design System & Theme Customization"
description: Analysis of the design system page, interactive playground, and full branding customization for the Roxabi boilerplate.
---

## Context

Issue #48 (UI Component Library) is complete: Shadcn/UI is configured, 20 components live in `packages/ui`, and light/dark mode works via OKLch CSS variables. However, there is no **visible design system page**, no **interactive playground** to explore components, and no **theme customization** beyond the light/dark toggle.

This analysis explores what it takes to build:
1. A public `/design-system` page with an interactive component playground
2. A theme editor (admin UI) for full branding customization
3. Theme persistence and runtime application

## Current State

### What Exists

| Area | Status | Details |
|------|--------|---------|
| Color tokens | Done | OKLch CSS variables in `packages/ui/src/theme.css` (30+ variables) |
| Dark mode | Done | `.dark` class via `next-themes` + fumadocs RootProvider |
| Components | Done | 20 Shadcn components in `packages/ui/src/components/` |
| Tailwind integration | Done | CSS vars mapped to Tailwind tokens via `@theme inline` |
| Design system page | Missing | No `/design-system` route |
| Theme customization | Missing | Only light/dark toggle, no branding control |
| Component playground | Missing | No interactive preview |
| Theme persistence | Missing | No storage for custom themes |

### Current Token Architecture

```
packages/ui/src/theme.css
├── :root (light mode)
│   ├── --background, --foreground
│   ├── --primary, --primary-foreground
│   ├── --secondary, --secondary-foreground
│   ├── --muted, --muted-foreground
│   ├── --accent, --accent-foreground
│   ├── --destructive, --destructive-foreground
│   ├── --border, --input, --ring
│   ├── --chart-1 through --chart-5
│   ├── --sidebar-* (7 variables)
│   └── --radius (+ sm, md, lg, xl)
├── .dark (dark mode overrides)
└── @theme inline (Tailwind mapping)
```

## Questions Explored

### 1. How should the `/design-system` page be structured?

**Recommendation: Single page with tabbed sections**

The page should be a public app route at `/design-system` with the following sections:

| Section | Content |
|---------|---------|
| **Theme Editor** (sidebar/panel) | Live controls to tweak all branding tokens |
| **Colors** | Color palette grid showing all semantic tokens with hex/oklch values |
| **Typography** | Font scale, weights, line heights rendered as examples |
| **Spacing & Radius** | Visual scale of spacing units and radius tokens |
| **Components** | Interactive playground for each component with prop controls |
| **Compositions** | Ready-made UI patterns (login form, settings card, notification stack) |

**Architecture:**
- Route: `apps/web/src/routes/design-system.tsx` (or nested `design-system/` folder)
- Components: render directly from `@repo/ui` — no duplication
- Theme editor state: React state with `CSS.setProperty()` for live preview

### 2. How should the interactive playground work?

**Recommendation: Prop-driven live preview per component**

Each component section should have:
- A **rendered preview** area showing the component
- **Controls** to toggle props (variant, size, disabled, etc.)
- A **code snippet** showing the current usage

**Implementation approach:**
- Define a `ComponentShowcase` wrapper that takes a component config (available props, variants)
- Use `useState` for each prop, render the component with current props
- No need for Storybook — a custom lightweight playground is simpler and more integrated

**For compositions**, show pre-built patterns:
- Auth: Login form, signup form, forgot password
- Feedback: Toast/alert notification, empty state, error page
- Data: Stat card, simple table, profile card

### 3. How should the theme editor work?

**Recommendation: Side panel with grouped token controls**

The theme editor should be a **collapsible side panel** on the `/design-system` page with:

| Token Group | Controls |
|-------------|----------|
| **Colors** | Color pickers for primary, secondary, accent, destructive, muted, background, foreground |
| **Typography** | Font family selector (dropdown), base font size (slider) |
| **Border radius** | Slider for base radius (auto-calculates sm/md/lg/xl) |
| **Shadows** | Preset selector (none, subtle, medium, strong) |

**Live preview mechanism:**
```
User picks color → Convert to OKLch → document.documentElement.style.setProperty('--primary', value) → All components update instantly
```

This avoids rebuilds — CSS variables cascade immediately.

### 4. How should themes be persisted?

**Options analysis:**

| Approach | Pros | Cons | Best for |
|----------|------|------|----------|
| **Database (API)** | Survives deploys, shared across sessions, API-driven | Requires auth + API endpoint, loading delay | Production SaaS |
| **LocalStorage** | Simple, instant, no backend needed | Per-browser, lost on clear | Development/preview |
| **Config file** | Version-controllable, no runtime cost | Requires rebuild, not user-friendly | Developer-only themes |

**Recommendation: Database with localStorage fallback**

- **Phase 1**: localStorage for the playground (instant, no backend dependency)
- **Phase 2**: Database persistence via API once Auth (#19) and Admin Panel (#25) are built
- **Runtime**: On app load, fetch theme from API → apply CSS variables → fallback to defaults

**Theme data shape:**
```typescript
interface ThemeConfig {
  name: string
  colors: {
    primary: string       // OKLch value
    secondary: string
    accent: string
    destructive: string
    muted: string
    background: string
    foreground: string
    border: string
  }
  typography: {
    fontFamily: string
    baseFontSize: string  // e.g., "16px"
  }
  radius: string          // e.g., "0.625rem"
  shadows: "none" | "subtle" | "medium" | "strong"
}
```

### 5. How should preset themes work?

**Recommendation: Ship 3-4 built-in presets + reset to default**

| Preset | Description |
|--------|-------------|
| **Default** | Current zinc-based theme (the reset target) |
| **Ocean** | Blue primary, cool grays, rounded |
| **Warm** | Amber/orange primary, warm neutrals |
| **Minimal** | Monochrome, sharp radius, no shadows |

Presets are hardcoded `ThemeConfig` objects. Selecting one applies all its values. The "Reset to default" button is just applying the Default preset.

### 6. What about the admin UI for non-dev branding?

**Recommendation: Defer to Admin Panel (#25)**

The `/design-system` page serves **developers** (internal). The admin-facing theme customization belongs in the **Admin Panel** (#25) and should reuse the same `ThemeEditor` component. This avoids building two UIs.

**Phased approach:**
1. **Now**: `/design-system` page with playground + theme editor (localStorage)
2. **With Auth (#19)**: Add API endpoint for theme CRUD
3. **With Admin (#25)**: Embed ThemeEditor in admin panel with DB persistence

## Technical Decisions

### Color picker: OKLch handling

The current theme uses OKLch, which most color pickers don't support natively. Options:

| Approach | Recommendation |
|----------|---------------|
| Convert to hex for picker, back to OKLch on save | **Recommended** — best UX |
| Use an OKLch-aware picker library | Niche, fewer options |
| Switch to HSL | Loses perceptual uniformity |

Use a standard hex color picker + `culori` or `colorjs.io` library for hex ↔ OKLch conversion.

### Component playground: Build vs library

| Option | Pros | Cons |
|--------|------|------|
| **Custom built** | Lightweight, integrated, no extra deps | More code to maintain |
| **Storybook** | Industry standard, addon ecosystem | Heavy (100MB+), separate build process, not in-app |
| **Ladle** | Lighter than Storybook | Still separate process |

**Recommendation: Custom built**. For an internal dev tool, a custom page is simpler, faster, and lives inside the app. No separate build or tooling needed.

### Asset uploads (logo, favicon)

Deferred to a future iteration. Focus on CSS tokens first. When ready:
- Logo: Store URL in theme config, render via `&lt;img>` in Header
- Favicon: Dynamic `&lt;link>` tag in `&lt;head>`

## Proposed Architecture

```
apps/web/src/routes/
└── design-system/
    ├── index.tsx              # Main layout: sidebar + content
    ├── -components/           # Route-specific components (not routes)
    │   ├── ThemeEditor.tsx    # Side panel with token controls
    │   ├── ColorPicker.tsx    # Hex picker + OKLch conversion
    │   ├── ComponentShowcase.tsx  # Wrapper for interactive preview
    │   ├── CodeSnippet.tsx    # Syntax-highlighted usage example
    │   └── compositions/     # Pre-built pattern examples
    │       ├── AuthForms.tsx
    │       ├── FeedbackPatterns.tsx
    │       └── DataDisplay.tsx
    └── ...

packages/ui/src/
├── theme.css                  # Design tokens (unchanged)
├── themes/                    # NEW: Preset theme configs
│   ├── default.ts
│   ├── ocean.ts
│   ├── warm.ts
│   └── minimal.ts
└── lib/
    ├── utils.ts               # Existing cn() utility
    └── theme.ts               # NEW: Theme types + apply/reset helpers
```

## Scope & Sizing

| Phase | Scope | Size | Depends on |
|-------|-------|------|------------|
| **Phase 1** | `/design-system` page + component playground + theme editor (localStorage) | **L** | #48 ✅ |
| **Phase 2** | Theme API endpoint + DB persistence | M | #19 (Auth) |
| **Phase 3** | Admin panel integration + asset uploads | M | #25 (Admin) |

Phase 1 is the scope of issue #70. It touches 10+ files (new route, multiple components, theme utilities, preset configs).

## Conclusions

1. **The `/design-system` page** should be a single public route with a theme editor sidebar and tabbed content sections (colors, typography, components, compositions)
2. **Interactive playground** should be custom-built (not Storybook) — lighter, integrated, no extra tooling
3. **Theme customization** works by overriding CSS variables at runtime — no rebuild needed
4. **Persistence** starts with localStorage (Phase 1), moves to database when Auth/Admin are ready
5. **Preset themes** (4 built-in) with reset-to-default provide a good starting experience
6. **OKLch ↔ hex conversion** is needed for the color picker — use `culori` or `colorjs.io`
7. **Compositions** (auth forms, feedback patterns) add significant value for developers copying patterns

## Next Steps

- [ ] Update issue #70 with refined requirements from this analysis
- [ ] Write a spec based on this analysis (Phase 1 scope)
- [ ] Determine exact composition patterns to include
- [ ] Evaluate `culori` vs `colorjs.io` for color conversion
- [ ] Decide on code snippet display library (e.g., `shiki` already used by Fumadocs)

## Open Questions

- Should the theme editor support **importing/exporting** theme JSON? (useful for sharing themes between instances)
- Should there be a **contrast checker** in the color picker to warn about WCAG violations?
- How should the theme loading work on first paint to avoid **FOUC** (flash of unstyled content)?
