---
title: "Analysis: Claude Code Agents & Skills Setup (Issue #12)"
description: Technical analysis for Roxabi Boilerplate infrastructure
---


## Executive Summary

This analysis explores the state of the art for AI coding assistants in 2025-2026 to define the optimal architecture for Claude Code agents and skills in the Roxabi Boilerplate. The field has evolved from single all-purpose AI assistants to orchestrated teams of specialized agents following the "one agent, one task" microservices pattern. We recommend a phased approach starting with essential skills (/commit, /pr, /review, /test) and gradually introducing specialized agents as the team's workflows mature.

## State of the Art

### Multi-Agent Architecture (2025-2026)

The agentic AI field is experiencing its "microservices revolution." Just as monolithic applications gave way to distributed service architectures, single all-purpose agents are being replaced by orchestrated teams of specialized agents. Leading organizations implement "puppeteer" orchestrators that coordinate specialist agents - a researcher gathers information, a coder implements solutions, an analyst validates results.

Key frameworks driving this evolution:
- **Claude Code 2.1.0**: Native subagents support, agent lifecycle hooks, hot-reloading of skills
- **CrewAI**: Open-source framework for multi-agent coordination
- **LangGraph**: Graph-based orchestration with visual debugging
- **AutoGen (Microsoft)**: Automated generation of code and workflows

### Protocol Standards

The **Model Context Protocol (MCP)** has become the accepted standard for agent-tool interaction. Originally introduced by Anthropic in November 2024, MCP was donated to the Agentic AI Foundation (AAIF) under the Linux Foundation in December 2025, with support from Anthropic, Block, OpenAI, and others. MCP provides a universal interface for reading files, executing functions, and handling contextual prompts.

### Claude Code Architecture

Claude Code follows a hierarchical structure:

```
~/.claude/                    # User-level (all projects)
├── CLAUDE.md                 # Global instructions
├── agents/                   # User subagents
└── skills/                   # User skills

project/.claude/              # Project-level
├── settings.json             # Hooks configuration
├── agents/                   # Project subagents
├── skills/                   # Project skills
├── commands/                 # Slash commands
└── processes/                # Workflow documentation
```

### Built-in Subagents

Claude Code includes three built-in subagents:
- **Explore**: Fast, read-only agent for searching and analyzing codebases
- **Plan**: Research agent used in plan mode to gather context
- **General-purpose**: Capable agent for complex, multi-step tasks

### Skill vs Command vs Agent

| Feature | Slash Command | Skill | Subagent |
|---------|---------------|-------|----------|
| Token usage | Always loaded | On-demand | Isolated context |
| Conversation access | Full | Configurable | Fork only |
| Tool restrictions | None | Configurable | Configurable |
| Use case | Quick actions | Specialized workflows | Complex delegated tasks |

### Best Practices from Other Tools

**Cursor AI (2026)**:
- Modular rules in `.cursor/rules/*.mdc` (under 500 lines each)
- "Plan Mode" with sequence: Research -> Clarify -> Plan -> Build
- MCP server integration for tool access

**Aider**:
- CONVENTIONS.md file loaded via `--read` flag
- Codebase mapping for large project navigation
- Prompt caching for efficiency

**GitHub Copilot**:
- Custom agents in `.github/agents/*.agent.md`
- Agent Skills via SKILL.md files (VS Code 1.108+)
- Organization-level shared agents in `.github-private` repository

### Prompt Engineering Patterns

Key patterns for code generation:
1. **Chain-of-thought**: Step-by-step reasoning before action
2. **Role-based**: "Act as a senior React developer"
3. **Few-shot examples**: Concrete input/output examples
4. **Leading words**: Starting with "import" or "SELECT" nudges correct patterns
5. **Semantic tags**: Using `<task>`, `<context>` for Claude specifically

---

## Three Options

### Option A: MVP Approach (Fastest to Implement)

**Description**: Focus on essential skills only, using slash commands rather than full subagents. Leverage built-in subagents (Explore, Plan) rather than creating custom ones.

**Implementation**:
```
.claude/
├── commands/                 # Existing
│   ├── issues.md            # Existing
│   ├── issue-triage.md      # Existing
│   ├── commit.md            # NEW - Simple commit workflow
│   ├── pr.md                # NEW - PR creation
│   ├── review.md            # NEW - Code review checklist
│   └── test.md              # NEW - Test generation prompt
├── skills/
│   └── interview/           # Existing
└── settings.json            # Existing hooks
```

**Skills to create**:
- `/commit` - Conventional commit with lint checks
- `/pr` - PR creation with template
- `/review` - Code review using built-in Explore
- `/test` - Test generation prompts

**Pros**:
- Can be implemented in 1-2 days
- Minimal complexity, easy to maintain
- Uses proven built-in subagents
- Low token overhead (commands loaded on-demand)
- Team can iterate based on actual usage

**Cons**:
- No specialized agent personas
- Limited workflow orchestration
- Manual context switching between tasks
- No agent-specific tool restrictions

**Complexity**: 2/5

---

### Option B: Gold Standard (Best Quality)

**Description**: Full multi-agent architecture with specialized subagents for each role, comprehensive skills library, workflow orchestration, and MCP server integration.

**Implementation**:
```
.claude/
├── agents/
│   ├── dev.md               # Feature implementation specialist
│   ├── review.md            # Code review & quality expert
│   ├── test.md              # Testing specialist
│   ├── deploy.md            # CI/CD expert
│   ├── product.md           # Product ownership
│   ├── frontend.md          # UI/UX specialist
│   ├── backend.md           # API/DB specialist
│   └── ops.md               # Infrastructure expert
├── skills/
│   ├── commit/SKILL.md      # Commit workflow with hooks
│   ├── pr/SKILL.md          # PR with template & checks
│   ├── review/SKILL.md      # Multi-pass review
│   ├── test/SKILL.md        # TDD workflow
│   ├── spec/SKILL.md        # Specification writer
│   ├── adr/SKILL.md         # Architecture Decision Records
│   └── _shared/             # Shared utilities
├── commands/
│   └── orchestrate.md       # Workflow orchestrator
├── processes/
│   ├── feature-flow.md      # Feature development workflow
│   ├── review-flow.md       # Review workflow
│   └── release-flow.md      # Release workflow
├── mcp/
│   └── servers.json         # MCP server configuration
└── settings.json            # Enhanced hooks
```

**Agent Configurations** (example for `agents/dev.md`):
```yaml
---
name: dev
description: Feature implementation specialist for TypeScript/Bun projects
tools: Read, Write, Edit, Bash, Glob, Grep
model: sonnet
---
# Dev Agent

You are a senior TypeScript developer working on a Bun/TurboRepo monorepo.

## Responsibilities
- Implement features following CLAUDE.md conventions
- Write clean, typed code with Biome formatting
- Create atomic commits with conventional messages

## Workflow
1. Understand requirements from spec/issue
2. Explore codebase with Grep/Glob
3. Plan implementation approach
4. Implement incrementally with tests
5. Run lint/typecheck before commits
```

**Pros**:
- Comprehensive coverage of all development roles
- Specialized context per agent reduces errors
- Workflow orchestration for complex tasks
- MCP integration for external tools
- Enterprise-grade architecture
- Scales well with team growth

**Cons**:
- 2-3 weeks implementation time
- Higher maintenance burden
- Steeper learning curve for team
- May be overkill for small team
- Token overhead from multiple agents

**Complexity**: 5/5

---

### Option C: Balanced Approach (Recommended)

**Description**: Start with core agents (Dev, Review, Test) and essential skills, with a clear extension pattern for adding more agents/skills as needed. Focus on immediate value while building foundation for growth.

**Implementation**:
```
.claude/
├── agents/
│   ├── dev.md               # Feature implementation (P1)
│   ├── review.md            # Code review (P1)
│   └── test.md              # Testing specialist (P1)
├── skills/
│   ├── commit/SKILL.md      # Commit with conventional format
│   ├── pr/SKILL.md          # PR creation workflow
│   ├── review/SKILL.md      # Code review workflow
│   ├── test/SKILL.md        # Test generation
│   ├── spec/SKILL.md        # Spec writing (uses /interview)
│   ├── adr/SKILL.md         # ADR creation
│   └── _shared/
│       ├── git-utils.md     # Existing
│       └── conventions.md   # Code conventions
├── commands/
│   ├── issues.md            # Existing
│   ├── issue-triage.md      # Existing
│   └── dev.md               # Quick dev workflow start
└── settings.json            # Enhanced hooks
```

**Phase 1 (Week 1)**: Core Skills
- `/commit` - Conventional commits with pre-checks
- `/pr` - PR creation with template
- `/review` - Code review workflow
- `/test` - Test generation

**Phase 2 (Week 2)**: Core Agents
- `dev.md` - Feature implementation agent
- `review.md` - Code review agent
- `test.md` - Testing agent

**Phase 3 (Week 3+)**: Extension as needed
- `/spec` and `/adr` skills
- Additional agents (deploy, product, frontend, backend)
- MCP integrations

**Skill Template** (example `skills/commit/SKILL.md`):
```yaml
---
argument-hint: [commit message or empty for interactive]
description: Create a conventional commit with pre-checks
allowed-tools: Bash, Read, Glob
---
# Commit

Create a conventional commit following project conventions.

## Process

1. **Pre-checks**:
   - Run `bun lint` to check formatting
   - Run `bun typecheck` to validate types
   - Fail early if checks don't pass

2. **Stage changes**:
   - Show `git status` and `git diff --staged`
   - Confirm files to commit

3. **Commit message**:
   - Format: `{type}: {description}`
   - Types: feat, fix, refactor, docs, chore, test
   - Add body for complex changes
   - Reference issue number if applicable

4. **Create commit**:
   ```bash
   git commit -m "{type}: {description}

   {body}

   Closes #{issue}"
   ```

$ARGUMENTS
```

**Pros**:
- Achievable in 1 week for Phase 1
- Immediate value from day one
- Clear extension pattern
- Balances simplicity with capability
- Matches team size (start small, grow)
- Built-in documentation for onboarding

**Cons**:
- Some agents deferred to later phases
- May need refactoring as patterns emerge
- Not fully comprehensive initially

**Complexity**: 3/5

---

## Comparison Table

| Aspect | Option A (MVP) | Option B (Gold) | Option C (Balanced) |
|--------|----------------|-----------------|---------------------|
| **Implementation Speed** | 1-2 days | 2-3 weeks | 1 week (Phase 1) |
| **Quality/Coverage** | Basic | Comprehensive | Good + extensible |
| **Complexity** | 2/5 | 5/5 | 3/5 |
| **Maintenance** | Low | High | Medium |
| **Scalability** | Limited | Excellent | Good |
| **Learning Curve** | Minimal | Steep | Moderate |
| **Token Efficiency** | High | Lower | Medium |
| **Immediate Value** | Medium | High (after setup) | High |
| **Future-Proofing** | Low | High | Medium-High |

---

## CLI for Runtime AI Interaction

Beyond development agents, AI agents may need to interact with the deployed SaaS API. A CLI generated from OpenAPI specs provides this capability:

**Why CLI over direct HTTP?**
- **Discoverability**: `cli --help` lists all available actions
- **Authentication**: Handled once, reused automatically
- **Semantic commands**: `users create` vs `POST /api/v1/users`
- **Universal**: Any AI capable of running bash can use it

**Integration with Development Agents**
- Dev agents use the CLI to test API changes during development
- Test agents use the CLI to run integration scenarios
- CI/CD uses the CLI for smoke tests and health checks

See [CLI for AI Agents Analysis](cli-for-ai-agents.md) for the full strategic analysis.

---

## Recommendation

**We recommend Option C (Balanced Approach)** for the following reasons:

1. **Matches project maturity**: As a boilerplate project, we need patterns that work now but scale later. Option C provides immediate value while establishing extensible patterns.

2. **Aligns with industry trends**: The "one agent, one task" pattern is the state of the art, but starting with 8 agents when 3 would suffice adds unnecessary overhead.

3. **Practical timeline**: Phase 1 can be completed in one week, providing skills (/commit, /pr, /review, /test) that address daily developer needs.

4. **Built-in documentation**: The agent-guide.md and clear folder structure serve as onboarding material for the AI team concept.

5. **Extensibility**: The `.claude/agents/` and `.claude/skills/` pattern matches Claude Code's official structure, making it easy to add agents for Deploy, Product, Ops, Frontend, and Backend later.

6. **Token efficiency**: Skills are loaded on-demand (unlike CLAUDE.md which loads every session), and subagents run in isolated contexts, preserving main conversation context.

### Implementation Priority

| Priority | Item | Timeline |
|----------|------|----------|
| P1 | `/commit`, `/pr`, `/review`, `/test` skills | Week 1 |
| P1 | `dev.md`, `review.md`, `test.md` agents | Week 2 |
| P2 | `/spec`, `/adr` skills | Week 3 |
| P2 | `deploy.md`, `product.md` agents | Week 4 |
| P3 | `frontend.md`, `backend.md`, `ops.md` agents | As needed |

---

## Key Resources

### Official Documentation
- [Claude Code Best Practices](https://www.anthropic.com/engineering/claude-code-best-practices) - Anthropic's official guide
- [Claude Code Skills Documentation](https://code.claude.com/docs/en/skills) - Official skills reference
- [Claude Code Subagents](https://code.claude.com/docs/en/sub-agents) - Subagent configuration guide
- [CLI Reference](https://code.claude.com/docs/en/cli-reference) - Command-line options

### Community Resources
- [awesome-claude-code](https://github.com/hesreallyhim/awesome-claude-code) - Curated list of skills, hooks, and plugins
- [claude-code-showcase](https://github.com/ChrisWiles/claude-code-showcase) - Complete project configuration example
- [awesome-agent-skills](https://github.com/VoltAgent/awesome-agent-skills) - 200+ agent skills collection
- [awesome-claude-code-subagents](https://github.com/VoltAgent/awesome-claude-code-subagents) - 100+ specialized subagents

### Multi-Agent Patterns
- [Multi-agent AI workflows](https://www.infoworld.com/article/4035926/multi-agent-ai-workflows-the-next-evolution-of-ai-coding.html) - InfoWorld overview
- [Multi-agent patterns in ADK](https://developers.googleblog.com/developers-guide-to-multi-agent-patterns-in-adk/) - Google's ADK patterns
- [Agentic AI Trends 2026](https://machinelearningmastery.com/7-agentic-ai-trends-to-watch-in-2026/) - Industry trends

### Other AI Tools (for pattern inspiration)
- [Cursor Rules Documentation](https://docs.cursor.com/context/rules-for-ai) - Cursor's rule configuration
- [awesome-cursorrules](https://github.com/PatrickJS/awesome-cursorrules) - Cursor rules collection
- [Aider Conventions](https://aider.chat/docs/usage/conventions.html) - Aider's approach
- [GitHub Copilot Custom Agents](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents) - Copilot agent docs

### Protocol Standards
- [Model Context Protocol Specification](https://modelcontextprotocol.io/specification/2025-11-25) - MCP spec
- [MCP Introduction](https://www.anthropic.com/news/model-context-protocol) - Anthropic's MCP announcement

### Prompt Engineering
- [IBM 2026 Prompt Engineering Guide](https://www.ibm.com/think/prompt-engineering) - Comprehensive guide
- [Lakera Prompt Engineering Guide](https://www.lakera.ai/blog/prompt-engineering-guide) - Best practices
- [Prompt Engineering Playbook for Programmers](https://addyo.substack.com/p/the-prompt-engineering-playbook-for) - Developer-focused

---

*Analysis completed: 2026-02-02*
*Issue: #12 - Setup: Claude Code agents & skills*
*Blocked by: #11 (Documentation structure)*
