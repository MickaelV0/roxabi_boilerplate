---
title: "Multi-tenant Row-Level Security (RLS) Strategy"
description: Analysis of the multi-tenant architecture using PostgreSQL RLS for data isolation in the Roxabi SaaS boilerplate.
---

# Multi-tenant Row-Level Security (RLS) Strategy

## Context

Roxabi's vision defines a hierarchical organization model:

```
META Organization (super admin)
└── Organization (tenant)
    └── Child Organization(s) (subdivisions)
        └── Users
```

Issue #19 (Auth &amp; Users) shipped the foundation: Better Auth with its Organization plugin provides `organizations`, `members`, `invitations`, and `sessions.activeOrganizationId`. The auth spec explicitly deferred tenant isolation to issue #21:

> "Organization plugin's `organizationId` and our existing `tenantId` base column serve different purposes. Alignment is deferred to #21 (RLS)."

This analysis covers the strategy for implementing database-level tenant isolation using PostgreSQL Row-Level Security, building on the existing Better Auth foundation.

**Dependencies:** #19 (Auth — complete)
**Blocks:** RBAC (#24), Admin panel (#25)

## Questions Explored

1. How should `tenant_id` relate to Better Auth's `organizations.id`?
2. How deep should the organization hierarchy go, and how does it interact with tenant boundaries?
3. How should super admin (META Organization) access cross-tenant data?
4. Can RLS be applied to Better Auth's own tables?
5. How should tenant context be set per-request in PostgreSQL?
6. How should Drizzle ORM integrate with RLS?
7. What is the scope of this issue — infrastructure only or full implementation?

## Analysis

### Tenant Identity: `tenant_id` = `organizations.id`

The simplest and most pragmatic choice: the organization IS the tenant. The `tenant_id` column on business tables maps directly to `organizations.id` from Better Auth.

**Rationale:**
- Better Auth already manages organizations and membership
- `sessions.activeOrganizationId` already tracks the user's active org context
- No need for a separate `tenants` table or concept
- The `tenantColumn` helper in `base.ts` already defines a `tenant_id` text column

### Organization Hierarchy: Shared Tenant Boundary

Child organizations are **subdivisions within a tenant**, not separate tenants:

| Entity | Role | tenant_id |
|--------|------|-----------|
| Acme Corp | Parent org (tenant) | `acme_corp_id` |
| Acme Sales | Child org (department) | `acme_corp_id` |
| Acme Engineering | Child org (department) | `acme_corp_id` |

All child orgs share the parent's `tenant_id`. This means:
- RLS policies are simple: one `tenant_id` check per table
- Child orgs are organizational grouping, not security boundaries
- Members of any child org can see all data within the tenant
- Covers 90% of SaaS use cases (company = tenant, departments = internal structure)

The `parent_organization_id` column (nullable) on `organizations` enables the hierarchy without complicating RLS.

### Better Auth Tables: Excluded from RLS

**Investigation finding:** Better Auth shares the same Drizzle instance and connection pool as the application. Its queries run during auth flows (login, session validation, org listing) **before tenant context is known**.

| Auth Flow | Tables Queried | Tenant Context Available? |
|-----------|---------------|--------------------------|
| Login/signup | `users`, `accounts` | No |
| Session validation | `sessions`, `users` | No |
| List user's orgs | `members` JOIN `organizations` | No (queries by `userId`) |
| Accept invitation | `invitations`, `members` | Ambiguous |

**Decision:** Do NOT apply RLS to Better Auth tables (`users`, `sessions`, `accounts`, `verifications`, `organizations`, `members`, `invitations`). These tables are managed by Better Auth's own application-level filtering. RLS applies **only to application business tables**.

**Risk mitigation:**
- Better Auth's organization plugin already scopes queries by `userId` and `organizationId`
- The `@RequireOrg()` guard decorator ensures `activeOrganizationId` is set before business logic runs
- Business tables with RLS provide the actual data isolation guarantee

### RLS Mechanism: `set_config()` in Transactions

Each request sets the tenant context using PostgreSQL's `set_config()` function inside a transaction:

```sql
SELECT set_config('app.tenant_id', 'org_abc123', true);
-- true = local to current transaction, auto-cleared when tx ends
```

RLS policies read this via `current_setting()`:

```sql
CREATE POLICY tenant_isolation ON business_table
  USING (tenant_id = current_setting('app.tenant_id', true));
```

**Why `set_config()` over `SET LOCAL`:**
- Function call — can be embedded in SQL, returns value
- Third parameter `true` = transaction-local, safe with connection pooling
- Common pattern in Node.js / Drizzle ecosystems
- Ergonomic with Drizzle's `sql` tagged template

### Super Admin: Bypass RLS via Postgres Role

The META Organization (super admin) bypasses RLS entirely using a separate PostgreSQL role:

```sql
-- Application role (used by normal requests)
CREATE ROLE app_user;
ALTER TABLE business_table ENABLE ROW LEVEL SECURITY;
-- RLS policies apply to app_user

-- Super admin role (bypasses RLS)
CREATE ROLE app_admin BYPASSRLS;
```

The NestJS interceptor detects super admin context (e.g., `user.role === 'admin'` or META org membership) and uses the `app_admin` role connection for those requests.

**Trade-off:** Requires two connection pools (or role switching per-request). The complexity is justified because:
- Super admin bypass is a well-understood Postgres pattern
- No need to pollute every RLS policy with admin checks
- Clear security boundary: admin access is a Postgres-level capability

### Drizzle Integration: NestJS Interceptor + CLS

The tenant context flows through the request lifecycle automatically:

```
Request → AuthGuard (validates session)
        → TenantInterceptor (extracts activeOrganizationId → CLS)
        → Controller → Service → TenantService.query(callback)
          ↳ BEGIN transaction
          ↳ set_config('app.tenant_id', tenantId, true)
          ↳ execute callback queries (RLS enforced)
          ↳ COMMIT
```

**Components:**
1. **TenantInterceptor** (global NestJS interceptor): Reads `session.session.activeOrganizationId`, stores in CLS (`nestjs-cls`, already configured)
2. **TenantService**: Wraps queries in a transaction with `set_config()`. Reads tenant ID from CLS. Zero boilerplate in service code.
3. **`@RequireOrg()` guard**: Already exists — ensures `activeOrganizationId` is set before the interceptor runs

**nestjs-cls** is already set up in the codebase for correlation IDs, so extending it for tenant context is natural.

### Scope: Infrastructure Only

This issue delivers the **RLS infrastructure and patterns**, not business tables:

**In scope:**
- `TenantInterceptor` (extract tenant from session → CLS)
- `TenantService` (transactional query wrapper with `set_config()`)
- PostgreSQL migration: enable RLS, create roles, create reusable policy function
- `tenantColumn` already exists in `base.ts` — document its usage pattern
- Integration tests proving tenant isolation
- Documentation of the pattern for future table creation

**Out of scope:**
- Creating business tables (deferred to feature-specific issues)
- Organization CRUD endpoints (handled by Better Auth)
- RBAC implementation (#24)
- Admin panel (#25)
- Modifying Better Auth tables

## Conclusions

1. **Tenant = Organization.** The `tenant_id` column maps to `organizations.id`. No separate tenant concept needed.
2. **RLS on business tables only.** Better Auth tables are excluded — auth flows run before tenant context exists, and Better Auth's own scoping is sufficient.
3. **Shared tenant boundary for child orgs.** Child orgs are organizational subdivisions, not security boundaries. Simplifies RLS policies significantly.
4. **`set_config()` in transactions.** Safe with connection pooling, ergonomic with Drizzle, auto-cleared when transaction ends.
5. **Super admin bypasses RLS** via a separate Postgres role (`BYPASSRLS`). Clean separation of concerns at the database level.
6. **Automatic tenant injection** via NestJS interceptor + CLS. Services don't need to know about tenant context — it's handled transparently.
7. **Infrastructure-first scope.** Deliver the middleware, service, migration, and patterns. Business tables adopt the pattern incrementally.

## Next Steps

- Create a spec for issue #21 with detailed implementation requirements based on these decisions
- Define the exact migration SQL (roles, RLS enable, policy function)
- Define the `TenantInterceptor` and `TenantService` API
- Plan integration tests for tenant isolation verification
- Document the pattern in coding standards for future table creation
