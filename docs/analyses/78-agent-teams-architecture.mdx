---
title: "Analysis: Agent Teams Architecture for Roxabi Boilerplate"
description: Architecture design for a 10-agent team using Claude Code Agent Teams, covering roles, coordination, tool access, and integration with existing skills.
---

## Context

Roxabi Boilerplate operates as a monorepo (apps/web, apps/api, packages/ui, packages/types, packages/config) with 16 Claude Code skills covering the full dev lifecycle (interview, commit, pr, review, test, bootstrap, scaffold, plan, etc.). The current model is **single-agent, skill-invoked**: one Claude Code session handles everything sequentially, invoking skills as prompt templates.

This analysis designs the transition to **Claude Code Agent Teams** — an experimental multi-agent coordination system where independent Claude Code sessions (teammates) work in parallel under a shared task list, each with dedicated roles, tools, and domain expertise.

**Triggering factors:**
- **Role specialization**: A single generalist agent makes inconsistent decisions across frontend (TanStack/React), backend (NestJS/Fastify), and infrastructure (Bun/TurboRepo/Biome). Domain-specific agents produce higher-quality output.
- **Context window exhaustion**: Large features (Tier M/L) saturate the 200k context. Isolated contexts per role keep each agent sharp on its responsibility.
- **Monorepo demands**: Each package has distinct patterns, conventions, and tooling. Domain agents can internalize these deeply instead of context-switching.

**Prior art:**
- [Analysis: Claude Code Agents Recommendations (2026-02-01)](claude-code-ai-agents-recommendations-20260201) — 45+ source survey covering agent patterns, memory systems, task system as native swarm
- [Analysis: Claude Code Agents &amp; Skills (deprecated)](12-claude-code-agents) — Historical 3-option comparison (MVP/Gold/Balanced)
- Anthropic's [feature-dev plugin](https://github.com/anthropics/claude-code/tree/main/plugins/feature-dev) — 3-agent workflow (explorer, architect, reviewer)

## Questions Explored

1. What agent roles does a monorepo SaaS project need?
2. How should agents coordinate — subagents vs agent teams?
3. How do agents interact with the existing 16 skills?
4. What orchestration model supports progressive autonomy?
5. What are the cost and risk implications of agent teams?

## Analysis

### 1. Agent Teams vs Subagents

Claude Code offers two multi-agent mechanisms:

| Dimension | Subagents | Agent Teams |
|-----------|-----------|-------------|
| **Context** | Isolated within single session | Fully independent sessions |
| **Communication** | Report back to spawner only | Direct teammate messaging + shared task list |
| **Parallelism** | 7-10 concurrent | Limited by terminal/tmux panes |
| **Persistence** | Within session only | Task list survives across sessions |
| **Token cost** | Lower (shared session) | 4-15x higher (each teammate = separate Claude instance) |
| **Nesting** | Cannot spawn sub-subagents | Only lead spawns teammates |
| **Feature status** | Stable | Experimental (`CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`) |

**Decision: Agent Teams** — The shared task list with dependencies, direct messaging, and session persistence are critical for a 10-agent team working on complex features. Subagents are better for one-off parallel tasks within a single workflow step; agent teams are better for sustained multi-role collaboration.

### 2. Team Roster (10 Agents)

The roster is organized in three tiers: **Domain agents** (package-specialized), **Quality agents** (cross-cutting verification), and **Strategy agents** (planning and alignment).

#### Tier 1 — Domain Agents

| Agent | Domain | Model | Tools | Primary Packages |
|-------|--------|-------|-------|-----------------|
| **frontend-dev** | UI/UX implementation | opus | Read, Write, Edit, Glob, Grep, Bash | `apps/web`, `packages/ui` |
| **backend-dev** | API implementation | opus | Read, Write, Edit, Glob, Grep, Bash | `apps/api`, `packages/types` |
| **devops** | CI/CD, deps, config | sonnet | Read, Write, Edit, Glob, Grep, Bash | `packages/config`, root configs |

**Rationale**: Domain agents need write access (they implement code). Opus for frontend/backend because implementation requires deep reasoning. Sonnet for devops because config tasks are more mechanical.

**Key design rule**: Each domain agent's system prompt includes the relevant standards doc baked in:
- frontend-dev reads `docs/standards/frontend-patterns.mdx`
- backend-dev reads `docs/standards/backend-patterns.mdx`
- devops reads `docs/configuration.mdx`

#### Tier 2 — Quality Agents

| Agent | Role | Model | Tools | Scope |
|-------|------|-------|-------|-------|
| **reviewer** | Code quality gate | sonnet | Read, Glob, Grep | All packages |
| **tester** | Test generation &amp; coverage | sonnet | Read, Write, Edit, Glob, Grep, Bash | All packages |
| **security-auditor** | Vulnerability detection | sonnet | Read, Glob, Grep, Bash | All packages |

**Rationale**: Quality agents are cross-cutting — they review/test code from any domain. Sonnet is sufficient for pattern matching and rule application. Reviewer is read-only (reports findings, does not fix). Tester needs write access to create test files.

**Key design rules**:
- reviewer bakes in `docs/standards/code-review.mdx` (Conventional Comments format)
- tester bakes in `docs/standards/testing.mdx` (patterns, thresholds)
- security-auditor bakes in the security hook patterns from `.claude/hooks/security-check.js` plus OWASP top 10

#### Tier 3 — Strategy Agents

| Agent | Role | Model | Tools | Scope |
|-------|------|-------|-------|-------|
| **architect** | System design, cross-cutting decisions | opus | Read, Glob, Grep, Bash | All packages |
| **business-analyst** | Requirements, user stories, acceptance criteria | sonnet | Read, Glob, Grep, WebSearch | `docs/` |
| **product-manager** | Prioritization, roadmap, spec validation | sonnet | Read, Glob, Grep, Bash (gh CLI) | `docs/`, GitHub issues |
| **doc-writer** | Documentation maintenance, CLAUDE.md sync | sonnet | Read, Write, Edit, Glob, Grep | `docs/`, `CLAUDE.md`, `AGENTS.md` |

**Rationale**: Architect uses Opus because system-level design decisions require deep reasoning. Strategy agents don't need Write access to code (except doc-writer for docs). PM gets Bash for `gh` CLI access to manage GitHub issues/PRs.

### 3. Skills Integration Strategy: Coexistence

The existing 16 skills remain available for direct human invocation. Agents adopt a **coexistence** model:

| Behavior | Where it lives | Why |
|----------|---------------|-----|
| **Critical behaviors** (commit format, review checklist, test patterns) | Baked into agent system prompts | 100% reliability vs 53% skill invocation success rate (Vercel data) |
| **Complex workflows** (/bootstrap, /scaffold, /interview) | Remain as skills, optionally invocable | Too large to bake in. Agents invoke when needed for multi-step orchestration |
| **Utility operations** (/cleanup, /1b1, /issues) | Remain as skills for human use | Agents don't need these — they work at a different granularity |

**Mapping: which agents bake which skill logic:**

| Agent | Baked-in behavior (from skill) |
|-------|-------------------------------|
| frontend-dev, backend-dev | `/commit` conventions, coding standards |
| reviewer | `/review` checklist, Conventional Comments format |
| tester | `/test` patterns, coverage thresholds |
| architect | `/plan` tier classification (S/M/L), architecture patterns |
| product-manager | `/issues` triage logic, `/interview` question framework |
| doc-writer | MDX formatting rules from `docs/contributing.mdx` |

### 4. Orchestration Model: Progressive Autonomy

Three phases of increasing agent autonomy:

#### Phase 1 — Human-Led (Initial)

```
Human (you)
  ├── Creates task list manually
  ├── Assigns tasks to specific teammates
  ├── Reviews every deliverable
  └── Approves at every gate

Teammates
  ├── Claim assigned tasks
  ├── Execute within their domain
  ├── Report back to lead
  └── Wait for next assignment
```

**Gates**: Spec approval, architecture approval, implementation review, test review, PR approval.

#### Phase 2 — Agent-Led with Human Gates

```
Lead Agent (architect or PM)
  ├── Breaks down feature into tasks
  ├── Assigns tasks to teammates based on domain
  ├── Coordinates dependencies
  └── Escalates to human at gates

Human
  ├── Reviews at 3 gates: spec, pre-merge, deploy
  └── Can intervene at any time
```

**Gates reduced to**: Spec approval, pre-merge review, deploy approval.

#### Phase 3 — Fully Autonomous with Notifications

```
Lead Agent
  ├── Full pipeline: spec → plan → implement → test → review → PR
  ├── Notifies human at completion
  └── Pauses only on: security findings, architecture changes, breaking changes

Human
  ├── Reviews completed PRs
  └── Handles escalations
```

**Gates minimal**: Only security escalations and breaking changes.

### 5. Coordination Patterns

#### Task Dependency Graph (Feature Development Example)

```
[BA: Gather requirements] ──→ [PM: Validate & prioritize]
                                       │
                               [Architect: Design]
                                       │
                    ┌──────────────────┼──────────────────┐
                    │                  │                   │
          [Frontend-dev:        [Backend-dev:       [Infra-ops:
           Implement UI]         Implement API]      Setup config]
                    │                  │                   │
                    └──────────────────┼──────────────────┘
                                       │
                    ┌──────────────────┼──────────────┐
                    │                  │               │
            [Tester:          [Reviewer:        [Security:
             Write tests]     Review code]       Audit]
                    │                  │               │
                    └──────────────────┼──────────────┘
                                       │
                              [Doc-writer: Update docs]
                                       │
                              [PM: Create PR]
```

#### Communication Patterns

| Pattern | When | Mechanism |
|---------|------|-----------|
| **Task handoff** | Agent completes work, next agent starts | `blockedBy` dependency in shared task list |
| **Direct message** | Agent needs clarification from another | Teammate messaging (`message` tool) |
| **Broadcast** | Lead announces decision affecting all | `broadcast` to all teammates |
| **Escalation** | Agent encounters blocker or security issue | Message to lead → lead notifies human |

### 6. Agent Definition Structure

Each agent is defined as a Markdown file in `.claude/agents/`:

```
.claude/agents/
  ├── frontend-dev.md
  ├── backend-dev.md
  ├── devops.md
  ├── architect.md
  ├── reviewer.md
  ├── tester.md
  ├── security-auditor.md
  ├── business-analyst.md
  ├── product-manager.md
  └── doc-writer.md
```

**Frontmatter schema per agent:**

```yaml
---
name: {agent-name}
description: {one-line role description}
tools: {comma-separated tool list}
model: {opus|sonnet|haiku}
permissionMode: {default|acceptEdits|plan}
maxTurns: {number}
---
```

**System prompt structure per agent:**

1. **Role definition** — Who you are, what you're responsible for
2. **Domain context** — Baked-in standards and patterns (from docs/)
3. **Deliverables** — What you produce and in what format
4. **Boundaries** — What's out of scope, when to escalate
5. **Coordination rules** — How to interact with other teammates

### 7. Cost and Risk Analysis

#### Token Cost

| Scenario | Single Agent | Agent Teams (10) |
|----------|-------------|-----------------|
| Small feature (Tier S) | ~50k tokens | ~200k tokens (4x) |
| Medium feature (Tier M) | ~200k tokens | ~1M tokens (5x) |
| Large feature (Tier L) | ~500k tokens | ~3-5M tokens (6-10x) |

**Mitigation**: Use Sonnet (cheaper) for quality and strategy agents. Only Opus for domain agents and architect. Use Haiku where possible for read-only exploration.

#### Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Experimental feature instability** | Agent teams may break with updates | Pin Claude Code version. Maintain fallback to subagent-based workflow |
| **Coordination overhead** | Agents waste tokens on messaging | Strict task dependencies minimize unnecessary communication |
| **Conflicting edits** | Two agents modify same file | Domain boundaries prevent overlap. File locking in agent teams handles edge cases |
| **Cost explosion** | 10 agents on Opus = very expensive | Model tiering (Opus only where needed). Tier S features skip agent teams entirely |
| **Stale docs → cascading errors** | Agents read outdated docs and produce wrong output | Doc-writer agent maintains docs post-merge. Architect validates docs before feature start |

## Conclusions

1. **Agent Teams is the right coordination model** for a 10-agent team on a monorepo SaaS project. Subagents are insufficient for sustained multi-role collaboration.
2. **10 agents in 3 tiers** (Domain, Quality, Strategy) provide complete lifecycle coverage with clear boundaries.
3. **Coexistence with skills** is optimal: bake critical behaviors into agent prompts for reliability, keep skills for human use.
4. **Progressive autonomy** (human-led → agent-led → autonomous) allows building trust incrementally.
5. **Cost is 4-10x higher** but offset by parallelism, specialization quality, and reduced rework.
6. **Tier S features should bypass agent teams** entirely — direct branch + single agent is sufficient.

## Next Steps

- [ ] Create spec from this analysis defining exact agent definitions, frontmatter, and system prompts
- [ ] Define the team configuration in `.claude/teams/roxabi/config.json`
- [ ] Enable `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1` in project settings
- [ ] Implement Phase 1 (human-led) agents and validate with a Tier M feature
- [ ] Create per-package CLAUDE.md files (`apps/web/CLAUDE.md`, `apps/api/CLAUDE.md`) as domain context
- [ ] Define when to use agent teams vs subagents vs single agent (tier-based routing)
