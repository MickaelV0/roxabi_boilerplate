---
title: Development Process
description: Development workflow with tiered tracks adapted to task complexity
---

Adapts to task complexity through tiered tracks. **Determine tier before starting.**

## Step 0: Determine Tier

```
≤3 files, no arch risk, no regression risk? ────────► Tier S
Otherwise ──────────────────────────────────────────► Tier F
```

| Tier | Name | Criteria | Process |
|------|------|----------|---------|
| **S** | Quick Fix | &lt;=3 files, no arch, no risk | Worktree + PR |
| **F-lite** | Feature (lite) | Clear scope, documented requirements, single domain | Worktree + agents + /review (skip bootstrap) |
| **F-full** | Feature (full) | New arch concepts, unclear requirements, or >2 domain boundaries | Bootstrap + worktree + agents + /review |

### F-lite vs F-full (judgment-based)

File count alone does not determine the tier. A 50-file mechanical change may be F-lite, while a 3-file rate limiter with design decisions may be F-full. Use judgment, then validate with the human.

**F-full (bootstrap required):**

```
New architectural concepts or patterns?              -> F-full
Unclear or competing requirements?                   -> F-full
Affects >2 domain boundaries?                        -> F-full
```

**F-lite (skip bootstrap):**

```
Mechanical/repetitive regardless of file count?      -> F-lite
Requirements fully documented (analysis/spec exist)? -> F-lite
Single domain, clear scope?                          -> F-lite
```

**Human always validates** the F-lite/F-full classification before proceeding.

> **Branch Strategy:** `staging` is the default integration branch. All feature and fix branches are created from `staging` and PRs target `staging`. Only `hotfix/*` branches may target `main` directly. Merges to `main` trigger production deploys; merges to `staging` do not auto-deploy (use the **Deploy Preview** GitHub Action for on-demand previews).

---

## Development Checklist

**CRITICAL: Before considering a development complete, verify ALL applicable items.**

### 1. Source Code

| Artifact | When | Typical files |
|----------|------|---------------|
| Frontend components | UI changes | `apps/web/src/**/*.tsx` |
| Backend modules | API changes | `apps/api/src/**/*.ts` |
| Shared UI | Reusable components | `packages/ui/src/**/*.tsx` |
| Shared types | Type definitions | `packages/types/src/**/*.ts` |

### 2. Tests

| Type | When | Typical files |
|------|------|---------------|
| Unit tests | New function/logic | `**/*.test.ts`, `**/*.spec.ts` |
| E2E tests | User flows | `apps/web/e2e/**/*.spec.ts` |
| API tests | Endpoints | `apps/api/src/**/*.spec.ts` |

**Rule: Any new public function must have at least one test.**

### 3. Documentation

| Artifact | When | Files |
|----------|------|-------|
| Feature spec | New feature | `docs/specs/*.mdx` |
| Analysis (pre-spec) | Before writing a spec | `docs/analyses/*.mdx` |
| Architecture | Structure change | `docs/architecture/*.mdx` |
| CLAUDE.md | Critical change | `CLAUDE.md` |

### 4. Configuration

| Artifact | When | Files |
|----------|------|-------|
| Environment variables | New config | `.env.example` |
| Package dependencies | New packages | `package.json`, `bun.lock` |
| TypeScript config | Compiler settings | `tsconfig.json` |

---

## Tier S: Quick Fix

### S.1 — Scope
- Identify files (max 3)
- Confirm no regression risk
- **List all impacted artifacts** (see checklist above)

> **XS exception:** For Size XS changes (single file, &lt;1h, zero risk), use `AskUserQuestion` to confirm with the lead. If approved, direct branch from staging is acceptable without worktree.

### S.2 — Create Worktree

```bash
git worktree add ../roxabi-XXX -b fix/XXX-description staging
cd ../roxabi-XXX
```

### S.3 — Validate
- Present approach with `AskUserQuestion`
- Include: files to modify, related artifacts (tests, docs)
- Wait for explicit approval

### S.4 — Implement
Follow this order:

1. **Read** existing files before modifying
2. **Implement** business logic
3. **Update tests**
4. **Run quality checks**: `bun lint && bun typecheck && bun test`
5. **Verify** all checks pass
6. *(Optional)* Delegate to **tester** subagent for a quick quality check

### S.5 — Verify & PR

Before creating the PR, verify **all applicable items** from the [Quality Checklist](#quality-checklist):
- All impacted artifacts are included (code, tests, docs, config)
- `bun lint && bun typecheck && bun test` pass locally
- No debug code or console.log left behind

```bash
# 1. Check changes — verify nothing is missing
git status
git diff --stat

# 2. Add files (NEVER git add -A)
git add <file1> <file2> ...

# 3. Commit with standard format
git commit -m "$(cat <<'EOF'
<type>(<scope>): <description>

<optional body>

Co-Authored-By: Claude <model> <noreply@anthropic.com>
EOF
)"

# 4. Create PR
gh pr create --title "<type>: description" --body "Closes #XXX"
```

### S.6 — Wait for CI

**MANDATORY:** Wait for all CI checks to pass before merging.

```bash
# Watch CI status until completion
gh pr checks <pr-number> --watch
```

CI runs: **lint → typecheck → test → build** (+ E2E if relevant paths changed).

If CI fails: fix the issue, push a new commit, and wait for CI again. **Never merge with failing checks.**

### S.7 — Cleanup Worktree (after merge)

```bash
# Return to main project directory
cd ../roxabi_boilerplate
git worktree remove ../roxabi-XXX
```

**Commit types:** `feat`, `fix`, `refactor`, `docs`, `style`, `test`, `chore`, `ci`, `perf`

---

## Agent Coordination

Two modes are available depending on task complexity. See the [Agent Teams Guide](../guides/agent-teams) for full setup and playbooks.

| Mode | Mechanism | When | Overhead |
|------|-----------|------|----------|
| **Subagents** | `Task` tool (single session) | Tier S or Tier F single-domain | Low — results return to your context |
| **Agent Teams** | `TeamCreate` (multi-process swarm) | Tier F multi-domain or large scope | High — each agent is a separate Claude instance |

**Quick decision:**
- Tier S: single session, optionally delegate to **tester** subagent
- Tier F single-domain: subagents via `Task` tool
- Tier F multi-domain: agent teams via `TeamCreate`

### Roles

| Actor | Role | Does NOT |
|-------|------|----------|
| **Human** | Decision-maker at every gate (spec approval, review comment acceptance, merge) | -- |
| **Main Claude** | Orchestrator — assesses issues, spawns agents, runs skills, coordinates flow | Does not implement code directly (Tier F — for Tier S, single session implements) |
| **product-lead** | Writes analyses and specs, triages issues, interacts with human when spawned | Does not orchestrate or merge |
| **Domain agents** (FE, BE, infra) | Implement within their domain boundaries | Do not review their own code |
| **tester** | Writes failing tests first (RED), verifies coverage | Does not write production code |
| **fixer** | Fixes accepted review comments across the entire stack | Does not review or write new features |
| **Fresh review agents** | Review code they did not write (security, architecture, product, tests, domain) | Do not fix code — that is the fixer's job |

---

## Tier F: Feature (4-Phase Workflow)

Tier F follows four phases: **Assess, Implement, Review, Fix/Merge**. The human is the decision-maker at every gate. Main Claude is the orchestrator.

```
Human: "develop #XXX"
        |
        v
========================================
  PHASE 1 — ASSESSMENT
========================================
        |
  Main Claude: fetch issue, check docs
        |
  Spec exists? ---- Yes --+
        |                  |
        No                 |
        |                  |
  product-lead: interview  |
  (+ architect if needed)  |
        |                  |
  Write analysis           |
        |                  |
  * Human approves *       |
        |                  |
  Write spec               |
        |                  |
  * Human approves *       |
        |                  |
        +------------------+
        |
        v
========================================
  /scaffold (spec → PR)
========================================
        |
  Plan: analyze scope, pick agents
        |
  * Human approves plan *
        |
  Create issue + worktree + stubs
        |
  Spawn agents (test-first):
        |
  tester: write failing tests (RED)
        |
     +--+--+--+
     |  |  |  |
    FE BE infra doc-writer   <-- parallel (GREEN)
     |  |  |  |
     +--+--+--+
        |
  tester: verify coverage + edge cases
        |
  All tests pass? --- No --> team fixes, loop
        |
       Yes
        |
  Commit + create PR
        |
        v
========================================
  PHASE 3 — REVIEW
========================================
        |
  Main Claude: /review
        |
  Fresh agents (never the authors):
  +- security-auditor
  +- architect
  +- product-lead
  +- tester
  +- frontend-dev  (if FE changes)
  +- backend-dev   (if BE changes)
        |
  Conventional Comments collected
        |
  Main Claude: /1b1
        |
  Human decides per comment:
  accept / reject / defer
        |
        v
========================================
  PHASE 4 — FIX & MERGE
========================================
        |
  fixer: fix accepted comments
        |
  Push + CI runs
        |
  CI green? --- No --> fixer fixes, loop
        |
       Yes
        |
  * Human approves merge *
        |
  Cleanup worktree
        |
       DONE
```

### Phase 1 — Assessment

1. Human says "develop issue #XXX"
2. Main Claude fetches the GitHub issue, scans for existing documents:
   - `docs/analyses/*` — matching analysis
   - `docs/specs/*` — matching spec
3. **If a sufficient spec exists** — skip to Phase 2
4. **If gaps exist** (no issue detail, no analysis, no spec):
   - Main Claude spawns **product-lead** agent
   - Product-lead interacts directly with the human to:
     - Clarify and structure the issue if needed
     - Write the analysis (human approves)
     - Write the spec (human approves)
   - If deeper technical analysis is needed, product-lead requests **architect** agent
   - Once spec is approved, product-lead returns control to Main Claude

> **F-lite shortcut:** If the task is classified as F-lite (clear scope, documented requirements), the assessment phase is brief — Main Claude confirms the spec exists and proceeds to `/scaffold`.

### Scaffold and Implementation (`/scaffold`)

`/scaffold` is the execution engine. It takes a spec and drives it all the way to a PR:

5. **Plan** — Reads the spec, analyzes scope, determines tier, breaks into tasks, picks agents. Human approves the plan.

6. **Setup** — Creates the GitHub issue (if none exists), creates worktree:
   ```bash
   git worktree add ../roxabi-XXX -b feat/XXX-slug staging
   cd ../roxabi-XXX && bun install
   ```

7. **Scaffold** — Creates boilerplate stubs (types, API, UI, test shells) from the spec. Commits.

8. **Implement** — Spawns agents based on the plan:

   | Change type | Agent |
   |-------------|-------|
   | Frontend | frontend-dev |
   | Backend | backend-dev |
   | CI/CD / config | infra-ops |
   | Any code change | tester (always) |
   | Security-sensitive | security-auditor (during review) |
   | Documentation | doc-writer |

   **Test-first** (RED → GREEN → REFACTOR):
   1. **RED** — Tester writes failing tests from spec acceptance criteria
   2. **GREEN** — Domain agents implement to pass the tests
   3. **REFACTOR** — Domain agents refactor while keeping tests green
   4. Tester verifies coverage and adds edge cases

9. **Quality gate** — `bun lint && bun typecheck && bun test`
   - **Pass** — proceed to PR
   - **Fail** — agents fix, re-test, loop until green

10. **PR** — `/scaffold` commits and creates the PR:
    ```bash
    gh pr create --title "feat: description" --body "Closes #XXX"
    ```

### Phase 3 — Review

11. Main Claude runs `/review` which spawns **fresh review agents** (new instances with no implementation context):

    | Always | Conditional |
    |--------|-------------|
    | security-auditor | frontend-dev (if FE changes) |
    | architect | backend-dev (if BE changes) |
    | product-lead | infra-ops (if config changes) |
    | tester | |

    Each reviewer produces Conventional Comments scoped to their domain.

12. Main Claude collects all review comments.
13. Main Claude walks the human through each comment **one-by-one** (`/1b1`):
    - Shows the comment, severity, and context
    - Presents trade-offs and recommendations
    - Human decides: **accept**, **reject**, or **defer**

### Phase 4 — Fix and Merge

14. **Fullstack quick fixer** receives the list of accepted comments and fixes them across the stack.
15. Push changes, update PR.
16. CI runs:
    - **Pass** — merge and cleanup worktree
    - **Fail** — fixer investigates and fixes, CI again, loop until green
17. Human approves merge:
    ```bash
    gh pr merge <pr-number> --squash --delete-branch
    ```
18. Cleanup:
    ```bash
    cd ../roxabi_boilerplate
    git worktree remove ../roxabi-XXX
    ```

**Never merge with failing checks.**

---

## Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Branch | `feat/XXX-slug` | `feat/123-user-auth` |
| Branch | `fix/XXX-slug` | `fix/456-login-bug` |
| Branch | `hotfix/XXX-slug` | `hotfix/99-security-patch` |
| Branch | `docs/slug` | `docs/api-reference` |
| Spec | `docs/specs/XXX-slug.mdx` | `docs/specs/123-user-auth.mdx` |
| Worktree | `../roxabi-XXX` | `../roxabi-123` |

> XXX = GitHub issue number

---

## Principles

1. **Human decides, Claude orchestrates, agents specialize** — The human is the decision-maker at every gate. Main Claude coordinates the workflow. Agents execute within their domain.
2. **Validate before implementing** — Always get user approval on approach before writing code
3. **Match process to complexity** — Tier S for quick fixes, F-lite for clear features, F-full for complex features
4. **Test first** — Tester writes failing tests before implementation (RED, GREEN, REFACTOR)
5. **Fresh eyes for review** — No agent reviews code it wrote. Review agents are fresh instances.
6. **Understand before building** — Read code before modifying
7. **Complete the checklist** — Every applicable artifact must be updated
8. **Track progress** — Keep GitHub issue updated
9. **Respect patterns** — Use shared packages, follow conventions
10. **No speculative complexity** — Build what's requested

---

## Quality Checklist

**Before creating PR:**
- [ ] All impacted artifacts included (code, tests, docs, config)
- [ ] Code follows conventions (Biome)
- [ ] Tests pass (`bun test`)
- [ ] Linting passes (`bun lint`)
- [ ] Types check (`bun typecheck`)
- [ ] No console.log or debug code
- [ ] PR description is clear
- [ ] Documentation updated if needed

**Before merging PR:**
- [ ] CI checks pass (`gh pr checks &lt;pr-number&gt; --watch`)
- [ ] `/review` completed with fresh domain agents (Tier F)
- [ ] Human walked through all review comments via `/1b1`
- [ ] Accepted comments fixed by fixer agent
