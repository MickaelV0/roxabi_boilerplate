---
title: Database Architecture
description: Drizzle ORM setup, schema conventions, migration workflow, and patterns used in the API.
---

## Overview

The API uses **Drizzle ORM** with **PostgreSQL** through the `postgres.js` driver. Drizzle provides fully type-safe queries derived from schema definitions — no code generation step, no runtime overhead.

Key characteristics:

- **Driver:** `postgres` (postgres.js) for connection pooling and query execution
- **ORM layer:** `drizzle-orm/postgres-js` for type-safe query building
- **Schema toolkit:** `drizzle-kit` for migrations and schema introspection
- **TypeScript integration:** Schema definitions produce TypeScript types automatically

All database code lives in `apps/api/src/database/`.

## Provider Pattern

Database access is wired through NestJS dependency injection using **Symbol tokens** (not string tokens):

```ts
// drizzle.provider.ts
export const DRIZZLE = Symbol('DRIZZLE')
export const POSTGRES_CLIENT = Symbol('POSTGRES_CLIENT')
```

Two providers are registered:

1. **`POSTGRES_CLIENT`** — creates the raw `postgres` connection. Reads `DATABASE_URL` from `ConfigService`. Connection pool settings: `max: 10`, `idle_timeout: 20`, `connect_timeout: 10`.

2. **`DRIZZLE`** — wraps the postgres client in Drizzle ORM with the full schema. This is the token you inject in services.

**Graceful degradation:** If `DATABASE_URL` is not set:
- In **production**: throws immediately (hard failure)
- In **development**: returns `null` and logs a warning — the app starts without database features

The `DatabaseModule` is registered as `@Global()` so every module can inject `DRIZZLE` without importing it:

```ts
@Inject(DRIZZLE) private readonly db: DrizzleDB | null
```

The module implements `OnModuleDestroy` to close the postgres connection on shutdown.

## Schema Conventions

### Shared helpers

`database/schema/base.ts` exports reusable column definitions:

```ts
// Timestamps with timezone and auto-update
export const timestamps = {
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  updatedAt: timestamp('updated_at', { withTimezone: true })
    .defaultNow()
    .notNull()
    .$onUpdateFn(() => new Date()),
}

// Tenant column for Row-Level Security
export const tenantColumn = {
  tenantId: text('tenant_id').notNull(),
}
```

Spread `timestamps` into any new table to get consistent `created_at` / `updated_at` columns with timezone support and automatic update-on-write.

### Naming rules

| Element | Convention | Example |
|---------|-----------|---------|
| Table names | **plural**, snake_case | `users`, `organizations` |
| Column names | **snake_case** | `created_at`, `user_id` |
| Primary keys | `text` type, UUID generated by Better Auth | `id: text('id').primaryKey()` |
| Foreign keys | `&lt;entity>_id` with explicit `references` and `onDelete` | `userId: text('user_id').references(() => users.id, { onDelete: 'cascade' })` |

### Barrel export

All schema files re-export through `database/schema/index.ts`:

```ts
export * from './auth.schema.js'
export * from './base.js'
export * from './rbac.schema.js'
```

The Drizzle provider imports `* as schema` from this index.

## Auth Schema

Better Auth manages its own database tables via the Drizzle adapter (`usePlural: true`). These are defined in `database/schema/auth.schema.ts`:

| Table | Purpose | Key columns |
|-------|---------|-------------|
| `users` | User accounts | `id`, `name`, `email`, `emailVerified`, `role`, `banned` |
| `sessions` | Active sessions | `id`, `userId`, `token`, `expiresAt`, `activeOrganizationId` |
| `accounts` | OAuth provider links | `userId`, `providerId`, `accountId`, `accessToken` |
| `verifications` | Email verification tokens | `identifier`, `value`, `expiresAt` |
| `organizations` | Multi-tenant orgs | `id`, `name`, `slug` |
| `members` | Org membership | `userId`, `organizationId`, `role` |
| `invitations` | Pending org invites | `organizationId`, `email`, `role`, `status`, `expiresAt` |

These tables use `text` primary keys with UUID generation (`advanced.database.generateId: 'uuid'` in Better Auth config). The auth schema does **not** use the shared `timestamps` helper — most tables define `createdAt` / `updatedAt` inline (without timezone or `$onUpdateFn`), `organizations` and `members` only have `createdAt`, and `invitations` has no timestamps at all. This inconsistency is tracked as tech debt.

## RBAC Schema

RBAC tables are defined in `database/schema/rbac.schema.ts` and manage per-tenant roles and permissions. The schema follows the existing conventions (text PKs with UUID, snake_case columns, timestamps).

### Tables

| Table | Scope | Purpose | Key columns |
|-------|-------|---------|-------------|
| `permissions` | Global | Available permission definitions | `id`, `resource`, `action`, `description` |
| `roles` | Tenant (RLS) | Roles per organization | `id`, `tenant_id`, `name`, `slug`, `is_default` |
| `role_permissions` | Via FK | Maps roles to permissions | `role_id`, `permission_id` (composite PK) |

**`members` table extension:** A `role_id` FK column was added to the existing `members` table, referencing `roles.id` with `ON DELETE SET NULL`. This column is the source of truth for RBAC; the original `role` text column is kept for Better Auth compatibility.

### Constraints

- `permissions`: unique on `(resource, action)` — seeded via migration, not editable by tenants
- `roles`: unique on `(tenant_id, slug)` — default roles (`owner`, `admin`, `member`, `viewer`) seeded per org on creation
- `role_permissions`: composite PK on `(role_id, permission_id)`, cascades on delete
- `roles` has RLS via `create_tenant_rls_policy('roles')`. `permissions` is global (no RLS). `role_permissions` inherits isolation through the FK to `roles`.

### Default roles

Each organization gets four default roles seeded automatically via `RbacListener` on the `ORGANIZATION_CREATED` event:

| Role | Slug | Permissions |
|------|------|-------------|
| Owner | `owner` | All 15 permissions |
| Admin | `admin` | All except `organizations:delete` |
| Member | `member` | Read-only: `users`, `organizations`, `members`, `invitations`, `roles` |
| Viewer | `viewer` | Read-only: `users`, `organizations`, `members`, `roles` |

## Drizzle Kit Configuration

`apps/api/drizzle.config.ts`:

```ts
export default defineConfig({
  schema: './src/database/schema/index.ts',
  out: './drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL ?? '',
  },
  verbose: true,
  strict: true,
})
```

- **`schema`** — points to the barrel export of all schema files
- **`out`** — migration SQL files are written to `apps/api/drizzle/migrations/`
- **`strict: true`** — prompts for confirmation before destructive changes
- **`verbose: true`** — prints detailed migration output

## Migration Workflow

All commands run from the `apps/api/` directory:

```bash
# 1. Generate a migration from schema changes
bunx drizzle-kit generate

# 2. Apply pending migrations to the database
bunx drizzle-kit migrate

# 3. Open Drizzle Studio for visual inspection
bunx drizzle-kit studio
```

**Workflow:**

1. Edit or create schema files in `src/database/schema/`
2. Run `bunx drizzle-kit generate` — Drizzle compares the schema to the last migration snapshot and generates SQL
3. Review the generated SQL in `drizzle/migrations/`
4. Run `bunx drizzle-kit migrate` to apply
5. Commit both the schema changes and the migration files

## Adding a New Table

1. **Create the schema file:**

   ```ts
   // src/database/schema/products.ts
   import { pgTable, text } from 'drizzle-orm/pg-core'
   import { timestamps } from './base.js'

   export const products = pgTable('products', {
     id: text('id').primaryKey(),
     name: text('name').notNull(),
     ...timestamps,
   })
   ```

2. **Re-export from the barrel:**

   ```ts
   // src/database/schema/index.ts
   export * from './auth.schema.js'
   export * from './base.js'
   export * from './products.js'
   ```

3. **Generate the migration:**

   ```bash
   cd apps/api
   bunx drizzle-kit generate
   ```

4. **Review and apply:**

   ```bash
   # Check the generated SQL
   cat drizzle/migrations/XXXX_*.sql

   # Apply to database
   bunx drizzle-kit migrate
   ```

5. **Use in a service:**

   ```ts
   import { Inject, Injectable } from '@nestjs/common'
   import { DRIZZLE, type DrizzleDB } from '../database/drizzle.provider.js'
   import { products } from '../database/schema/index.js'

   @Injectable()
   export class ProductService {
     constructor(@Inject(DRIZZLE) private readonly db: DrizzleDB) {}

     async findAll() {
       return this.db.select().from(products)
     }
   }
   ```
