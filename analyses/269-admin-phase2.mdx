---
title: "Admin Panel Phase 2 — Cross-Tenant User & Organization Management"
description: Cross-tenant user management, cross-tenant organization management with hierarchy, and audit log viewer for super admins.
---

## Context

Issue [#269](https://github.com/roxabi/roxabi_boilerplate/issues/269) — Phase 2 of the Admin Panel ([#25](https://github.com/roxabi/roxabi_boilerplate/issues/25)). Depends on Phase 1 (#268, completed), which delivered the admin layout, route guards, member management migration, `AuditService` scaffolding, and Better Auth plugin restriction.

**Promoted from:** [Admin Panel Analysis](../analyses/25-admin-panel.mdx) (Phase 2 section) and [Admin Panel Spec](../specs/25-admin-panel.mdx) (Phase 2 section).

**Current state (post-Phase 1):**

- **Admin layout** exists at `/admin` with sidebar nav groups: Organization (Members, Settings) and System (placeholder links for Users, Organizations, System Settings, Feature Flags, Health, Audit Logs).
- **Route guards** implemented: `requireAdmin()` (superadmin fast-path + `members:write` permission check) and `requireSuperAdmin()` (superadmin role only). Both are SSR-safe with hydration-time enforcement.
- **`AdminModule`** in NestJS with `AdminMembersController`, `AdminInvitationsController`, and `AdminMembersService`. Uses direct Drizzle queries with explicit `organizationId` filtering (no `TenantService`).
- **`AuditService`** scaffolded with `audit_logs` table. Fire-and-forget logging via `auditService.log()`. Currently logs: `member.invited`, `member.role_changed`, `member.removed`, `invitation.revoked`.
- **Offset-based pagination** for member list (page/limit with `PaginationControls` component).
- **Cursor-based pagination does not exist yet** — must be built for Phase 2.
- **`parentOrganizationId` does not exist** on organizations schema yet — must be added in Phase 2.
- **`AdminExceptionFilter`** provides standardized error responses with correlation IDs.
- **Shared types** in `packages/types/src/admin.ts` define `Member`, `PaginationMeta`, `MembersResponse`.
- **Dual role field sync** resolved: `AdminMembersService.changeMemberRole()` writes both `roleId` and legacy `role` field.

## Questions Explored

1. What is the exact scope boundary between Phase 2 and Phase 3/4?
2. How should cursor-based pagination be implemented (reusable pattern for users, orgs, audit logs)?
3. What are the org hierarchy constraints and how is depth enforced?
4. How should the audit log viewer work given the existing `AuditService`?
5. What Phase 1 patterns can be reused vs. what needs new patterns?

## Analysis

### Scope

Phase 2 adds three cross-tenant capabilities for super admins:

| Feature | Route | Key APIs |
|---------|-------|----------|
| **Cross-tenant user management** | `/admin/users` | `GET/PATCH/DELETE /api/admin/users`, `POST /api/admin/users/:id/ban`, `POST /api/admin/users/:id/restore` |
| **Cross-tenant org management** | `/admin/organizations` | `GET/POST/PATCH/DELETE /api/admin/organizations`, `GET .../deletion-impact`, `POST .../restore` |
| **Audit log viewer** | `/admin/audit-logs` | `GET /api/admin/audit-logs` |

All three features use `@Roles('superadmin')` and cursor-based pagination.

### Non-goals (deferred to Phase 3/4)

- **System settings** and **feature flags** — Phase 3 (separate DB tables + services, no dependency on Phase 2)
- **User impersonation** and **health dashboard** — Phase 4 (requires session schema changes + Better Auth investigation)
- **Audit log CSV export** — follow-up issue (UX and streaming complexity, not blocking core functionality)
- **Org hierarchy cross-access inheritance** — parent/child is display-only grouping (cross-org access remains a super admin privilege only)
- **Optimistic locking / conflict resolution** — last-write-wins is acceptable for a super-admin tool with low concurrent edit frequency; the audit log captures both changes as a compensating control
- **Session invalidation on ban** — banned user's current session remains active until next request or session expiry; a middleware-level `banned` check can be added as a fast-follow if the gap is unacceptable

### Cursor-Based Pagination (New Pattern)

Phase 1 uses offset pagination for org-scoped members. Phase 2 introduces cursor-based pagination for cross-tenant lists (larger datasets, better performance).

**Design:**

- Cursor = Base64-encoded `(timestamp, id)` tuple (timestamp for ordering, id for tiebreaking).
- **ID tiebreaking note:** `audit_logs.id` uses UUID v4 (random, not time-ordered). When two rows share the same `timestamp` value, the tiebreak ordering is stable (deterministic string comparison) but not chronological. This is acceptable — exact sub-millisecond ordering of simultaneous events is not a user requirement. If strict ordering becomes necessary, a monotonic sequence column can be added later.
- **Drizzle query pattern:** PostgreSQL supports row constructor comparison (`WHERE (ts, id) < (?, ?)`), but Drizzle ORM does not. The expanded form is required: `WHERE timestamp < cursor_ts OR (timestamp = cursor_ts AND id < cursor_id)`. This requires a composite index `(timestamp DESC, id DESC)` for efficient execution — the existing `idx_audit_logs_timestamp` (single column) is insufficient. A new composite index must be added for audit logs, and equivalent indexes for users/orgs `createdAt` columns.
- Response shape: `{ data: T[], cursor: { next: string | null, hasMore: boolean } }`.
- Fetch `LIMIT N+1` rows to determine `hasMore` without a separate count query.
- **Frontend: "Load more" button** (not infinite scroll). Load more is simpler, accessible by default (keyboard/screen-reader friendly), and avoids scroll position bugs with filtered lists. Infinite scroll can be added later as an enhancement if needed.

**Reusability:** The cursor pagination utility should be generic (used by users, orgs, and audit logs). Backend: shared helper function (not a service — it's a stateless query builder) in a `cursor-pagination.util.ts` within the admin module. Frontend: shared `useCursorPagination` hook wrapping TanStack Query's `useInfiniteQuery`.

**Why cursor over offset:** Cross-tenant lists may grow unbounded. Offset pagination degrades with large offsets (`OFFSET 10000` scans and discards rows). Cursor pagination is O(1) regardless of position — critical for audit logs which grow continuously.

### Cross-Tenant User Management

**Backend: `AdminUsersController`**

| Endpoint | Method | Guard | Description |
|----------|--------|-------|-------------|
| `/api/admin/users` | GET | `@Roles('superadmin')` | Cursor-paginated list with search and filters |
| `/api/admin/users/:id` | GET | `@Roles('superadmin')` | User detail: profile, org memberships, last 10 audit entries |
| `/api/admin/users/:id` | PATCH | `@Roles('superadmin')` | Edit name, email, global role |
| `/api/admin/users/:id/ban` | POST | `@Roles('superadmin')` | Ban with reason + optional expiration |
| `/api/admin/users/:id/unban` | POST | `@Roles('superadmin')` | Remove ban |
| `/api/admin/users/:id` | DELETE | `@Roles('superadmin')` | Soft-delete |
| `/api/admin/users/:id/restore` | POST | `@Roles('superadmin')` | Restore soft-deleted user |

**Query pattern:** Direct Drizzle queries without `TenantService` (same pattern as Phase 1 `AdminMembersService`). All queries explicitly join across tables without tenant scoping.

**Filters:** role (`user | admin | superadmin`), status (`active | banned | deleted`), organization (by orgId), text search (name/email ILIKE).

**User detail view:** Two queries (not a single wide join to avoid row duplication): (1) `SELECT * FROM users WHERE id = :id` for profile, (2) `SELECT m.*, o.name, o.slug FROM members m JOIN organizations o ON m.organizationId = o.id WHERE m.userId = :id` for memberships. Activity summary: `SELECT * FROM audit_logs WHERE resource_id = :userId OR actor_id = :userId ORDER BY timestamp DESC LIMIT 10`.

**Ban/unban:** The `users` schema already has `banned`, `banReason`, and `banExpires` columns (via Better Auth's `auth.schema.ts`). The admin service writes these columns directly via Drizzle (consistent with the Phase 1 pattern of bypassing Better Auth APIs for admin actions). `banExpires` is a timestamp — **auto-unban on expiry is not implemented in Phase 2**; the ban is lifted only when a super admin explicitly unbans or when a middleware check (fast-follow) detects expiry. Audit log with `user.banned` / `user.unbanned` actions.

**Ban UX impact:** A banned user's current session remains active until their next API request, at which point the auth guard checks the `banned` field and returns 403. On serverless (Vercel), sessions are short-lived, so the gap is minimal. On long-lived servers, the gap could be up to the session TTL. This is an accepted limitation for Phase 2.

**Soft-delete/restore:** Uses existing soft-delete pattern (`deletedAt` + `deleteScheduledFor`). Restore clears both fields. Audit log with `user.deleted` / `user.restored`. Note: hard-deletion of users is blocked by the `audit_logs.actorId` FK (`ON DELETE NO ACTION`) — this is intentional to preserve audit trail integrity.

### Cross-Tenant Organization Management

**Backend: `AdminOrganizationsController`**

| Endpoint | Method | Guard | Description |
|----------|--------|-------|-------------|
| `/api/admin/organizations` | GET | `@Roles('superadmin')` | Cursor-paginated list with search |
| `/api/admin/organizations` | POST | `@Roles('superadmin')` | Create org with optional parent |
| `/api/admin/organizations/:id` | GET | `@Roles('superadmin')` | Org detail: info, members, children |
| `/api/admin/organizations/:id` | PATCH | `@Roles('superadmin')` | Edit name, slug, parent |
| `/api/admin/organizations/:id/deletion-impact` | GET | `@Roles('superadmin')` | Preview deletion impact |
| `/api/admin/organizations/:id` | DELETE | `@Roles('superadmin')` | Soft-delete |
| `/api/admin/organizations/:id/restore` | POST | `@Roles('superadmin')` | Restore soft-deleted org |

**Org hierarchy:**

- **Schema change:** Add `parentOrganizationId` (text, nullable, self-referencing FK) to `organizations` table. Column name matches `TenantInterceptor` dynamic field check already in place.
- **TenantInterceptor impact (CRITICAL):** The existing `TenantInterceptor` reads `parentOrganizationId` and resolves child orgs to the parent's tenant boundary. Adding this column **changes tenant resolution behavior globally** for any org with a parent set. This must be investigated during implementation: either (a) the interceptor logic must be made opt-in (only resolve to parent when explicitly configured), or (b) the tenant boundary change must be designed for and tested across all existing org-scoped features. The spec must resolve this before implementation begins.
- **Max depth validation (3 levels):** Enforced at the **application layer only** (service walks up the parent chain before allowing create/update). A DB CHECK constraint cannot enforce depth (it cannot query other rows). A trigger could enforce it but adds complexity with no precedent in the codebase. Application-layer validation is sufficient — the TOCTOU race window (two concurrent reparent operations) is negligible for admin-only operations. **Reparenting edge case:** when changing a parent, the service must validate the *entire subtree depth* (not just the immediate parent chain) to prevent moving a 2-level subtree under a 2-level parent (creating depth 4).
- **Tree view data strategy:** The flat list approach is selected — `GET /api/admin/organizations?view=tree` returns a flat list of all orgs with `parentOrganizationId` fields. The frontend assembles the tree client-side. This is simpler than server-side hierarchy assembly, avoids recursive CTEs in the query, and the dataset is bounded (orgs grow slowly).
- **Flat vs. tree toggle:** User can switch between flat paginated list and tree view. Tree view loads all non-deleted orgs in a single query (no pagination — tree browsing is UX-incompatible with cursor pagination). Hard limit: 1000 orgs. If exceeded, tree view is disabled with a message suggesting flat list with search. The 1000 threshold is a UX heuristic — rendering 1000+ tree nodes degrades browser performance.

**Deletion impact:** Existing pattern from `GET /api/organizations/:id/deletion-impact`. The admin version is cross-tenant (no org scoping). Returns: `{ memberCount, activeMembers, childOrgCount, childMemberCount, effect: string }`. `memberCount` is the direct member count; `childMemberCount` is the recursive total across all child orgs. Both are shown in the impact preview dialog.

**Soft-delete org with children:** Deleting a parent org does **not** cascade-delete children. Children become orphaned (their `parentOrganizationId` still references the deleted parent). The UI shows a warning in the impact preview: "This organization has {N} child organizations that will become top-level." Restoring the parent re-establishes the hierarchy.

**Guard chain note:** Cross-tenant endpoints use `@Roles('superadmin')`. The existing guard chain includes a `@RequireOrg` check that fires before `@Permissions`. For super admin endpoints that operate without an active org context, the guard chain must be verified — super admin role should short-circuit the org requirement. If it doesn't, the guard chain needs adjustment (e.g., `@SkipOrg()` decorator or guard ordering change). This must be confirmed during implementation.

### Audit Log Viewer

**Backend: extend existing `AuditService` module**

| Endpoint | Method | Guard | Description |
|----------|--------|-------|-------------|
| `/api/admin/audit-logs` | GET | `@Roles('superadmin')` | Cursor-paginated, filterable audit log entries |

**Filters:** date range (`from`, `to`), actor (userId), action type, resource type, organization, text search (across action + resourceId).

**Response:** Each entry includes `before` and `after` JSONB fields. Frontend renders an expandable diff view per row.

**Indexes already exist:** `idx_audit_logs_actor`, `idx_audit_logs_org`, `idx_audit_logs_timestamp`, `idx_audit_logs_action`, `idx_audit_logs_org_action_ts`. A new composite index `(timestamp DESC, id DESC)` is needed for efficient cursor pagination (see Cursor-Based Pagination section).

**Diff viewer security:** The `before`/`after` JSONB fields may contain sensitive data if audit logging was misconfigured (e.g., password hashes). The diff viewer must redact known-sensitive fields (`password`, `passwordHash`, `token`, `secret`) before rendering. This is a frontend-only concern — the backend returns raw data; the frontend applies a redaction list.

### Frontend Patterns (Reuse from Phase 1)

| Pattern | Phase 1 Source | Phase 2 Reuse |
|---------|---------------|---------------|
| Admin layout + sidebar | `routes/admin.tsx` | Enable disabled links, no changes |
| TanStack Query + mutations | `members.tsx` | Same pattern for users/orgs/audit |
| `AdminExceptionFilter` | `admin/exceptions/` | Add new exception types |
| Error/loading states | `ErrorCard`, skeleton loaders | Reuse directly |
| Search with debounce | `useDebouncedValue` in members | Reuse in all list views |
| Confirmation dialogs | Member removal dialog | Reuse for user/org actions |

**New patterns needed:**

| Pattern | Description |
|---------|-------------|
| Cursor pagination hook | `useCursorPagination` wrapping `useInfiniteQuery` |
| Cursor pagination controls | "Load more" button or infinite scroll component |
| Detail view layout | User detail / org detail with tabs or sections |
| Tree view component | Expandable/collapsible org hierarchy |
| Diff viewer | Before/after JSON diff for audit log entries |
| Filter bar | Multi-filter component (dropdowns, date range, search) |

### Schema Changes

**New column:**

```
organizations
  + parentOrganizationId TEXT (nullable, self-ref FK → organizations.id)
```

**No new tables** — `audit_logs` already exists from Phase 1.

**Migration:** Single Drizzle migration adding the column + FK constraint. No DB-level depth constraint (application-layer only — see Org hierarchy section). The migration also adds composite indexes for cursor pagination: `(createdAt DESC, id DESC)` on `users` and `organizations` tables.

### Shared Types (New)

```
packages/types/src/pagination.ts (new — cursor types are not admin-specific)
  + CursorPaginationMeta ({ next: string | null, hasMore: boolean })
  + CursorPaginatedResponse<T> ({ data: T[], cursor: CursorPaginationMeta })

packages/types/src/admin.ts (extend)
  + AdminUser (cross-tenant user with org memberships)
  + AdminOrganization (with parentOrganizationId, childCount, memberCount)
  + UserFilters, OrgFilters, AuditLogFilters (filter types)
```

**Note:** `AuditLogEntry` already exists in `packages/types/src/audit.ts`. The admin viewer should re-export or extend that type, not duplicate it.

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| Soft-delete org with active members | Impact preview shows direct member count + child org member count; proceed requires confirmation |
| Soft-delete org with child orgs | Children become orphaned (top-level). Impact preview warns: "N child organizations will become top-level." No cascade delete |
| Reparent org creates depth > 3 | 400: "Maximum organization depth of 3 levels exceeded." Validation checks full subtree depth, not just immediate parent |
| Reparent org creates cycle | 400: "Cannot set parent to a descendant organization." Service walks up parent chain to detect cycles |
| Org hierarchy exceeds 3 levels | 400: "Maximum organization depth of 3 levels exceeded" |
| Concurrent admin edits to same user/org | Last-write-wins; both changes audit logged independently. Acceptable for low-frequency admin operations |
| Audit log for deleted user | `actorId` FK prevents hard-delete. Display shows "[Deleted User]" with original ID for soft-deleted users |
| Ban user who is currently logged in | Ban takes effect on next API request. Current session remains active until then (see Non-goals) |
| Ban expiration | Auto-unban is **not** implemented. Expired bans are lifted only on explicit unban or future middleware check |
| Restore org that had a parent which is now deleted | Restore succeeds; `parentOrganizationId` references deleted parent. UI shows warning: "Parent organization is archived" |
| Tree view with 1000+ orgs | Tree view disabled; message suggests flat list with search |
| Search with special characters | Server-side escaping of ILIKE patterns (prevent injection via `%` / `_` chars) |
| Diff viewer with sensitive fields | Frontend redacts known-sensitive keys (`password`, `passwordHash`, `token`, `secret`) before rendering |

## Conclusions

1. **Cursor-based pagination** is the biggest new pattern — must be designed as a reusable utility (backend helper + frontend hook) since it's used by users, orgs, and audit logs.
2. **Phase 1 patterns transfer well** — same controller/service architecture, same guard strategy, same audit logging approach. Phase 2 is an extension, not a redesign.
3. **Org hierarchy** is the most complex new feature — schema change, depth validation (app + DB), tree view UI. Keep it simple: parent/child grouping only, no cross-org access inheritance.
4. **Audit log viewer** is read-only on existing data — straightforward once cursor pagination is in place. Main complexity is the filter bar and diff viewer.
5. **Schema change is non-trivial** — `parentOrganizationId` adds a self-referencing FK with application-layer depth validation, plus new composite indexes for cursor pagination. No new tables, but the migration requires care.
6. **Biggest risk:** Cursor pagination implementation across all three features. If the abstraction leaks, each feature gets its own pagination bugs. Invest in the shared utility.
7. **TenantInterceptor interaction** must be resolved before implementation — adding `parentOrganizationId` may change tenant resolution behavior globally.
8. **Guard chain** for cross-tenant endpoints must be verified — `@Roles('superadmin')` needs to short-circuit the `@RequireOrg` check for org-free operations.

## Shapes

### Shape A: Feature-First (Vertical Slices)

Build each feature end-to-end (backend + frontend + types) before moving to the next. Order: Users → Organizations → Audit Logs. Cursor pagination built inline with the first feature (users), then extracted and reused.

**Pros:** First working feature (users list) available within ~2 days; each slice is independently demo-able and testable.
**Cons:** Cursor pagination abstraction built for users may not generalize cleanly to orgs/audit (different sort fields, filter shapes). Refactoring needed when applying to second feature. Sequential — no parallelization until all features started.

### Shape B: Lean Foundation + Vertical Slices (Hybrid)

Build only cursor pagination utility (backend helper + frontend hook + shared types) as foundation (~1 day), then build each feature as a vertical slice. Order: Cursor pagination → Users → Organizations → Audit Logs. Filter bar and diff viewer built inline with the first feature that needs them (users for filters, audit for diffs).

**Pros:** Foundation is minimal and targeted (only the shared utility, not all components). First feature starts after ~1 day, not 2-3. Features after the first can be parallelized since they share the pagination utility. Lower risk of over-engineering the foundation.
**Cons:** Filter bar and diff viewer are built inline and may need light refactoring for reuse. Slightly less consistent than full foundation-first.

### Shape C: Full Foundation-First (Horizontal Layers)

Build all shared infrastructure first (cursor pagination, shared types, filter bar, diff viewer, "Load more" component), then build each feature on top. Order: All utilities → Users → Organizations → Audit Logs.

**Pros:** Maximum code consistency from the start. All three features can be built in parallel after foundation is complete.
**Cons:** ~2-3 days before any working feature. Foundation components built without concrete usage context may miss requirements. Over-engineering risk (building diff viewer before understanding audit log data shapes).

## Fit Check

| Criterion | Shape A | Shape B | Shape C |
|-----------|---------|---------|---------|
| Time to first demo | ~2 days | ~2 days | ~4 days |
| Code consistency | Medium | High (where it matters) | Highest |
| Parallel development | Not possible | After foundation (~1 day) | After foundation (~3 days) |
| Rework risk | Higher | Low | Lowest |
| Over-engineering risk | None | Low | Higher |
| Total estimated effort | ~8 days | ~7 days | ~8 days |

**Recommendation:** **Shape B (Lean Foundation + Vertical Slices)** — build only cursor pagination as shared infrastructure (the one pattern used by all three features), then proceed with vertical slices. This balances consistency (shared pagination) with pragmatism (other components built in context). The ~1 day foundation investment is proportional to the ~7 day total phase scope.

## Open Questions

- **TenantInterceptor interaction:** Does adding `parentOrganizationId` to organizations change tenant resolution for existing org-scoped features? Must be investigated before implementation — see Org hierarchy section.
- **Guard chain for superadmin:** Does `@Roles('superadmin')` short-circuit the `@RequireOrg` check, or does a superadmin without an active org get 403 on cross-tenant endpoints? Must be confirmed.
- **Rate limiting:** Phase 1 applies `@Throttle({ global: { ttl: 60_000, limit: 30 } })` on `AdminMembersController`. The same or similar throttle should apply to Phase 2 controllers. The spec should specify the rate limit tier.

## Next Steps

1. **Investigate TenantInterceptor + parentOrganizationId interaction** — this is a hard blocker for the org hierarchy feature.
2. **Verify guard chain** for `@Roles('superadmin')` on org-free endpoints.
3. **Create spec** (`specs/269-admin-phase2.mdx`) with API contracts, component breakdown, and implementation slices.
4. **Define cursor pagination utility API** (backend helper + frontend hook) as the first implementation task.
