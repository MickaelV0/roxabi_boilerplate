---
title: "CI/CD Database Migrations Strategy"
description: Analysis of approaches for automating Drizzle DB migrations in the CI/CD pipeline
---

## Context

Database migrations (Drizzle Kit) are never executed as part of the CI/CD pipeline. When schema changes merge to `main` and Vercel auto-deploys, the database is **not updated** — migrations must be run manually, which is error-prone and can cause runtime failures when code expects a schema that doesn't exist yet.

**Current state:**

- **CI workflow** (`.github/workflows/ci.yml`): lint → typecheck → test → build → e2e. No migration step.
- **Deploy preview** (`.github/workflows/deploy-preview.yml`): builds and deploys to Vercel via `workflow_dispatch`. No migration step.
- **Vercel production deploy**: auto-triggers on push to `main` via `turbo-ignore`. No pre-deploy hook for migrations.
- **Migration files**: `apps/api/drizzle/migrations/` (SQL files managed by `drizzle-kit generate`).
- **Migration command**: `bun run db:migrate` (runs `drizzle-kit migrate`).
- **Database**: Neon serverless PostgreSQL (connection via `DATABASE_URL`).
- **Related issue**: #106 (drizzle-kit ESM .js extension bug) — fix in progress separately.

## Questions Explored

1. Where should migrations run relative to Vercel's auto-deploy to avoid race conditions?
2. How should preview environments handle database schema changes?
3. What happens when a migration fails during deployment?
4. How can we detect schema drift (forgotten `db:generate`) early in the PR process?

## Analysis

### Migration Timing: Vercel Build Command

Three approaches were evaluated:

| Approach | Race condition | Complexity | Extra secrets needed |
|----------|---------------|------------|---------------------|
| **GitHub Actions workflow** | Yes (GH Actions and Vercel race) | Medium (new workflow) | Yes (`DATABASE_URL` in GH) |
| **Vercel build command** | **No** (atomic with build) | **Low** (edit `vercel.json`) | **No** (already in Vercel env) |
| **Orchestrated deploy** | No (full control) | High (disable auto-deploy, CLI orchestration) | Yes |

**Decision: Vercel build command.**

Modify the API project's `vercel.json` to run migrations before building:

```json
{
  "buildCommand": "bun run db:migrate && turbo run build"
}
```

Rationale:
- **Zero race condition** — migration and build are a single atomic step. New code only goes live after both succeed.
- **No extra secrets** — `DATABASE_URL` is already configured in Vercel environment variables.
- **Simplest implementation** — one line change to `vercel.json`, no new workflow files.
- **Idempotent** — `drizzle-kit migrate` is safe to re-run. When no pending migrations exist, it completes instantly with no changes.
- Only the **API project** runs migrations (web project's `vercel.json` is unchanged).

### Preview Environments: Neon Branch Databases

For preview deployments, use **Neon's database branching** to create isolated database branches:

- Each preview deploy gets its own Neon branch (fork of the production database).
- Migrations run against the branch database, not production.
- Branch databases are ephemeral — created on PR open, deleted on PR close/merge.

This requires:
- Neon API integration (create/delete branches programmatically).
- A separate `DATABASE_URL` per preview environment (Neon branch connection string).
- Updates to the deploy-preview workflow to manage branch lifecycle.

**Note:** This is a more complex enhancement. The initial implementation can focus on production migrations only, with Neon branching as a fast follow.

### Failure Handling: Block Deploy + Alert

If `db:migrate` fails inside the Vercel build command:
- The entire build fails → Vercel does not deploy the new code.
- The failure surfaces as a Vercel build error (visible in dashboard and GitHub commit status).
- No automated rollback — Drizzle Kit does not have built-in down migrations.
- **Manual rollback process**: revert the migration SQL and re-deploy, or apply a corrective migration.

### Schema Drift Detection in CI

Add a step to `ci.yml` that runs on PRs to detect when schema TypeScript files have changed but no corresponding migration was generated:

- Run `drizzle-kit check` (or generate to a temp directory and diff against existing migrations).
- If drift is detected, fail the CI check with an actionable message.
- Adds ~10 seconds to CI runtime.
- Prevents the common mistake of merging schema changes without migration files.

**Requirement**: This may need `DATABASE_URL` available in GH Actions (for `drizzle-kit check`), or a way to run the check in dry-run / local mode. Needs investigation during implementation.

## Conclusions

1. **Production migrations via Vercel build command** is the simplest, safest approach — no race conditions, no extra infrastructure, one-line change.
2. **Neon branch databases** for preview environments provide full isolation but add complexity. Can be phased in after the core production migration pipeline is stable.
3. **Drift detection in CI** is low-cost and high-value — catches a common developer mistake before it reaches production.
4. **No automated rollback** — Drizzle Kit doesn't support it natively. Document the manual process instead.

## Next Steps

- Create a spec for implementation details (vercel.json changes, CI drift check, Neon branching workflow)
- Verify `drizzle-kit check` works without a live database connection (or plan for `DATABASE_URL` in GH Actions)
- Investigate Neon API for branch lifecycle management (create on PR, delete on merge/close)
- Coordinate with #106 fix to ensure `drizzle-kit migrate` works reliably in Vercel's build environment
