---
title: "Vercel Marketplace Integration Migration"
description: Analysis of migrating Neon, Resend, and Upstash to Vercel Marketplace integrations with auto-injected environment variables
---

## Context

Roxabi Boilerplate uses three external services — **Neon** (PostgreSQL), **Resend** (transactional emails), and **Upstash Redis** (rate limiting). All three offer native Vercel Marketplace integrations that auto-inject environment variables, but we currently configure most of them manually via `vercel env add`.

This analysis evaluates migrating to marketplace integrations, audits all env vars for integration opportunities, and addresses concerns around vendor lock-in, naming conflicts, and fork-user experience.

**GitHub Issue:** [#181](https://github.com/MickaelV0/roxabi_boilerplate/issues/181)

## Questions Explored

1. What is the current integration status of each service (Upstash, Resend, Neon)?
2. What are the migration options for Neon, given our custom preview deploy workflow?
3. Should we switch from `postgres` (postgres.js) to `@neondatabase/serverless`?
4. Are there other env vars that could benefit from marketplace integrations?
5. What are the vendor lock-in, naming conflict, and fork-user experience implications?

## Analysis

### Current State

| Service | Vercel Integration installed? | Env vars | Manual setup required? |
|---------|------|------|------|
| **Upstash Redis** | Yes (documented) | `KV_REST_API_URL`, `KV_REST_API_TOKEN` | No — auto-injected |
| **Neon** | No | `DATABASE_URL` | Yes — `vercel env add` |
| **Resend** | No | `RESEND_API_KEY` | Yes — `vercel env add` |

### Service-by-Service Assessment

#### Upstash Redis — Already Integrated

Upstash Redis is already configured as a Vercel Marketplace integration. The deployment guide (`deployment.mdx`) documents the full integration setup and the code uses the auto-injected env var names (`KV_REST_API_URL`, `KV_REST_API_TOKEN`).

**Action:** Verify integration is active on both Vercel projects, document verification steps. No code or config changes needed.

#### Resend — Straightforward Migration

The Resend Vercel integration exists on the marketplace and auto-injects `RESEND_API_KEY` — matching our current env var name exactly.

**Migration steps:**
1. Install Resend integration from [vercel.com/marketplace/resend](https://vercel.com/marketplace/resend)
2. Link to the API project
3. Remove manual `vercel env add RESEND_API_KEY` from deployment docs
4. Redeploy for env var injection

**Risk:** Low. Env var name matches. No code changes needed.

**Caveat:** If a manual `RESEND_API_KEY` already exists in the Vercel project, confirm whether the integration overwrites it, shadows it, or coexists. Recommended migration path: install integration, verify the key works (send a test email), then remove the manual env var to avoid confusion.

#### Neon — Requires Decision

The Neon Vercel integration is the most complex migration due to our custom preview deploy workflow.

**What the Neon integration provides:**
- Auto-injects `DATABASE_URL` (pooled) and `DATABASE_URL_UNPOOLED` (direct), plus legacy `POSTGRES_*` vars
- Auto-creates preview database branches when Vercel creates preview deployments
- Auto-cleans up branches when preview deployments are deleted

**Critical finding:** The Neon integration's auto-branching is **webhook-driven** — it triggers only when Vercel's built-in preview deployment system creates a deployment. It does **not** trigger on CLI-initiated `vercel deploy` commands (which is what our Deploy Preview GitHub Action uses).

##### Option A: Integration for Production Only

Install the Neon integration for production `DATABASE_URL` auto-injection. Keep the custom GitHub Actions workflow (`deploy-preview.yml`) for preview database branches.

| Aspect | Details |
|--------|---------|
| **What changes** | Production `DATABASE_URL` auto-injected instead of manual `vercel env add` |
| **What stays the same** | `deploy-preview.yml` workflow, `NEON_API_KEY`/`NEON_PROJECT_ID` GitHub secrets, manual preview branch management |
| **Pros** | Minimal disruption, incremental improvement, custom workflow gives full control |
| **Cons** | Still need GitHub secrets for Neon API, two sources of truth for database config |
| **Risk** | Low |

##### Option B: Full Integration with Auto-Branching

Re-enable Vercel automatic preview deploys. Use Neon integration auto-branching. Retire the custom `deploy-preview.yml` workflow entirely.

| Aspect | Details |
|--------|---------|
| **Prerequisite** | Re-enable automatic preview deploys at the Vercel project level |
| **What changes** | Vercel triggers preview deploys on every push; Neon auto-creates/deletes branches |
| **What's removed** | `deploy-preview.yml` workflow, `NEON_API_KEY`/`NEON_PROJECT_ID` GitHub secrets |
| **Pros** | Simplest long-term, no custom workflow to maintain, full Vercel-native experience |
| **Cons** | Preview deploys on *every* push (rate limit concern — the reason they were disabled), loss of manual trigger control via GitHub workflow, Neon branch cleanup depends on Vercel's deployment lifecycle (less aggressive than our current PR-close trigger) |
| **Risk** | Medium — reintroduces the rate-limit issue that led to disabling preview deploys |

**Important:** Automatic preview deploys are currently disabled to avoid Vercel deployment rate-limit exhaustion. Re-enabling them would reintroduce this problem unless Vercel's limits have changed or a Pro plan is used.

##### Option C: Hybrid — Integration for Production, Custom for Previews

Same as Option A, but explicitly document the split: Neon integration owns production env vars, GitHub Actions workflow owns preview branching.

| Aspect | Details |
|--------|---------|
| **What changes** | Production `DATABASE_URL` from integration; preview `DATABASE_URL` from workflow |
| **Pros** | Best of both — auto-synced production, full control over previews |
| **Cons** | Two branching mechanisms to understand (integration for prod, API for previews), credential rotation for Neon API secrets still manual |
| **Risk** | Low |

**Recommendation:** **Option C** (hybrid) — functionally identical to Option A but explicitly acknowledges and documents the split responsibility. This provides the production simplification without touching the preview workflow.

**Important interaction:** The `deploy-preview.yml` workflow passes `DATABASE_URL` via the `--env` flag (line 249), which overrides any Vercel project env vars at deploy time. After Neon integration install, the integration will inject a production `DATABASE_URL` into the preview scope, but the workflow's `--env` override takes precedence — preview deploys continue pointing to their isolated Neon branch. This override must be preserved and documented.

### Driver Comparison: postgres.js vs @neondatabase/serverless

| Factor | postgres.js (`postgres`) | @neondatabase/serverless |
|--------|--------------------------|--------------------------|
| **Runtime support** | Node.js only | Node.js + Edge (WebSocket-based) |
| **Our runtime** | Vercel Functions (Node.js) | Vercel Functions (Node.js) |
| **Performance** | TCP connections, client-side connection pooling (configured in `drizzle.provider.ts`) | WebSocket or HTTP fetch, uses Neon's server-side pooler |
| **Drizzle integration** | `drizzle-orm/postgres-js` | `drizzle-orm/neon-serverless` or `drizzle-orm/neon-http` |
| **Migration effort** | None (current driver) | Change adapter import, test all queries |
| **Edge compatibility** | Not compatible | Full Edge support |

**Recommendation:** **Keep postgres.js.** We run on Node.js runtime (not Edge), so the serverless driver provides no benefit. Switching adds migration risk with no functional gain. If we move to Edge Functions in the future, this can be revisited.

### Full Environment Variable Audit

All env vars from `.env.example` and `configuration.mdx`, checked for Vercel Marketplace integration availability:

| Variable | Used By | Marketplace Integration? | Notes |
|----------|---------|-------------------------|-------|
| `DATABASE_URL` | API | **Yes — Neon** | Auto-injected by Neon integration |
| `RESEND_API_KEY` | API | **Yes — Resend** | Auto-injected by Resend integration |
| `KV_REST_API_URL` | API | **Yes — Upstash** (already active) | Auto-injected |
| `KV_REST_API_TOKEN` | API | **Yes — Upstash** (already active) | Auto-injected |
| `BETTER_AUTH_SECRET` | API | No | App-specific secret |
| `BETTER_AUTH_URL` | API | No | App-specific URL |
| `CORS_ORIGIN` | API | No | App-specific URL |
| `APP_URL` | Both | No | App-specific URL |
| `API_URL` | Both | No | App-specific URL |
| `EMAIL_FROM` | API | No | App-specific config |
| `GOOGLE_CLIENT_ID` | API | No | Manual OAuth setup required |
| `GOOGLE_CLIENT_SECRET` | API | No | Manual OAuth setup required |
| `GITHUB_CLIENT_ID` | API | No | Manual OAuth setup required |
| `GITHUB_CLIENT_SECRET` | API | No | Manual OAuth setup required |
| `GITHUB_TOKEN` | CI/Dev | No | Personal access token |
| `OPENAI_API_KEY` | Dev | No | No marketplace integration |
| `ANTHROPIC_API_KEY` | Dev | No | No marketplace integration |
| `VITE_ENABLE_DEMO` | Web | No | Build-time feature flag |
| `VITE_GITHUB_REPO_URL` | Web | No | Build-time config |
| `RATE_LIMIT_ENABLED` | API | No | App-specific kill switch |
| `SWAGGER_ENABLED` | API | No | App-specific toggle |

**Finding:** Only three services have marketplace integrations (Neon, Resend, Upstash), and Upstash is already integrated. No additional marketplace opportunities exist for our current env vars. OAuth providers, AI API keys, and app-specific variables all require manual configuration.

### Concerns Assessment

#### Vendor Lock-in

| Concern | Assessment |
|---------|-----------|
| **Reversibility** | All three integrations can be uninstalled at any time. Env vars persist after uninstallation — you just manage them manually again. |
| **Data portability** | Neon databases, Resend domains, and Upstash databases exist independently of Vercel. The integration only manages env var injection. |
| **Code coupling** | Zero. The code reads standard env vars (`DATABASE_URL`, `RESEND_API_KEY`, `KV_REST_API_*`). It doesn't know or care whether they were set by an integration or manually. |
| **Exit strategy** | Uninstall integration &rarr; add env vars manually &rarr; redeploy. No code changes. |

**Verdict:** Lock-in risk is **negligible**. Integrations are a convenience layer over standard env vars.

#### Env Var Naming Conflicts

| Service | Integration injects | We currently use | Conflict? |
|---------|-------------------|------------------|-----------|
| Upstash | `KV_REST_API_URL`, `KV_REST_API_TOKEN` | `KV_REST_API_URL`, `KV_REST_API_TOKEN` | **No** — exact match |
| Resend | `RESEND_API_KEY` | `RESEND_API_KEY` | **No** — exact match |
| Neon | `DATABASE_URL`, `DATABASE_URL_UNPOOLED`, `POSTGRES_*` | `DATABASE_URL` | **No conflict** — but Neon also injects extra `POSTGRES_*` vars we don't use |

**Verdict:** No naming conflicts. The extra `POSTGRES_*` vars from Neon are harmless — we don't read them.

**Caution:** If a `DATABASE_URL` env var already exists when the Neon integration is installed, confirm whether the integration overwrites it or skips it. Test during installation.

#### Fork-User Experience

Current fork setup requires 6+ `vercel env add` commands. After migration:

| Before | After |
|--------|-------|
| `vercel env add DATABASE_URL` (manual) | Install Neon integration (auto) |
| `vercel env add RESEND_API_KEY` (manual) | Install Resend integration (auto) |
| `vercel env add KV_REST_API_URL` (manual) | Already via Upstash integration |
| `vercel env add KV_REST_API_TOKEN` (manual) | Already via Upstash integration |
| 11 manual env vars total | **7 manual** + 4 auto-injected |

**Verdict:** Reduces manual setup by ~36%. More importantly, reduces the chance of misconfigured secrets (typos, wrong env scope).

### Migration Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Env var overwrite on install** | Neon/Resend integration may overwrite or conflict with existing manual env vars | Test on a staging project first; document behavior before production install |
| **Preview `--env` override removal** | If someone removes the `--env "DATABASE_URL=..."` from `deploy-preview.yml` assuming "the integration handles it," preview deploys would point to production | Add an explicit comment in the workflow file explaining the override is intentional |
| **Neon credential rotation** | Production auto-rotates via integration; preview workflow secrets (`NEON_API_KEY`, `NEON_PROJECT_ID`) still require manual rotation | Document the split responsibility in deployment guide |
| **Better Auth initialization** | New forks with empty production databases: Neon integration injects `DATABASE_URL` but tables don't exist until `drizzle-kit push --force` runs | Spec must include prerequisite: "Initialize production DB before first deploy" (already documented, but reinforce) |
| **Connection string format** | Neon integration may inject pooled vs direct URL; verify `?sslmode=require` and compatibility with postgres.js | Test the injected `DATABASE_URL` format against current Drizzle config |
| **Local dev unaffected** | Marketplace integrations only inject into Vercel environments; local `.env` files remain manual | No risk — but document that local dev setup is unchanged |

### Rollback Plan

If any integration causes issues after installation:

| Service | Rollback steps |
|---------|---------------|
| **Neon** | Uninstall integration &rarr; `vercel env add DATABASE_URL production` &rarr; redeploy |
| **Resend** | Uninstall integration &rarr; `vercel env add RESEND_API_KEY production` &rarr; redeploy |
| **Upstash** | Uninstall integration &rarr; `vercel env add KV_REST_API_URL` + `KV_REST_API_TOKEN` &rarr; redeploy |

No code changes needed in any rollback scenario. The application reads standard env var names regardless of source.

## Conclusions

1. **Upstash Redis** is already fully integrated — verify and document.
2. **Resend** is a quick win — install the integration, update docs, done.
3. **Neon** should use **Option C (hybrid)**: integration for production auto-injection, keep the custom GitHub Actions workflow for preview branches. Auto-branching via the integration does not trigger on CLI `vercel deploy` commands, and re-enabling automatic preview deploys would reintroduce rate-limit issues.
4. **Keep postgres.js** — no driver change needed since we run on Node.js, not Edge.
5. **No other env vars** have marketplace integrations available.
6. **Vendor lock-in is negligible** — integrations are a thin layer over standard env vars.
7. **No naming conflicts** — all injected var names match our current usage.

## Next Steps

- Create a spec from this analysis defining the implementation tasks
- Spec scope:
  - **Phase 1 — Verify:** Confirm Upstash integration is active (no changes, just verification + docs)
  - **Phase 2 — Resend:** Install integration, verify API key works, remove manual env var, update docs
  - **Phase 3 — Neon:** Install integration for production, test env var injection, verify preview workflow still works, update docs
  - **Docs updates:** `deployment.mdx`, `configuration.mdx`, `getting-started.mdx`, add comment in `deploy-preview.yml`
- Include pre-migration and post-migration verification checklists
- Include rollback procedures for each service
- Re-evaluate Option B if Vercel increases preview deploy limits or adds rate-limit controls
- Implementation is a Tier F-lite task (clear scope, documented requirements, single domain — devops)
