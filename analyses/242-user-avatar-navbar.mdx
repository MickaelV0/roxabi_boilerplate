---
title: "User Avatar System — DiceBear Customization & Navbar Integration"
description: Analysis of DiceBear avatar integration in navbar, UserMenu cleanup, new styles, and per-style customization.
---

## Context

The profile settings page (`/settings/profile`) already has a working DiceBear avatar picker with 5 styles and a seed input. The backend stores `avatarStyle` and `avatarSeed` on the user profile. However, **the navbar avatar never shows the DiceBear avatar** — it reads `user.image` from the Better Auth session (usually null) and falls back to text initials. The DiceBear configuration is effectively write-only.

Additionally, the `UserMenu` dropdown duplicates org-related links (Org Settings, Org Members) that already exist in the `OrgSwitcher` component, cluttering the user's personal menu with organization concerns.

The user wants to:
1. **Connect** the DiceBear avatar to the navbar so it actually displays
2. **Remove** org settings/members from the `UserMenu` dropdown (they live in `OrgSwitcher`)
3. **Add** new DiceBear styles (adventurer, toon-head)
4. **Expose** full per-style customization options (colors, accessories, features) via a dynamic form

**Related spec:** [specs/201-user-account-management.mdx](../specs/201-user-account-management) covers avatar at a high level but scopes it to style + seed only with "no real-time avatar editor with color picker" listed as a non-goal. This analysis supersedes that constraint for the avatar subsystem.

## Questions Explored

### Q1: How should the DiceBear avatar reach the navbar without importing DiceBear everywhere?

**Answer: Hybrid storage — CDN URL in `user.image`.**

The DiceBear HTTP API provides deterministic SVG URLs:
```
https://api.dicebear.com/9.x/{style}/svg?seed={seed}&backgroundColor=b6e3f4&...
```

On profile save, the backend (or frontend before PATCH) computes this URL from the selected style + seed + options and writes it to the `image` column on the `users` table. This column is already part of the Better Auth session, so `user.image` in the navbar immediately reflects the DiceBear avatar without any client-side DiceBear import.

**Trade-offs:**
- **Pro:** Zero bundle impact outside `/settings/profile`. Navbar uses a plain `&lt;img>` tag.
- **Pro:** Works in member lists, org switcher, and anywhere `user.image` is displayed.
- **Con:** Depends on DiceBear CDN for avatar display. Accepted for V1 — CDN URLs are deterministic and highly cacheable. Self-hosting DiceBear's API is a future hardening option if CDN reliability becomes an issue.
- **Con:** The `user.image` column is shared between DiceBear avatars and OAuth profile photos (Google/GitHub). This is a conscious trade-off — any future need to distinguish avatar source would require an additional column.

**CSP requirement:** The current Content Security Policy has `imgSrc: ["'self'", 'data:']`. Loading images from `https://api.dicebear.com` requires adding it to the allowed `img-src` origins. **This is a hard blocker** — without it, avatars will silently fail to load in production.

### Q2: What new DiceBear styles should be added?

**Answer: Add `adventurer` and `toon-head` (7 styles total).**

| Style | Package | Description |
|-------|---------|-------------|
| lorelei | `@dicebear/lorelei` | Artistic line-art faces (existing) |
| bottts | `@dicebear/bottts` | Robot/bot style (existing) |
| pixel-art | `@dicebear/pixel-art` | 8-bit pixel art (existing) |
| thumbs | `@dicebear/thumbs` | Emoji-like thumbs (existing) |
| avataaars | `@dicebear/avataaars` | Cartoon characters (existing) |
| **adventurer** | `@dicebear/adventurer` | Adventure-style illustrated characters (**new**) |
| **toon-head** | `@dicebear/toon-head` | Cartoon toon heads (**new**, user-requested as "toon head") |

Both new packages are MIT-licensed, zero-dependency, and follow the same DiceBear `Style&lt;Options>` interface as existing styles.

### Q3: How should full per-style options be exposed in the UI?

**Answer: Dynamic form that adapts to the selected style.**

Each DiceBear style exports a JSON schema describing its options (available at runtime via the style module's `schema` export). The UI should:

1. When the user selects a style, read that style's available options
2. Render controls dynamically:
   - **Color options** (e.g., `backgroundColor`, `hairColor`, `skinColor`) &rarr; color picker swatches from the style's allowed palette
   - **Enum options** (e.g., `eyes`, `mouth`, `clothing`) &rarr; dropdown/select with option names
   - **Probability options** (e.g., `glassesProbability`) &rarr; toggle on/off (map to 0 or 100)
   - **Boolean options** (e.g., `flip`) &rarr; toggle
3. The seed input and randomize button remain for quick variation
4. All selected options are stored as a JSON object (`avatarOptions` column) alongside `avatarStyle` and `avatarSeed`

**Complexity note:** Each style has 15-25 options. Not all need to be shown by default. Group into:
- **Primary options** (always visible): options that visually change the avatar's identity — `backgroundColor`, color options (`hairColor`, `skinColor`), and major feature selectors (`eyes`, `mouth`, `hair`, `clothing`). Rule: if changing the option produces a visibly different avatar at a glance, it's primary.
- **Advanced options** (behind a collapsible toggle): positioning (`flip`, `rotate`, `scale`, `translateX/Y`), probability sliders (`glassesProbability`, `facialHairProbability`), and minor features (`earrings`, `features`). Rule: cosmetic refinements that don't change the avatar's core identity.

**Scope watch:** The dynamic form with 7 styles is non-trivial frontend work. If implementation reveals more complexity than expected, consider shipping V1 with primary options only and deferring advanced options.

### Q4: What schema changes are needed?

**Current columns:** `avatar_seed TEXT`, `avatar_style TEXT DEFAULT 'lorelei'`

**New column:**
```sql
ALTER TABLE users ADD COLUMN avatar_options JSONB DEFAULT '{}';
```

The `avatar_options` column stores the DiceBear options object **using DiceBear's own option format verbatim**. DiceBear uses arrays for multi-value options (colors that allow multiple picks) and strings for single-value options:

```json
{
  "backgroundColor": ["b6e3f4"],
  "hairColor": ["2c1b18"],
  "eyes": ["variant01"],
  "flip": true,
  "scale": 90
}
```

This 1:1 mapping means options can be passed directly to DiceBear's `createAvatar()` for preview and to the CDN URL builder for display — no translation layer needed.

The `image` column (already exists, managed by Better Auth) is updated on save with the computed DiceBear CDN URL.

**Better Auth field management:** The `image` column is managed by Better Auth's Drizzle adapter. Writing to it via a direct Drizzle UPDATE (as the existing `PATCH /api/users/me` does) may conflict with Better Auth's session sync. The spec must verify whether to use Better Auth's `updateUser` API or direct Drizzle — and whether a session refresh is needed after the write (see Q7).

### Q5: What navbar changes are needed?

**UserMenu cleanup:**

Remove the `activeOrg` conditional block in `UserMenu.tsx` containing the Org Settings and Org Members links (plus the surrounding separator). These links are already accessible via the `OrgSwitcher` component in the header, making them redundant in the user's personal menu.

**Avatar display:**

The `UserMenu` trigger already uses `&lt;AvatarImage src={user.image}>` with an initials fallback. Once the backend writes the DiceBear CDN URL to `user.image` on profile save, the navbar avatar will display correctly **with no frontend changes to the avatar display logic**. The only change is ensuring that new users get a default DiceBear URL written to `user.image` on account creation.

### Q7: What about session cache lag after saving the avatar?

**Answer: Force session refresh after profile save.**

Better Auth's cookie cache has a 5-minute TTL. After a user saves their avatar, `user.image` is updated in the DB immediately, but the session cookie still holds the old `image` value until the cache expires. Without intervention, the navbar avatar won't update for up to 5 minutes.

**Solution:** After a successful profile PATCH, call `authClient.getSession({ fetchOptions: { cache: 'no-cache' } })` to force a session refresh. This immediately updates `user.image` in the client-side session state.

### Q8: What happens to OAuth profile photos?

**Answer: DiceBear save overwrites `user.image` — OAuth photo is not preserved separately.**

When a Google/GitHub OAuth user saves avatar settings, the DiceBear CDN URL replaces their OAuth profile photo in `user.image`. This is acceptable for V1 because:
- The avatar settings page is an explicit user action (not automatic)
- Users who prefer their OAuth photo can simply not customize their avatar
- Restoring the OAuth photo would require re-authenticating with the provider

**Future consideration:** If users request the ability to revert to their OAuth photo, a separate `oauth_image` column could store the original URL. This is out of scope for this feature.

### Q6: What about default avatars for users who haven't customized?

**Answer: Auto-generate on account creation.**

When a new user is created (or an existing user has no `avatar_style` set), the backend should:
1. Default `avatar_style` to `'lorelei'`, `avatar_seed` to the user's ID
2. Compute the DiceBear CDN URL and write it to `image`

This ensures every user has a unique, deterministic avatar from day one — no more initials fallback as the primary state.

**Migration for existing users:** A one-time data migration backfills all users:
1. Users with `avatar_style` set but `image` is null &rarr; compute CDN URL from their existing style + seed
2. Users with both `avatar_style` and `image` null &rarr; default to `avatar_style='lorelei'`, `avatar_seed=user.id`, compute CDN URL
3. Users with `image` already set (e.g., OAuth photos) &rarr; **skip** — do not overwrite existing photos

This ensures every user without an explicit photo gets a unique DiceBear avatar, while preserving OAuth profile photos for users who have them.

## Analysis

### Scope Assessment

This is a **focused feature** touching 3 areas:

| Area | Changes | Files |
|------|---------|-------|
| **Navbar cleanup** | Remove org links from UserMenu | 1 file (`UserMenu.tsx`) |
| **Avatar display** | Write CDN URL to `user.image` on save; default on creation | 2-3 files (backend user service, profile save handler) |
| **Avatar customization** | New styles, dynamic options form, `avatar_options` column | 4-5 files (profile.tsx, migration, types, packages) |

**Estimated tier:** F-lite (clear scope, single domain boundary between frontend settings page and backend user service). **Watch item:** the dynamic options form with 7 styles is the main complexity driver — if it proves more complex than expected, consider shipping V1 with primary options only.

### DiceBear CDN URL Construction

The URL pattern is:
```
https://api.dicebear.com/9.x/{style}/svg?seed={seed}&{key}={value}&{key}={value}
```

Array values (e.g., multiple allowed colors) use comma separation:
```
?backgroundColor=b6e3f4,ffdfbf&hairColor=2c1b18
```

The frontend can construct this URL client-side before sending the PATCH request, or the backend can build it from the stored options. **Recommendation: frontend constructs the URL** since it already has all the DiceBear context, and sends it as part of the PATCH payload.

**URL length:** DiceBear option query strings with many parameters can become long. Browser and CDN proxy limits are typically ~2000-8000 characters. The spec should include a URL length sanity check (warn if >2000 chars) to prevent silently broken avatar URLs.

### Bundle Impact

| Change | Impact |
|--------|--------|
| 2 new DiceBear style packages | ~50-100KB each, but **code-split** via dynamic import — only loaded on `/settings/profile` |
| Dynamic options form | New UI code in `profile.tsx` — moderate complexity, no new dependencies |
| Navbar avatar | **Zero impact** — uses existing `&lt;img>` with `user.image` URL |

### Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| DiceBear CDN downtime | Low | Medium (all avatars break sitewide) | Accepted for V1 — URLs are cacheable. Self-hosting is a future hardening option. |
| `@dicebear/toon-head` package name mismatch | Medium | Low | Verify exact package name on npm before implementation |
| Dynamic form complexity | Medium | Medium | Ship V1 with primary options only if complexity exceeds estimate |
| CSP blocks CDN images | Certain | High (silent failure) | **Must** add `api.dicebear.com` to `imgSrc` CSP before shipping |
| Session cache lag after avatar save | Certain | Low (stale avatar for up to 5 min) | Force session refresh via `authClient.getSession({ cache: 'no-cache' })` |
| OAuth photo overwrite | Low | Low | Users must explicitly save avatar settings; OAuth photo not preserved separately |

## Conclusions

1. **Hybrid storage is the right approach.** Store options in DB for the editor, cache the CDN URL in `user.image` for zero-cost display everywhere.

2. **CSP update is a hard blocker.** `api.dicebear.com` must be added to `imgSrc` before shipping.

3. **Navbar cleanup is trivial.** Remove the `activeOrg` conditional block from `UserMenu` — the org links already live in `OrgSwitcher`.

4. **Default DiceBear avatar on account creation** eliminates the initials fallback as the primary state. Every user gets a unique avatar from day one.

5. **Session refresh after save** is required to immediately update the navbar avatar (otherwise 5-min cache lag).

6. **Dynamic options form is the main complexity.** Each DiceBear style has 15-25 options. A primary/advanced split keeps the UI manageable. Ship V1 with primary options; defer advanced if needed.

7. **Bundle stays light.** All DiceBear packages are code-split. The navbar uses a plain image URL.

8. **OAuth photos are overwritten on avatar save** — this is acceptable for V1 as an explicit user action.

9. **Verify the `@dicebear/toon-head` package name** before implementation — DiceBear style names sometimes differ from display names.

## Next Steps

- Create a focused spec from this analysis covering:
  - Schema migration (`avatar_options` JSONB column)
  - Backend changes (CDN URL computation, default avatar on creation, backfill migration)
  - Frontend changes (UserMenu cleanup, new styles, dynamic options form)
  - Success criteria and acceptance tests
- Create a GitHub issue for tracking
- Scaffold implementation via `/scaffold`
