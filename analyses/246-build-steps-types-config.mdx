---
title: "Add Build Steps to @repo/types and @repo/config"
description: Add tsup build steps to shared packages so they export compiled JavaScript, fixing runtime ERR_MODULE_NOT_FOUND on Vercel
---

## Context

After the v0.3.0 release, every API endpoint returned 500 errors on Vercel. The root cause: `@repo/types` and `@repo/config` export raw TypeScript via `"exports": { ".": "./src/index.ts" }`. This works for `import type` (erased at compile time) and for bundled consumers (Vite/TanStack Start), but **fails at runtime** on Vercel where the NestJS API runs on Node.js without a bundler.

Two files added runtime imports of `DICEBEAR_CDN_BASE` and `AVATAR_STYLES` from `@repo/types`:
- `apps/api/src/auth/auth.instance.ts`
- `apps/api/src/user/user.controller.ts`

A hotfix (commit `9049f7b`) inlined the constants locally. The underlying issue remains — any future runtime import from either package **will break production**.

**Refs #246**

## Questions Explored

1. What is the minimal fix to make runtime imports safe for all consumers?
2. Should `@repo/config` be fixed now despite having zero runtime consumers?
3. Should `@repo/types/src/index.ts` (206 lines, 7+ domains) be split into domain files?
4. What build tooling and export strategy to use?
5. What TurboRepo pipeline changes are needed?

## Analysis

### Current State

| Package | Source files | Runtime values | Runtime consumers | Build step |
|---------|------------|----------------|-------------------|------------|
| `@repo/types` | 1 (`index.ts`, 206 lines) | `DICEBEAR_CDN_BASE`, `AVATAR_STYLES`, `ERROR_CODES` | 5 in `apps/web`, 1 test in `apps/api`, 2 inlined in `apps/api` (hotfix) | None |
| `@repo/config` | 1 (`index.ts`, 7 lines) | `config` object | 0 (no consumers yet) | None |
| `@repo/ui` | Many | Many (React components) | All web consumers | **tsup** (reference) |

**Runtime value exports in `@repo/types`:**
- `DICEBEAR_CDN_BASE` — used at runtime in `apps/web` (1 file) and `apps/api` (2 inlined + 1 test)
- `AVATAR_STYLES` — used at runtime in `apps/web` (3 files) and `apps/api` (1 inlined + 1 test)
- `ERROR_CODES` — currently only used via `import type` patterns; no runtime consumers yet, but it is a runtime value (`const`) that would trigger the same failure if imported at runtime

### Why It Breaks

The NestJS API on Vercel runs as compiled JavaScript on Node.js. When Node resolves `import { DICEBEAR_CDN_BASE } from '@repo/types'`, the `exports` field in `package.json` points to `./src/index.ts` — a raw TypeScript file. Node.js cannot execute `.ts` files natively, so it fails with `ERR_MODULE_NOT_FOUND` because the resolved path does not correspond to a valid JavaScript module.

Vite (used by TanStack Start) handles this transparently because it processes all imports through its transform pipeline, compiling TypeScript on the fly. This asymmetry is why the web app never hit this error while the API broke in production.

### Proposed Fix: tsup Build Step

Use **tsup** (already used by `@repo/ui`) to compile both packages. `tsup` must be added as a `devDependency` to both `@repo/types` and `@repo/config` — it is not hoisted to the workspace root.

**Reference config for `@repo/types`:**

```ts
import { defineConfig } from 'tsup'

export default defineConfig({
  entry: ['src/index.ts'],
  format: ['esm'],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
})
```

Key options:
- **`format: ['esm']`** — matches `"type": "module"` in both packages
- **`dts: true`** — generates `.d.ts` declaration files so `import type` continues to work with full IntelliSense
- **`splitting: false`** — bundles all domain re-exports into a single `dist/index.js` (no code-split chunks); matches `@repo/ui` pattern
- **`sourcemap: true`** — aids debugging
- **`clean: true`** — removes stale output before each build

`@repo/config` uses the same config (single small file, no domain split).

**Note on `dts` generation:** tsup invokes `tsc` internally for declaration emission. The shared `tsconfig.base` sets `"noEmit": true`, but tsup overrides this at runtime when generating declarations. This is standard tsup behavior and requires no workaround.

### Package.json Changes

Both packages adopt the same conditional export pattern as `@repo/ui`:

```json
{
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "source": "./src/index.ts",
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "files": ["dist"],
  "scripts": {
    "build": "tsup",
    "dev": "tsup --watch",
    "typecheck": "tsc --noEmit"
  }
}
```

- **`source`** — preserves the ability for bundlers (like Vite) to resolve the original TypeScript source when available
- **`import`** — ensures Node.js gets compiled JavaScript
- **`types`** — points TypeScript to generated declaration files
- **`main`** — fallback for tools that don't support the `exports` field
- **`files: ["dist"]`** — explicitly declares the compiled output as the package artifact (matches `@repo/ui` pattern)

**`@repo/config` sub-path exports:** The existing `"./tsconfig"` and `"./tsconfig.base"` exports point to raw JSON files (not TypeScript). These are TSConfig references consumed by the TypeScript compiler, not runtime imports — they are unaffected by this change and remain as-is.

### Domain File Split (`@repo/types`)

The current `index.ts` contains 7+ unrelated domains in a single 206-line file. Splitting improves maintainability and makes it easier to add types for new domains without growing a monolithic file. **This is optional scope** — the build step fix is the critical path, and the domain split can be shipped in the same PR or deferred if time-constrained.

**Proposed structure:**

| File | Exports |
|------|---------|
| `src/auth.ts` | `User`, `Role` |
| `src/api.ts` | `ApiErrorResponse` |
| `src/avatar.ts` | `DICEBEAR_CDN_BASE`, `AVATAR_STYLES`, `AvatarStyle` |
| `src/profile.ts` | `UserProfile`, `UpdateProfilePayload` (imports `AvatarStyle` from `./avatar`) |
| `src/account.ts` | `OrgOwnershipResolution`, `DeleteAccountPayload`, `AccountDeletionStatus`, `DeletionImpact`, `DeleteOrgPayload` |
| `src/errors.ts` | `ERROR_CODES` |
| `src/consent.ts` | `ConsentCategories`, `ConsentAction`, `ConsentCookiePayload`, `ConsentState`, `ConsentActions`, `ConsentRecord` |
| `src/rbac.ts` | `PermissionResource`, `PermissionAction`, `PermissionString`, `DefaultRoleSlug`, `Permission`, `OrgRole`, `RolePermission` |
| `src/index.ts` | Barrel re-export: `export * from './auth'`, `export * from './api'`, etc. |

The barrel `index.ts` uses flat `export * from './domain'` statements — these are order-independent at the module level. All cross-domain imports (e.g., `profile.ts` importing `AvatarStyle` from `./avatar`) are one-directional with no circular dependencies.

**All existing consumer imports remain unchanged** — they still import from `@repo/types` (the barrel). The split is an internal refactor only.

### TurboRepo Pipeline

The existing `turbo.jsonc` already has `"dependsOn": ["codegen", "^build"]` on the `build` task and `"dist/**"` in `outputs`. Once `@repo/types` and `@repo/config` have a `"build"` script, TurboRepo will automatically:
- Build them before any consumer's build
- Cache their `dist/` output correctly

Neither package has a `codegen` step, which is fine — TurboRepo treats missing tasks as no-ops in the dependency graph.

**Dev mode:** Both packages add `"dev": "tsup --watch"`. The `dev` task in `turbo.jsonc` has `"cache": false` and `"persistent": true`, so watch processes integrate naturally. Developers running `bun run dev` will get automatic recompilation when editing types or config.

**Test task gap:** The `test` task in `turbo.jsonc` currently has no `"dependsOn"` — it does not depend on `^build`. This means `turbo run test --filter=@repo/api` on a clean checkout (without a prior build) could fail if a test file imports a runtime value from `@repo/types` (e.g., `user.controller.test.ts` imports `DICEBEAR_CDN_BASE`). The spec should add `"dependsOn": ["^build"]` to the `test` task to close this gap.

### Cleanup: Replace Inlined Constants

After the build step is confirmed working, replace the inlined constants from the hotfix:

| File | Remove (inlined) | Replace with |
|------|-------------------|--------------|
| `apps/api/src/auth/auth.instance.ts` | `const DICEBEAR_CDN_BASE = 'https://api.dicebear.com/9.x'` (line 11) | `import { DICEBEAR_CDN_BASE } from '@repo/types'` |
| `apps/api/src/user/user.controller.ts` | `const DICEBEAR_CDN_BASE = ...` (line 12) + `const AVATAR_STYLES = [...]` (lines 13-22) | `import { DICEBEAR_CDN_BASE, AVATAR_STYLES } from '@repo/types'` |

`apps/api/src/user/user.controller.test.ts` already imports from `@repo/types` correctly — no changes needed. After the build step and the test task dependency fix above, this import will resolve to compiled JavaScript correctly in all contexts.

### Git Ignore

The `dist/` directories for both packages must be gitignored (compiled output should not be committed). Verify that the root `.gitignore` or package-level `.gitignore` covers `dist/` for these packages, consistent with `@repo/ui`.

### Risk Assessment

| Risk | Likelihood | Mitigation |
|------|-----------|------------|
| Build step breaks existing `import type` | Low | tsup generates `.d.ts` files; the `types` export field ensures TypeScript resolves declarations correctly |
| `@repo/ui` consumers regress | None | No changes to `@repo/ui` |
| Dev mode lag from compilation | Low | `tsup --watch` is fast for small packages; both are &lt;210 lines total |
| TurboRepo cache invalidation | Low | `dist/**` is already in the `build` task's `outputs` glob |
| Breaking change for consumers | None | The barrel `index.ts` re-exports everything — all existing import paths continue to work |
| Tests fail on clean checkout | Medium | Fixed by adding `"dependsOn": ["^build"]` to the `test` task in `turbo.jsonc` |

## Conclusions

1. **Use tsup** to add build steps to both `@repo/types` and `@repo/config`, matching the `@repo/ui` precedent. Both packages need `tsup` added as a `devDependency`.
2. **Fix `@repo/config` now** despite having zero runtime consumers. The `config` object is a runtime value, and any future API consumer would trigger the same production outage. The cost is negligible (7-line file) and eliminates a future incident.
3. **Compile to ESM** with declaration files, sourcemaps, and `splitting: false`. Update `package.json` exports, `main`, `types`, and `files` fields to point to `dist/`.
4. **Split `@repo/types`** into 8 domain files with barrel re-export (optional scope — can be deferred if time-constrained). No breaking changes to consumers.
5. **Minimal TurboRepo change:** Add `"dependsOn": ["^build"]` to the `test` task. The `build` task pipeline already handles the new packages correctly.
6. **Replace inlined constants** in the two hotfixed API files after the build step is confirmed working.
7. **Verify locally** before merging: run `bun run build && bun run test` to confirm compiled output resolves correctly, then verify via Vercel preview deploy.

## Next Steps

1. Create spec from this analysis → `specs/246-build-steps-types-config.mdx`
2. Implementation order in spec:
   - Add tsup + build config to `@repo/types` and `@repo/config` (critical fix)
   - Update `package.json` exports for both packages
   - Add `test` task dependency on `^build` in `turbo.jsonc`
   - Verify `dist/` is gitignored
   - Domain file split for `@repo/types` (optional, can be same PR)
   - Replace inlined constants in API files (after build is working)
   - Local verification + Vercel preview deploy
3. Execution via `/scaffold` after spec approval
