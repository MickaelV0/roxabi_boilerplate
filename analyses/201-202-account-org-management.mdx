---
title: "User Account & Organization Management (Edit & Delete)"
description: Combined analysis for user account management (#201) and organization management (#202) — shared patterns for editing, soft deletion, and GDPR compliance
---

## Context

Two closely related features need implementation:

- **Issue #201** — `feat(user): user account management (edit & delete)`: Users cannot currently edit their profile or delete their account. The backend exposes `GET/PATCH api/users/me` (name + image only), but **no frontend profile page exists**.
- **Issue #202** — `feat(org): organization management (edit & delete)`: Organization settings and member management pages **already exist** at `/org/settings` and `/org/members`. However, org deletion needs a soft-delete pattern, and the existing pages need enhancement.

Both features share patterns: edit flows, destructive action confirmation, soft deletion with grace periods, and GDPR-compliant data anonymization. This combined analysis designs these shared patterns once and applies them to both domains.

**Related analyses:**
- [Auth + Users (Better Auth)](./19-auth-users) — Foundation authentication and user management
- [Auth UI/UX](./68-auth-ui-ux) — Authentication UI/UX polish, new auth pages, and organization UI
- [RBAC](./24-rbac) — Role-based access control design

## Questions Explored

1. What profile fields should users be able to edit, and how does the name model need to evolve?
2. How should email change and password change work with Better Auth?
3. What soft-deletion pattern should be used, and how should the 30-day grace period work?
4. What happens to organizations when a user deletes their account?
5. How should data be anonymized after the grace period (GDPR)?
6. What confirmation UX patterns should destructive actions use?
7. What avatar solution should be used (no file upload infrastructure)?
8. What new frontend routes and pages are needed?

## Analysis

### 1. User Profile — Name Model Evolution

**Current state:** The `users` table has a single `name` field (text, not null). Better Auth uses this field directly via the Drizzle adapter.

**Target state:** Three fields:

| Field | DB Column | Type | Nullable | Default | Description |
|-------|-----------|------|----------|---------|-------------|
| `firstName` | `first_name` | text | NOT NULL | — | User's first name |
| `lastName` | `last_name` | text | NOT NULL | — | User's last name |
| `fullName` | `name` | text | NOT NULL | `firstName + ' ' + lastName` | Display name, editable independently |

**Critical decision: Keep the `name` column as-is in the database.** Better Auth's Drizzle adapter maps its internal `name` field directly to the `name` column. Renaming or dropping this column would break the adapter at runtime. Instead:
- Keep `name` as the DB column name — Better Auth continues to work.
- Alias it as `fullName` at the application layer (in `profileColumns`, DTOs, and `@repo/types` `User` type).
- Add `first_name` and `last_name` as new columns alongside.

**Spike required before spec:** Prototype that Better Auth correctly reads/writes the `name` column when `firstName`/`lastName` are also present, and that `additionalFields` config can expose `firstName`/`lastName` through the auth client. This is the highest-risk integration point.

**Migration strategy (three-phase):**
1. **Add columns as nullable:** `ALTER TABLE users ADD COLUMN first_name TEXT, ADD COLUMN last_name TEXT`
2. **Backfill:** Parse existing `name` — first word = `firstName`, rest = `lastName`. If `name` is a single word, set `lastName` to empty string or the same value.
3. **Set NOT NULL:** `ALTER TABLE users ALTER COLUMN first_name SET NOT NULL, ALTER COLUMN last_name SET NOT NULL`

This ordering avoids the NOT NULL constraint failure on existing rows.

**`fullName` sync contract:**
- On profile creation or when `firstName`/`lastName` change: `fullName` is auto-computed as `firstName + ' ' + lastName` **unless** the user has explicitly edited `fullName` independently.
- To track this, add a `fullNameCustomized` boolean column (default `false`). When the user directly edits `fullName`, set to `true`. When `true`, `firstName`/`lastName` changes do not overwrite `fullName`.
- This avoids a hidden coupling and makes the behavior explicit.

### 2. User Profile — Editable Fields

| Field | Edit Method | Validation | Notes |
|-------|------------|------------|-------|
| `firstName` | Direct PATCH | 1-50 chars, required | Updates `fullName` if not customized |
| `lastName` | Direct PATCH | 1-50 chars, required | Updates `fullName` if not customized |
| `fullName` | Direct PATCH | 1-100 chars, required | Sets `fullNameCustomized = true` |
| `email` | Better Auth `changeEmail` | Valid email, unique | Verify-new-email-first flow (see section 3) |
| `password` | Better Auth `changePassword` | Current password required | Only for email+password accounts |
| `avatar` | DiceBear seed/style selection | Valid style + seed | Generated client-side (see section 7) |

### 3. Email Change Flow

Better Auth provides a `changeEmail` API. The flow:

1. User enters new email on the profile page
2. Frontend calls `authClient.changeEmail({ newEmail })`
3. Better Auth sends a verification email to the **new** address
4. User clicks verification link &rarr; email is updated
5. Old email receives a notification of the change (security measure)

**Edge cases:**
- New email already in use &rarr; Better Auth returns error, show toast
- Verification link expires &rarr; user must re-initiate
- OAuth-only accounts &rarr; email comes from the provider. Hide the email change field for OAuth-only users (the email is managed by the OAuth provider).

### 4. Password Change Flow

Better Auth provides `changePassword`:

1. User enters current password + new password + confirmation
2. Frontend calls `authClient.changePassword({ currentPassword, newPassword })`
3. Better Auth verifies current password and updates

**Edge cases:**
- OAuth-only accounts (no password set) &rarr; hide the password change section entirely. A "Set password" flow is **out of scope** for this feature — it can be added later.
- Incorrect current password &rarr; show validation error
- New password same as current &rarr; reject

### 5. Soft Deletion Pattern

A shared pattern for both user accounts and organizations.

**New database columns** (on both `users` and `organizations` tables):

| Column | Type | Default | Description |
|--------|------|---------|-------------|
| `deletedAt` | timestamptz | null | When deletion was initiated |
| `deleteScheduledFor` | timestamptz | null | When permanent purge will occur (deletedAt + 30 days) |

**Database indexes** (partial, covering only non-null rows for efficient purge queries):

```sql
CREATE INDEX users_delete_scheduled_for_idx
  ON users (delete_scheduled_for)
  WHERE delete_scheduled_for IS NOT NULL;

CREATE INDEX organizations_delete_scheduled_for_idx
  ON organizations (delete_scheduled_for)
  WHERE delete_scheduled_for IS NOT NULL;

CREATE INDEX users_deleted_at_idx
  ON users (deleted_at)
  WHERE deleted_at IS NOT NULL;

CREATE INDEX organizations_deleted_at_idx
  ON organizations (deleted_at)
  WHERE deleted_at IS NOT NULL;
```

**Deletion lifecycle:**

```
Active → Soft-deleted (deletedAt set) → [30 days] → Anonymized (purge job)
                ↑
          Reactivation
       (login during grace period)
```

**Application-level enforcement:**
- All queries must filter `WHERE deletedAt IS NULL` by default. Implement as a `whereActive(table)` Drizzle query helper for explicit, consistent filtering across all queries.
- **Auth guard enhancement:** After `AuthService.getSession()` resolves the session, the guard must check `users.deletedAt`. If set, return a special response that the frontend renders as an "Account scheduled for deletion" page with a reactivation option. The reactivation endpoint is whitelisted from this check.
- **Session invalidation on soft-delete:** Explicitly `DELETE FROM sessions WHERE user_id = $1` — do **not** rely on the `ON DELETE CASCADE` constraint, because the user row is updated (not deleted) during soft-delete.

**Purge job — Vercel Cron Jobs (decision made):**

NestJS `@Cron()` from `@nestjs/schedule` is **not viable** in the current deployment. The API runs as a Vercel Function (serverless, stateless) — there is no persistent process to keep a scheduler alive. The purge must use **Vercel Cron Jobs**:

- Add a protected HTTP endpoint: `POST /api/internal/purge`
- Guard with a secret header (`x-cron-secret`) to block public access
- Configure in `vercel.json`:
  ```json
  {
    "crons": [
      { "path": "/api/internal/purge", "schedule": "0 2 * * *" }
    ]
  }
  ```
- The handler queries records where `deleteScheduledFor &lt; NOW()` and executes anonymization (see section 6)
- **Must be idempotent and transactional** — if the job fails mid-run, re-running it produces the same result without leaving records in an inconsistent state

### 6. GDPR Data Anonymization

After the 30-day grace period, PII is anonymized but records are kept for referential integrity. The purge job **always uses UPDATE** on `users`/`organizations` rows — **never DELETE** — to avoid triggering `ON DELETE CASCADE` which would destroy membership records needed for integrity.

**User anonymization:**

| Table | Action |
|-------|--------|
| `users` | UPDATE: `firstName` &rarr; `'Deleted'`, `lastName` &rarr; `'User'`, `name` (fullName) &rarr; `'Deleted User'`, `email` &rarr; `'deleted-{uuid}@anonymized.local'`, `image` &rarr; null, `emailVerified` &rarr; false |
| `sessions` | DELETE all sessions for user |
| `accounts` | DELETE all OAuth/password accounts for user |
| `verifications` | DELETE all verification tokens for user |
| `members` | KEEP records (referential integrity) — `userId` still references the anonymized user row |
| `invitations` (as inviter) | DELETE invitations where user is `inviterId` |
| `invitations` (as recipient) | DELETE invitations where `email` matches the user's original email (PII cleanup) |

**Organization anonymization:**

| Table | Action |
|-------|--------|
| `organizations` | UPDATE: `name` &rarr; `'Deleted Organization'`, `slug` &rarr; `'deleted-{uuid}'`, `logo` &rarr; null, `metadata` &rarr; null |
| `members` | DELETE all membership records |
| `invitations` | DELETE all pending invitations for this org |
| `roles` | DELETE tenant-scoped custom roles (cascade from `tenantId` FK handles `role_permissions`) |

**Ordering note:** When both a user and their org are purged in the same run, process user anonymization first (preserving member rows), then org anonymization (which deletes member rows). This avoids conflicts — DELETE on non-existent rows is a no-op.

### 7. Avatar System — DiceBear

**Why DiceBear:**
- 30+ styles, seed-based deterministic generation (same seed = same avatar)
- SVG output via `createAvatar().toDataUri()` — no external server, no file storage
- React-friendly with `useMemo` pattern
- MIT core license, active development

**Storage: dedicated columns (not JSON in `image`).**

The existing `image` column is a Better Auth field used for OAuth profile pictures (Google/GitHub populate it on sign-in). Repurposing it with JSON would break Better Auth's expectations. Add explicit columns:

| Column | Type | Default | Description |
|--------|------|---------|-------------|
| `avatar_seed` | text | null | DiceBear seed (defaults to user ID if null) |
| `avatar_style` | text | `'lorelei'` | DiceBear style name |

**Implementation:**
- Default seed: user's ID (deterministic, unique)
- Default style: one chosen default (e.g., `lorelei`)
- Profile page: avatar preview with style selector (dropdown of available styles) and optional seed override
- Avatar component: `useMemo` with `createAvatar(style, { seed, size })` &rarr; `toDataUri()` &rarr; `&lt;img&gt;`

**Bundle size: use individual style packages, not `@dicebear/collection`.**

`@dicebear/collection` bundles all 30+ styles (~800 KB+). Instead, install only the styles offered in the UI:
- `@dicebear/core` (required)
- Individual style packages: e.g., `@dicebear/lorelei`, `@dicebear/bottts`, `@dicebear/pixel-art`, `@dicebear/thumbs`, `@dicebear/avataaars` (5-6 curated styles)
- **DiceBear is frontend-only** — must never be imported in `apps/api`

### 8. User Account Deletion Flow

The deletion flow must handle organization ownership:

1. User clicks "Delete my account" on settings page
2. System checks: does the user own any organizations?
   - If yes: show list of owned orgs with options per org:
     - **Transfer ownership** &rarr; select an active member as new owner
     - **Delete organization** &rarr; soft-delete the org too (same 30-day pattern)
   - All orgs must be resolved (transferred or marked for deletion) before proceeding
   - If no: proceed directly
3. Confirmation step: user types their email to confirm
4. Execute:
   - Set `deletedAt` + `deleteScheduledFor` on user (and any orgs marked for deletion)
   - Execute ownership transfers for orgs marked for transfer
   - **Explicitly delete all user sessions** (`DELETE FROM sessions WHERE user_id = $1`) — force logout across all devices
   - Clear `activeOrganizationId` on any other user's session that references an org being deleted
5. Show confirmation page: "Your account is scheduled for deletion on {date}. You can reactivate by logging in before then."

**Reactivation:** When a soft-deleted user attempts to login, Better Auth will authenticate successfully (credentials are still valid). A post-session hook in the auth guard detects `deletedAt IS NOT NULL` and presents the reactivation option. If the user confirms reactivation: clear `deletedAt` and `deleteScheduledFor` via a dedicated endpoint, then proceed with normal login.

**Edge cases:**
- User is the sole owner of an org with other members &rarr; must transfer before deletion
- User initiates deletion while an ownership transfer is pending &rarr; block deletion until transfer completes
- Multi-owner org &rarr; user can delete their account freely; remaining owners continue

### 9. Organization Deletion Flow

1. Owner clicks "Delete organization" on org settings page (permission-gated: only owners)
2. Show impact summary: number of members, pending invitations, custom roles
3. Confirmation: type the organization name to confirm (case-insensitive match)
4. Execute:
   - Set `deletedAt` + `deleteScheduledFor` on organization
   - Clear `activeOrganizationId` on all sessions referencing this org
   - Member notification: **out of scope for initial implementation** (no notification system exists). Add as a follow-up task.
5. Members can no longer access org resources (queries filter `WHERE deletedAt IS NULL`)
6. Show confirmation: "Organization scheduled for deletion on {date}."

**Reactivation:** During the grace period, an owner (with an active account) can navigate to the org and trigger reactivation. The org settings page detects `deletedAt IS NOT NULL` and shows a reactivation banner instead of the normal settings. Only users who were owners before deletion can reactivate.

**Edge cases:**
- All owners delete their accounts during the grace period &rarr; org cannot be reactivated and is purged after 30 days
- Slug collision: if a new org is created with the same slug during the grace period, the anonymization job sets slug to `'deleted-{uuid}'` — no conflict because the new org already has the slug. Add a unique constraint exclusion check in the creation flow to prevent reuse of slugs from soft-deleted orgs.
- Pending invitations: immediately invalidated (recipients clicking the link see "Organization no longer exists")

### 10. Confirmation UX Patterns

Two destructive action patterns:

| Action | Confirmation Method | Rationale |
|--------|-------------------|-----------|
| Delete user account | Type email address | Unique to user, confirms identity |
| Delete organization | Type organization name | Confirms intent for the specific org |

Both use an `AlertDialog` with:
- Warning icon + red-toned header
- Impact summary (what will be affected)
- Text input that must match exactly (case-insensitive)
- Disabled "Delete" button until input matches
- "Delete" button in destructive variant (red)

### 11. Frontend Architecture — New Pages

| Route | Page | Status |
|-------|------|--------|
| `/settings` | User settings layout (with sidebar nav) | **New** |
| `/settings/profile` | Profile editing (name, avatar) | **New** |
| `/settings/account` | Account settings (email, password, delete) | **New** |
| `/org/settings` | Org settings (name, slug, delete) | **Enhance** (add soft-delete) |
| `/org/members` | Member management | **Existing** (no changes needed for this feature) |

The user settings pages follow the same layout pattern as `/org/*` — a layout route with sidebar navigation and content area.

### 12. Scope Assessment

**Tier: F-full** — new architecture concepts (soft-delete pattern, purge cron, name model migration), unclear integration points (Better Auth field mapping), touches 3 domains (API, web, types).

**Affected packages:**

| Package | Changes |
|---------|---------|
| `apps/api` | Schema migration, user service enhancement, purge cron endpoint, auth guard update |
| `apps/web` | New settings pages, org settings enhancement, DiceBear integration, confirmation dialogs |
| `packages/types` | `User` type update (firstName, lastName, fullName, avatarSeed, avatarStyle) |

**Two specs needed:**
- **#201 spec** — User account management: profile page, edit flows, account deletion, DiceBear avatar, name model migration, soft-delete pattern definition, purge cron
- **#202 spec** — Organization management enhancement: soft-delete for orgs (references shared pattern from #201), confirmation UX, org reactivation, org deletion cascade

The soft-delete pattern, purge cron, and GDPR anonymization are defined in the #201 spec. The #202 spec references them.

## Conclusions

1. **Keep the `name` column as-is** — Better Auth depends on it. Add `firstName`/`lastName` alongside and alias `name` as `fullName` at the application layer. A **spike is required** to validate Better Auth compatibility before spec writing.
2. **Soft deletion is the right pattern** for both users and orgs. Shared columns (`deletedAt`, `deleteScheduledFor`) with partial indexes. Vercel Cron Jobs for the daily purge (NestJS `@Cron()` is not viable in serverless).
3. **DiceBear** is the clear choice for avatars. Use individual style packages (not full collection) to control bundle size. Store `avatarSeed`/`avatarStyle` as dedicated columns.
4. **Email/password changes** leverage Better Auth's built-in APIs. OAuth-only accounts hide these sections.
5. **Account deletion** is the most complex flow due to org ownership handling. The "per-org choose: transfer or delete" pattern gives users full control.
6. **Organization deletion** already has the settings page — it needs the soft-delete pattern plus confirmation UX.
7. **Auth guard must check `deletedAt`** after session resolution. Sessions must be explicitly deleted on soft-delete (not via cascade).
8. **GDPR anonymization uses UPDATE, never DELETE** on user/org rows to preserve referential integrity.

## Next Steps

- [ ] **Spike: Better Auth field mapping** — Prototype that `firstName`/`lastName` columns work alongside `name`, and that `additionalFields` can expose them via the auth client
- [ ] Create spec for #201: User account management (profile page, edit flows, deletion, DiceBear avatar, shared soft-delete pattern, purge cron)
- [ ] Create spec for #202: Organization management enhancement (soft-delete, confirmation UX, reactivation)
- [ ] Decide on purge cron endpoint auth: Vercel Cron secret header vs CRON_SECRET env var
- [ ] Define org member notification mechanism for deletion (follow-up task, not blocking)
- [ ] Verify Vercel plan supports daily cron jobs (Hobby: 1/day, Pro: hourly)

## References

- [DiceBear Documentation](https://www.dicebear.com/introduction/) — Avatar library, styles, and API reference
- [DiceBear GitHub](https://github.com/dicebear/dicebear) — Source, React integration guide
- [Better Auth Documentation](https://www.better-auth.com/) — changeEmail, changePassword, organization plugin
- [Vercel Cron Jobs](https://vercel.com/docs/cron-jobs) — Serverless cron configuration
- [GDPR Right to Erasure (Art. 17)](https://gdpr-info.eu/art-17-gdpr/) — Data deletion requirements
