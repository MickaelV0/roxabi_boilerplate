---
title: "Brainstorm: OpenClaw Analysis"
description: Analysis of openclaw/openclaw for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#214](https://github.com/roxabi/boilerplate/issues/214)
**Repository:** [openclaw/openclaw](https://github.com/openclaw/openclaw)
**Stars / Activity:** 202,901 stars, last commit 2026-02-17 (actively maintained, very high velocity)

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Personal AI assistant â€” different problem domain, but deeply adjacent |
| How it works | ðŸŸ¢ | Multi-channel gateway + skills + sub-agent orchestration at production scale |
| Architecture | ðŸŸ¢ | Flat-src monorepo with native apps â€” far larger scope, battle-tested patterns |
| File structure | ðŸŸ¢ | Per-feature colocation with `.test.ts` sidecars, granular module splitting |
| Tech stack | ðŸŸ¢ | Oxlint + Oxfmt instead of Biome â€” faster, leaner linting story |
| DX | ðŸŸ¢ | Per-platform dev scripts, docs-only CI skip, prek hooks, dual pnpm+bun |
| Testing | ðŸŸ¢ | 70% coverage gate, unit/e2e/live/docker tiers, slowest-test reporting |
| CI/CD | ðŸŸ¢ | Scope-aware CI (docs-only skip), multi-OS matrix, secrets scanning baseline |
| Documentation | ðŸŸ¢ | Mintlify docs site, zh-CN i18n pipeline, AGENTS.md + CLAUDE.md symlink |
| Unique ideas | ðŸŸ¢ | Skills marketplace, QMD memory, prek pre-commit tool, detect-secrets baseline |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

OpenClaw is an installable personal AI assistant CLI (npm package `openclaw`) that routes messages from any messaging platform (WhatsApp, Telegram, Slack, Discord, iMessage, Signal, Teams, Matrix, Zalo, WebChat) to a local AI agent runtime. It is not a SaaS boilerplate â€” it is a shipped product with 200k+ stars and 36k+ forks.

- **Purpose:** Own-your-data personal AI â€” run Claude/OpenAI/Gemini from your own devices across all messaging apps
- **Target audience:** Power users, developers, and teams who want AI without vendor lock-in
- **Problem solved:** Fragmented messaging surfaces, cloud dependency for AI inference, lack of persistent memory and tool extensibility

Compared to roxabi (which is a SaaS web application boilerplate), openclaw is a CLI daemon product. The domains are different, but the engineering problems â€” TypeScript monorepo at scale, testing discipline, AI integration, CI/CD â€” overlap significantly.

### 2. How It Works ðŸŸ¢

The architecture is a local gateway model:

1. A **Gateway** process (Node.js daemon) opens a WebSocket control plane that manages sessions, channels, tools, and events
2. **Channels** (Telegram, Discord, WhatsApp, etc.) are connection adapters that forward messages to the gateway
3. **Pi agents** (named after the runtime) receive messages, invoke tools, call LLM APIs (Anthropic/OpenAI/Gemini/Ollama/etc.)
4. **Skills** are installable npm packages that extend agent tool capabilities â€” they are loaded at runtime from `~/.openclaw/skills/`
5. **Sub-agents** can be spawned from any agent session with depth limits and lifecycle management
6. **Memory** uses vector embeddings (SQLite-vec + Voyage/OpenAI/Gemini) with hybrid search (MMR) and temporal decay

The `openclaw onboard` wizard drives first-time setup interactively. Native apps (macOS menu bar, iOS, Android) connect to the local gateway via a protocol schema that is code-generated and type-safe.

### 3. Architecture & Layers ðŸŸ¢

OpenClaw uses a **flat `src/` monorepo** (not a TurboRepo workspace style) with a `packages/` directory for two workspace packages (`clawdbot`, `moltbot`). The native apps live under `apps/`:

```
src/           # Core TypeScript source â€” all modules colocated here
  agents/      # Agent runtime, sub-agents, tool execution, model catalog
  memory/      # Embedding manager, QMD (Query-Memory-Distill), sqlite-vec
  channels/    # Channel routing, allowlists, pairing
  telegram/    # Telegram adapter
  discord/     # Discord adapter
  gateway/     # WebSocket control plane
  security/    # Audit, scan, secret scanning, Windows ACL
  ...
apps/
  macos/       # Swift macOS menu bar app
  ios/         # Swift iOS app (Xcode)
  android/     # Kotlin Android app (Gradle)
  shared/      # OpenClawKit Swift framework shared by macOS/iOS
packages/
  clawdbot/    # Discord bot package
  moltbot/     # Telegram bot package
skills/        # First-party skills shipped with the CLI
extensions/    # Channel extensions (Teams, Matrix, Zalo, voice-call)
ui/            # Web UI (Control UI, Canvas)
```

Key design patterns:
- **Protocol-first:** A JSON schema (`dist/protocol.schema.json`) is code-generated from TypeScript and used to generate Swift models for native apps â€” `pnpm protocol:check` enforces no drift
- **Plugin SDK:** Published as `openclaw/plugin-sdk` â€” skills depend on it as a peer dep, avoiding workspace coupling
- **DI via `createDefaultDeps`:** Dependency injection through explicit factory functions rather than a DI framework
- **No class prototype mutation:** Documented hard rule; prefer explicit class hierarchies

### 4. File / Project Structure ðŸŸ¢

The file structure strategy differs fundamentally from roxabi but offers strong lessons:

**Per-feature colocation at extreme granularity:**
```
src/agents/
  pi-embedded-runner.ts
  pi-embedded-runner.e2e.test.ts
  pi-embedded-runner.sanitize-session-history.e2e.test.ts
  pi-embedded-runner.sanitize-session-history.test-harness.ts
  pi-embedded-runner.guard.waitforidle-before-flush.test.ts
  ...
```

Every source file has its test file(s) colocated with explicit scope naming (`.e2e.test.ts` vs `.test.ts` vs `.live.test.ts`). Test harnesses are separate `*.test-harness.ts` files. This is different from roxabi's `src/__tests__/` style.

**Naming conventions:**
- Feature slices in kebab-case: `pi-embedded-runner.ts`, `auth-profiles.ts`
- Subtopics use dot notation: `pi-embedded-runner.guard.ts`, `models-config.providers.ts`
- E2E vs unit suffix encoded in filename
- `AGENTS.md` at repo root doubles as `CLAUDE.md` via symlink

**Config files:**
- `.oxlintrc.json` â€” Oxlint config
- `.oxfmtrc.jsonc` â€” Oxfmt config
- `.shellcheckrc` â€” Shell script lint
- `.markdownlint-cli2.jsonc` â€” Markdown lint
- `.swiftlint.yml` / `.swiftformat` â€” Swift tooling
- `.pre-commit-config.yaml` â€” Pre-commit hook config (uses `prek`)
- `.secrets.baseline` / `.detect-secrets.cfg` â€” Secret scanning baseline

### 5. Tech Stack & Tooling ðŸŸ¢

| Concern | OpenClaw | roxabi_boilerplate |
|---------|----------|--------------------|
| Runtime | Node.js 22+ (also Bun for dev) | Bun 1.3.9 |
| Package manager | pnpm (primary) + bun (dev) | Bun |
| Language | TypeScript (ESM, strict) | TypeScript 5.x (strict) |
| Linter | **Oxlint** (type-aware) | Biome |
| Formatter | **Oxfmt** | Biome |
| Test runner | Vitest (multiple configs) | Vitest |
| Build | tsdown (ESM bundler) | TurboRepo + Vite |
| Monorepo | pnpm workspaces | TurboRepo + Bun workspaces |
| Git hooks | **prek** + git-hooks dir | Lefthook |
| Pre-commit scanning | **detect-secrets** | â€” |
| Docs | Mintlify | Custom MDX (TanStack) |
| Native apps | Swift (macOS/iOS) + Kotlin (Android) | â€” |

The most significant divergence: **Oxlint + Oxfmt instead of Biome**. Oxlint is Rust-based, type-aware (runs TypeScript type checking as part of linting), and significantly faster. Biome is also Rust-based but is a single tool combining both. The openclaw team explicitly chose Oxlint for type-aware rules (`--type-aware` flag), which Biome does not yet support.

**`prek`** (pre-commit replacement tool) is used instead of Lefthook. It runs the same checks-as-CI philosophy.

### 6. Developer Experience (DX) ðŸŸ¢

Strong DX practices worth noting:

- **Dual runtime support:** `pnpm install` for production/CI, `bun install` for dev speed â€” both lockfiles kept in sync
- **Docs-only CI skip:** CI detects docs-only changes and skips expensive jobs (test, build, Windows, macOS, Android) â€” only lint and format always run
- **Scope-aware CI:** Changed files are analyzed to decide whether to run Node, macOS Swift, or Android Gradle lanes â€” avoids running all CI on every PR
- **Per-platform dev scripts:** `pnpm ios:run`, `pnpm android:run`, `pnpm gateway:dev`, `pnpm mac:open` â€” each platform has dedicated dev entry points
- **`openclaw doctor`** CLI command for config/service diagnostics
- **Interactive onboarding wizard** (`openclaw onboard --install-daemon`) â€” zero-friction first run
- **prek** hooks: run same checks as CI (lint + format + type)
- **3 release channels:** `stable` (tagged), `beta` (prerelease), `dev` (main HEAD)
- **LOC guardrail:** Enforced by `scripts/check-ts-max-loc.ts --max 500` â€” files over ~500 LOC trigger a warning

**Comparison to roxabi:** roxabi has solid DX with `bun run dev`, Lefthook, and `.env.example`. OpenClaw's scope-aware CI and docs-only skip are clearly superior for a large active repo. The roxabi onboarding (`.env.example` + `bun install`) is comparably simple for its narrower scope.

### 7. Testing Strategy ðŸŸ¢

Exemplary testing discipline:

- **Framework:** Vitest with V8 coverage (70% lines/branches/functions/statements enforced)
- **Multiple vitest configs:**
  - `vitest.unit.config.ts` â€” fast unit tests only (excludes gateway and extensions)
  - `vitest.config.ts` â€” full unit suite
  - `vitest.e2e.config.ts` â€” e2e tests (real filesystem/process)
  - `vitest.live.config.ts` â€” live integration tests (real API keys)
  - `vitest.extensions.config.ts` â€” extension-scoped tests
  - `vitest.gateway.config.ts` â€” gateway-scoped tests
- **Test tiers:**
  - Unit: `*.test.ts`
  - E2E (local, no keys): `*.e2e.test.ts`
  - Live (real keys required): `*.live.test.ts`
  - Docker: `pnpm test:docker:all`
- **Test harness pattern:** `*.test-harness.ts` files encapsulate shared setup/mocks
- **Slowest-test reporting:** `scripts/vitest-slowest.mjs` generates a Markdown report of top-50 slowest tests â€” uploaded as CI artifact
- **Multi-runtime:** Tests run on both Node and Bun in CI (matrix strategy)
- **Windows CI:** Full test suite runs on Windows (Blacksmith `windows-2025`) to catch cross-platform issues
- **iOS coverage gate:** 43% minimum enforced by Python script in CI (currently disabled but structure is there)

**Comparison to roxabi:** roxabi has unit + e2e (Playwright) tiers. OpenClaw's tier separation (unit/e2e/live/docker) and slowest-test artifact are significantly more mature. The 70% V8 coverage threshold is a best practice roxabi should adopt.

### 8. CI/CD Pipelines ðŸŸ¢

OpenClaw's CI workflow (`ci.yml`) is more sophisticated than roxabi's:

**Scope detection:**
```yaml
docs-scope:      # detects docs-only changes â†’ skips heavy jobs
changed-scope:   # detects which platforms changed (Node/macOS/Android)
```

**Job graph:**
- `check` â€” types + lint + oxfmt (always runs except docs-only)
- `check-docs` â€” markdown lint + broken links (only when docs changed)
- `secrets` â€” `detect-secrets` against `.secrets.baseline`
- `build-artifacts` â€” builds `dist/` once, uploads as artifact for downstream jobs
- `checks` â€” vitest (Node + Bun matrix) + protocol check
- `checks-windows` â€” lint + test + protocol on Windows
- `release-check` â€” validates npm pack contents (push to main only)
- `macos` â€” Swift lint + build + test (consolidated single runner to conserve macOS quota)
- `android` â€” Gradle test + build matrix

**CI provider:** Blacksmith (custom fast GitHub Actions runners), not standard `ubuntu-latest`

**Secret scanning:** `detect-secrets` with a `.secrets.baseline` committed to the repo â€” incremental scanning against the baseline rather than full history scan on every PR.

**Comparison to roxabi:** roxabi has a solid 5-stage pipeline (lint/typecheck/test/build/e2e). OpenClaw's docs-only skip and scope-aware platform detection would reduce CI times meaningfully as roxabi grows. The `detect-secrets` baseline approach is a security practice roxabi is missing.

### 9. Documentation Quality ðŸŸ¢

- **Mintlify docs site** at `docs.openclaw.ai` â€” structured, searchable, versioned MDX docs
- **AGENTS.md** (AI coding guidelines) is extremely comprehensive â€” covers module organization, commit conventions, test guidelines, security, release flow, multi-agent safety rules, and shorthand commands
- **`CLAUDE.md` is a symlink** to `AGENTS.md` â€” single source of truth across AI tools
- **zh-CN i18n pipeline** â€” English docs are the source of truth; a glossary + translation memory pipeline auto-generates Chinese docs under `docs/zh-CN/`
- **Docs link auditing** â€” `scripts/docs-link-audit.mjs` + `check-docs` CI step validate internal links
- **Changelog convention** â€” user-facing changes only, no internal/meta notes
- **Release docs** â€” dedicated `docs/reference/RELEASING.md` and `docs/platforms/mac/release.md`

**Comparison to roxabi:** roxabi has strong MDX docs co-located in the app. OpenClaw's AGENTS.md depth (multi-agent safety rules, shorthand commands, per-tool notes) is significantly more detailed. The `CLAUDE.md â†’ AGENTS.md` symlink pattern is worth adopting. Docs i18n is out of scope for roxabi currently.

### 10. Unique / Novel Ideas ðŸŸ¢

Several patterns stand out as genuinely novel:

1. **Skills marketplace (ClawHub):** Skills are npm packages installed at runtime. Each skill is a directory with a `tools.md` manifest. The agent runtime dynamically loads skills and injects their tools into the context. This is a plugin architecture for AI capabilities â€” entirely different from roxabi's static extension model.

2. **QMD (Query-Memory-Distill) memory manager:** The `src/memory/` module implements a production-grade memory system with vector embeddings (sqlite-vec), MMR (Maximal Marginal Relevance) for diverse retrieval, temporal decay scoring, hybrid search, and embedding batch management across multiple providers (OpenAI, Voyage, Gemini). This is far more sophisticated than typical RAG.

3. **Protocol code-generation:** A shared protocol schema (`dist/protocol.schema.json`) is code-generated from TypeScript types, then used to generate Swift models for native apps. `pnpm protocol:check` enforces that generated models never drift from the TypeScript source. This pattern enforces type safety across language boundaries.

4. **Scope-aware CI with docs-only bypass:** The CI first runs a "docs-only detection" job. If only docs changed, all heavy jobs (build, test, Windows, macOS, Android) are skipped. Only lint and format run. This reduces CI costs significantly on active docs-heavy repos.

5. **detect-secrets baseline:** Rather than blocking on any secret pattern match (too many false positives), a `.secrets.baseline` file is committed. CI only fails if **new** secrets appear since the last baseline update. This is a pragmatic, low-noise approach to secret scanning.

6. **prek (pre-commit tool):** A custom pre-commit framework (`prek install`) that runs the same checks as CI. Different from Lefthook in that it integrates natively with the pnpm workspace.

7. **Multi-agent safety rules in AGENTS.md:** Explicit rules for concurrent agent sessions (don't stash unless asked, don't switch branches, focus on your own changes). This is a real-world solution to the "multiple Claude sessions editing the same repo" problem.

8. **Slowest-test CI artifact:** `scripts/vitest-slowest.mjs` generates a Markdown report of the 50 slowest test cases and uploads it as a CI artifact. This makes test performance regressions visible without dedicated tooling.

9. **`openclaw doctor`** â€” a diagnostic CLI command that checks config, service health, and common issues. The AI assistant can run this autonomously when users report problems.

10. **`CLAUDE.md` as symlink to `AGENTS.md`:** A single AGENTS.md is the source of truth for all AI coding guidelines, shared across tools (Claude Code, Codex, etc.) via a symlink.

### 11. What They Do Better Than roxabi_boilerplate

**1. Scope-aware CI (docs-only skip + platform detection)**
OpenClaw detects docs-only PRs and skips all expensive jobs. It also detects which platform code changed (Node/macOS/Android) and runs only relevant CI lanes. roxabi currently runs all jobs on every push regardless of change scope.

Adoption: Add a `paths-filter` step to roxabi's CI workflow using `dorny/paths-filter` (already used for E2E path filtering). Skip the `build` job for docs-only changes to `docs/`.

**2. detect-secrets baseline**
`.secrets.baseline` + `detect-secrets scan --baseline` in CI provides incremental secret scanning with low noise. roxabi has no secret scanning at all.

Adoption: Add `detect-secrets` to the CI `secrets` job. Create a `.secrets.baseline` via `detect-secrets scan > .secrets.baseline`. Add to CI as a non-blocking step initially.

**3. Vitest coverage threshold enforcement (70%)**
OpenClaw enforces 70% coverage on lines/branches/functions/statements via Vitest config. roxabi runs coverage but has no enforced threshold.

Adoption: Add `coverageThreshold` to `vitest.config.ts` in roxabi.

**4. Test tier separation (unit / e2e / live / docker)**
Multiple Vitest configs for different test tiers means the fast unit suite can run in &lt;30s while the full integration suite runs separately. roxabi mixes unit and integration tests in one run.

Adoption: Create `vitest.unit.config.ts` that excludes slow integration tests. Run fast tests on every commit, full suite only on PR.

**5. Slowest-test reporting**
CI generates a Markdown report of the 50 slowest tests and uploads as an artifact. Makes performance regressions visible.

Adoption: Create `scripts/vitest-slowest.mjs` and add an upload-artifact step in CI.

**6. AGENTS.md + CLAUDE.md symlink**
Single source of truth for AI coding guidelines shared via symlink. roxabi has a comprehensive CLAUDE.md but it is standalone.

Adoption: roxabi already uses CLAUDE.md well â€” the symlink pattern is useful only if multiple AI tools are used simultaneously.

**7. Docs link auditing script**
`scripts/docs-link-audit.mjs` catches broken internal links. roxabi has no equivalent.

Adoption: Add a link audit script and hook it into CI `check-docs` step.

**8. Per-file LOC enforcement**
`scripts/check-ts-max-loc.ts --max 500` warns when files exceed 500 lines. Keeps code modular.

Adoption: Add a soft LOC check to the lint step in roxabi CI.

### 12. What They Do Better Than 2ndBrain

2ndBrain is a Python personal productivity system (not a TypeScript web boilerplate), so direct comparisons are limited. However:

**1. Multi-provider AI:** OpenClaw supports Anthropic, OpenAI, Gemini, Ollama, HuggingFace, Cloudflare AI Gateway, Bedrock, and more â€” with failover and auth profile rotation. 2ndBrain uses a fixed Claude integration.

**2. Memory system:** OpenClaw's QMD memory manager (hybrid vector search, temporal decay, embedding batching) is far more sophisticated than 2ndBrain's sqlite-vec setup. 2ndBrain uses `sqlite-vec` for basic vector search but lacks MMR, temporal decay, or embedding batching.

**3. Test discipline:** OpenClaw enforces 70% coverage with multiple test tiers. 2ndBrain uses pytest without enforced coverage thresholds.

**4. Skills architecture:** OpenClaw's installable npm skills (ClawHub marketplace) are a production-ready plugin system. 2ndBrain has a static `.claude/skills/` directory with no runtime installation.

**Cross-reference:** Both repos share strengths that roxabi lacks: multi-channel messaging integration and persistent memory. OpenClaw does both at production scale; 2ndBrain does both at personal/prototype scale.

### 13. Key Takeaways

Priority ranking from must-have to nice-to-have:

**Must-have:**

1. **Scope-aware CI with docs-only skip** â€” Reduces CI costs and merge queue latency as roxabi docs grow. Already has the `dorny/paths-filter` infrastructure in CI. File: `.github/workflows/ci.yml`. Estimated effort: 1-2 days.

2. **Vitest coverage threshold (70%)** â€” Prevents coverage regression silently. Add to `vitest.config.ts`: `coverage: { thresholds: { lines: 70, branches: 70, functions: 70, statements: 70 } }`. Estimated effort: 1h + fixing failing threshold.

3. **detect-secrets baseline in CI** â€” Addresses a real security gap. Create `.secrets.baseline`, add `secrets` job to CI. Estimated effort: half day.

**Nice-to-have:**

4. **Test tier separation (unit vs integration)** â€” Create `vitest.unit.config.ts` excluding DB-dependent tests. Run fast unit suite on every commit, full suite only on PR + push. Estimated effort: 1-2 days.

5. **Slowest-test CI artifact** â€” Low-effort visibility into test performance regression. Port `scripts/vitest-slowest.mjs` pattern. Estimated effort: half day.

6. **Docs link audit script** â€” Catches dead links in the docs MDX. Estimated effort: 1 day.

**Potential issues to create:**

- `feat: add scope-aware CI docs-only skip` â†’ linked to epic #163
- `feat: enforce Vitest coverage thresholds (70%)` â†’ linked to epic #163
- `chore: add detect-secrets baseline and CI secret scanning` â†’ linked to epic #163
- `chore: split vitest unit vs integration configs` â†’ linked to epic #163

## What's next?

The most actionable item for roxabi is the **scope-aware CI + docs-only skip pattern**. OpenClaw's approach is well-tested at 200k-star scale and directly applicable to a growing docs-heavy repo.

The **detect-secrets baseline** is a one-time setup that addresses a real gap â€” roxabi has no secret scanning today. It pairs well with the existing `.env.example` discipline.

The **Oxlint + Oxfmt** alternative to Biome is worth tracking. OpenClaw chose it specifically for type-aware linting, which Biome does not yet support. This is not an immediate migration recommendation, but if roxabi hits Biome's limits on type-aware rules, Oxlint is the proven alternative.

The **QMD memory architecture** (`src/memory/`) is high-value inspiration if roxabi ever adds AI memory features â€” hybrid search, temporal decay, and embedding batching are production-proven patterns available to study.
