---
title: "Brainstorm: ai-driven-dev/prompts Analysis"
description: Analysis of ai-driven-dev/prompts for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#210](https://github.com/roxabi/boilerplate/issues/210)
**Repository:** [ai-driven-dev/prompts](https://github.com/ai-driven-dev/prompts)
**Stars / Activity:** 198 stars, last commit November 2025

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Developer prompt library distributed via Espanso text-expander â€” different domain than roxabi |
| How it works | ðŸŸ¢ | README-as-source-of-truth pipeline: Markdown parsed into Espanso YAML automatically |
| Architecture | ðŸŸ¡ | Flat single-package structure â€” intentionally simple for a content repo |
| File structure | ðŸŸ¡ | Clean separation between source (README.md), build output (espanso/), and tooling (src/) |
| Tech stack | ðŸ”´ | Node.js + Jest + Prettier + Husky â€” older, heavier toolchain vs Bun + Biome + Lefthook |
| DX | ðŸŸ¢ | Near-zero onboarding: one `espanso install` command, auto-updates via shell hook or cron |
| Testing | ðŸ”´ | Unit tests only for the parser/generator scripts â€” no coverage targets, no CI test gate |
| CI/CD | ðŸŸ¡ | Single-pipeline auto-release on push to main: bump version, commit, tag, GitHub release |
| Documentation | ðŸŸ¢ | README is the product itself: 130 KB of structured, categorized prompts with inline examples |
| Unique ideas | ðŸŸ¢ | Prompts-as-code: README is both documentation and build input; private prompt overlay pattern |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

A community-maintained library of developer-focused AI prompts distributed as an [Espanso](https://espanso.org/) package. Espanso is a cross-platform text-expander: type `:featureCreate` anywhere on your OS and the full prompt is expanded inline â€” in any app (Cursor, VS Code, ChatGPT, Chrome).

- **Purpose:** Provide high-quality, reusable prompts for common dev tasks (feature generation, code review, debugging, testing, refactoring, project management).
- **Target audience:** Developers using AI coding assistants (Cursor, Copilot, Claude) who want standardized prompts without copy-pasting.
- **Problem solved:** Prompt fragmentation â€” developers repeat the same prompts ad-hoc or lose them across tools. This creates a single versioned, shareable source.

This is a different domain from roxabi_boilerplate (prompt library vs SaaS framework), so the rating is ðŸŸ¡ â€” not better or worse, just orthogonal.

### 2. How It Works ðŸŸ¢

The core workflow is a **README-as-source-of-truth pipeline**:

1. Prompts are authored directly in `README.md` using a strict format: heading with a `:triggerKey` suffix + `<details>` block containing a markdown fenced code block.
2. `npm run start` runs `index.js`, which calls `src/espanso-generation/parseMarkdown.js` to extract all trigger/form pairs from the README.
3. `src/espanso-generation/generateYaml.js` converts the parsed data into Espanso-compatible YAML and writes it to `espanso/package.yml`.
4. Template variables in prompts (`[[variable name]]`, `[[choice1|choice2]]`) are automatically transformed into Espanso form fields with multiline or select inputs.
5. A pre-commit hook runs `npm test` to validate the parser/generator before committing.
6. On push to `main`, the CI workflow regenerates `package.yml`, bumps the patch version in both `package.json` and `espanso/_manifest.yml`, commits the changes, creates a git tag, and publishes a GitHub Release.

A secondary feature (`src/extract-scripts.js`) extracts bash code blocks tagged with `# source: <path>` from markdown and writes them as standalone scripts.

This pipeline is elegant: contributors only ever edit the README, and the entire build + release is automated.

### 3. Architecture & Layers ðŸŸ¡

Intentionally flat, single-package architecture appropriate for a content distribution tool:

```
README.md          â†’ source of truth (prompts authored here)
index.js           â†’ build entry point (orchestrates parsing + YAML gen)
src/               â†’ tooling (parseMarkdown, generateYaml, extractScripts)
espanso/           â†’ build output (package.yml, _manifest.yml)
.github/workflows/ â†’ CI/CD (release pipeline)
```

No layers, no DDD, no hexagonal architecture â€” none of that applies here. The architectural insight worth noting is the **single source of truth pattern**: documentation IS the data. There is no risk of README drifting from the actual prompt content because the README is the input.

This contrasts with roxabi's architecture where configuration, code, and docs are separate layers. For prompt/content repos, this collapsed architecture is strictly better.

### 4. File / Project Structure ðŸŸ¡

```
.github/workflows/release.yml   â†’ single CI workflow
.husky/pre-commit               â†’ test gate before commit
.husky/post-push                â†’ auto-update Espanso after push
.prettierrc                     â†’ formatting config
.vscode/settings.json           â†’ cSpell words for Espanso
CONTRIBUTION.md                 â†’ contributor guide
README.md                       â†’ 130 KB source-of-truth prompt library
docs/                           â†’ images used in README (GIF, PNG)
espanso/_manifest.yml           â†’ Espanso package metadata
espanso/package.yml             â†’ generated Espanso trigger definitions
index.js                        â†’ build script entry point
package.json                    â†’ scripts, deps, jest config
src/espanso-generation/         â†’ parsing + YAML generation modules
src/extract-scripts.js          â†’ bash script extraction utility
```

The `espanso/` directory holds generated output committed to the repo, which is intentional for Espanso's `espanso install --external` flow. The `docs/` directory is assets-only (no MDX, no structured docs site). Configuration is minimal and flat.

### 5. Tech Stack & Tooling ðŸ”´

| Concern | ai-driven-dev/prompts | roxabi_boilerplate |
|---------|----------------------|-------------------|
| Runtime | Node.js 20 | Bun 1.3.9 |
| Language | JavaScript (no types) | TypeScript 5.x strict |
| Linter/Formatter | Prettier only | Biome (lint + format) |
| Test runner | Jest 29 | Vitest 4 |
| Git hooks | Husky 8 | Lefthook 2 |
| Package manager | npm | Bun |
| Monorepo | No | TurboRepo |

The toolchain is older and heavier (Husky + Jest + Prettier vs Lefthook + Vitest + Biome). No TypeScript means no compile-time safety for the parser/generator scripts â€” a real gap given the regex-heavy parsing logic. The `package-lock.json` (137 KB) is committed alongside `package.json`, which adds friction for contributors.

This is a ðŸ”´ relative to roxabi â€” not because the choices are wrong for this repo's complexity level, but because roxabi's stack is strictly more modern and productive.

### 6. Developer Experience (DX) ðŸŸ¢

**End-user DX (prompt consumer):**
```bash
# Install once
espanso install ai-driven-dev-prompts --git git@github.com:ai-driven-dev/prompts.git --external

# Update
espanso package update ai-driven-dev-prompts

# Auto-update (add to .zshrc)
espanso package update ai-driven-dev-prompts
```

This is exceptional DX: system-wide access to all prompts in any application, updated with one command. The `.husky/post-push` hook even auto-updates the local Espanso install after every push to the repo.

**Contributor DX:**
```bash
git clone https://github.com/ai-driven-dev/prompts.git
npm install
# Edit README.md
npm run start   # regenerate espanso/package.yml
npm test        # validate parser
git commit      # pre-commit hook runs tests automatically
```

Onboarding is genuinely fast. The CONTRIBUTION.md clearly explains the prompt format. The only friction is the npm + Node.js requirement (vs Bun), and the lack of a dev mode (you run the full build each time to preview changes).

**Private prompt overlay:** The `index.js` script writes a private Espanso package to `~/Library/Application Support/espanso/match/packages/espanso-private/` for prompts in `./prompts/private/*` â€” a clean pattern for keeping personal/work prompts separate from the public library.

### 7. Testing Strategy ðŸ”´

Tests exist only for the tooling scripts (parser and YAML generator), not for the prompts themselves:

```
src/espanso-generation/parseMarkdown.test.js   â†’ unit tests for markdown parser
src/espanso-generation/generateYaml.test.js    â†’ unit tests for YAML generator
src/extract-scripts.test.js                    â†’ unit tests for script extractor
```

- No coverage targets or enforcement
- No integration tests (no test that the full `index.js` pipeline runs end-to-end)
- No CI test gate â€” the release workflow runs `npm run start` but never `npm test`
- The pre-commit hook runs `npm test`, which provides some local protection

The pre-commit test gate is good, but the CI pipeline skips tests entirely. Given the regex-heavy parsing logic, a coverage threshold of even 80% would be justified.

### 8. CI/CD Pipelines ðŸŸ¡

Single workflow: `.github/workflows/release.yml`, triggered on push to `main` or `workflow_dispatch`.

**Pipeline steps:**
1. Checkout with full history (`fetch-depth: 0`)
2. Setup Node.js 20
3. `npm install`
4. `npm run start` â€” regenerate `espanso/package.yml`
5. Extract current version from `package.json`, increment patch, update `package.json` and `espanso/_manifest.yml` via `sed`
6. Generate changelog from git log since last tag
7. Commit and push bumped files (`git add package.json espanso/`)
8. Create and push git tag
9. Create GitHub Release via REST API

**Strengths:**
- Fully automated versioning and release â€” no manual steps after merging a PR
- Changelog generated from commit messages
- GitHub Release created automatically

**Weaknesses:**
- No test run in CI (only build)
- `sed -i` used to update YAML version â€” fragile on edge cases
- Bot commits (`github-actions[bot]`) can trigger infinite CI loops if not careful (no protection)
- No branch protection rules visible
- No preview/staging stage â€” main is always production

Compared to roxabi's CI (lint + typecheck + test + preview deploy + Neon branch), this is simpler but sufficient for a content repo. The ðŸŸ¡ rating reflects "different use case, comparable quality for what it is."

### 9. Documentation Quality ðŸŸ¢

The README is the product. At 131 KB (~4,000 lines), it is the most complete and useful documentation of any repo in this comparison set:

- Full table of contents with anchor links
- 70+ categorized prompts across 15 domains (feature generation, debugging, testing, refactoring, project management, etc.)
- Each prompt has: French title, English description, collapsible `<details>` block with the full prompt text
- Template variables documented inline (`[[variable name]]`, `[[choice1|choice2]]`)
- Installation instructions with platform-specific auto-update examples (zshrc, cron, Launchd)
- GIF demo of Espanso usage

`CONTRIBUTION.md` explains the exact format contributors must follow with a worked example. This is better than most open-source contribution guides.

The weakness: no architecture docs, no API reference, no changelog separate from GitHub Releases, no versioned docs site.

### 10. Unique / Novel Ideas ðŸŸ¢

**1. README as build input (Docs-as-Code taken further)**

Most projects use docs-as-code to generate documentation from code. This repo inverts it: the README is the source data that generates the deployable artifact (`espanso/package.yml`). The documentation IS the product. This eliminates any possibility of drift between what is documented and what is deployed.

**Applicability to roxabi:** Could inform how roxabi handles CLAUDE.md skill documentation â€” if the skill description in a CLAUDE.md file was also parseable to generate something executable (e.g., a CLI command registry, or an MCP tool definition).

**2. Private prompt overlay pattern**

The `index.js` script generates both a public package (committed to GitHub) and a private package (written to the local Espanso config directory, never committed). Contributors can maintain personal prompts that extend the community library without polluting the public repo.

**Applicability to roxabi:** The pattern of "public base + private local extension" could apply to roxabi's skill system: a base set of skills in the repo + a local `~/.claude/private-skills/` directory for team-specific or personal skills.

**3. Text-expander as AI interface layer**

Using Espanso as a system-wide prompt dispatcher means the prompt library works in literally any application â€” not just IDEs with plugin support. This is a distribution model worth considering for how roxabi surfaces AI tooling to developers.

**4. Trigger taxonomy via naming convention**

The trigger key naming convention encodes category + action: `:featureCreate`, `:bugFinder`, `:testUnit`, `:refactSRP`. This is a lightweight, discoverable taxonomy that works without a GUI. Roxabi's skill system uses a similar approach (skill names as categories) but less systematically.

**5. Auto-update via post-push git hook**

The `.husky/post-push` hook runs `espanso package update ai-driven-dev-prompts` after every push. This makes the developer's local Espanso installation always in sync with the upstream repo automatically. A small but clever piece of glue.

### 11. What They Do Better Than roxabi_boilerplate

**1. Fully automated release pipeline**

Every push to `main` automatically: regenerates the artifact, bumps the version, commits, tags, and creates a GitHub Release â€” all without manual intervention. Roxabi's release process (via `/promote`) involves several manual steps.

- Actionable: adopt the automated patch-version bump + GitHub Release creation pattern for roxabi's library packages (`packages/types`, `packages/ui`, `packages/config`) when they are published.

**2. README quality as contributor onboarding**

The CONTRIBUTION.md is exemplary: it explains the exact format, gives a worked example, and links to the regeneration command. Roxabi's contributing docs (`docs/contributing.mdx`) are good but more process-heavy than format-specific.

**3. System-wide prompt accessibility**

Espanso makes prompts available in every application on the OS. Roxabi's `.claude/skills/` are only available inside Claude Code sessions. For prompts that are used outside of Claude Code (ChatGPT, Cursor, browser), there is no distribution mechanism.

- Actionable: consider maintaining an Espanso package or similar text-expander config for commonly-used prompts that work outside Claude Code.

**4. Private overlay for personal extensions**

The pattern of generating a private Espanso package alongside the public one is elegant. Roxabi has no equivalent mechanism for developers to add private skills without modifying the committed `.claude/` directory.

- Actionable: document a pattern for local-only skill extensions (e.g., `~/.claude/skills/` directory that Claude Code loads in addition to the repo's `.claude/skills/`).

### 12. What They Do Better Than 2ndBrain

2ndBrain exists at `/home/mickael/projects/2ndBrain/` and is a personal knowledge management system built in Python. Key observations for comparison:

**ai-driven-dev/prompts does better:**

- **Distribution model:** Prompts are installable by anyone via `espanso install`. 2ndBrain's prompts/skills are locked inside the personal repo with no external distribution mechanism.
- **Community maintenance:** 198 stars and community PRs mean the prompt quality improves over time with many contributors. 2ndBrain is a personal project.
- **Cross-app availability:** Espanso works system-wide. 2ndBrain's skills only work inside Claude Code.
- **Versioning:** Semantic versioning with GitHub Releases provides a clear upgrade path. 2ndBrain has no versioning for its skill/prompt content.

**2ndBrain does better:**

- **Execution scope:** 2ndBrain skills actually execute code (Google Calendar API, Gmail, vector search, Telegram bot). ai-driven-dev/prompts only distributes text â€” it does not execute anything.
- **Integration depth:** 2ndBrain integrates with real external services (Google Workspace, Telegram). The prompts repo is self-contained.
- **Python tooling:** 2ndBrain uses `uv` (modern Python package manager) and has structured test infrastructure (`pytest`). The prompts repo uses older npm/Jest.

The repos solve different problems and the cross-comparisons are limited. The prompt distribution model is the clear takeaway for 2ndBrain.

### 13. Key Takeaways

**Priority 1 â€” Must consider: "README as build input" pattern for skill metadata**

The idea that a human-readable document can be the source of truth for a generated artifact is applicable to roxabi's skill system. If each skill's `SKILL.md` followed a machine-parseable format, roxabi could auto-generate: a CLI command registry, Claude's tool descriptions, or a documentation site for available skills. This is a high-value architectural pattern.

- Potential issue: "Define parseable format for SKILL.md and auto-generate skill registry"

**Priority 2 â€” Nice to have: Automated patch-version bump + GitHub Release in CI**

The release workflow pattern (regenerate artifact â†’ bump patch version â†’ commit â†’ tag â†’ publish GitHub Release) is clean and reusable. Roxabi could adopt this for its packages (`packages/types`, `packages/ui`) to automate minor releases without manual `/promote` overhead.

- Potential issue: "Automate package versioning in CI for library packages"

**Priority 3 â€” Nice to have: Private skill overlay pattern**

Documenting a standard location for local-only Claude Code skills (e.g., `~/.claude/skills/`) that complements the committed `.claude/skills/` directory would let developers maintain personal/team-specific extensions without committing them.

- Potential issue: "Document local-only skill extension pattern for Claude Code"

**Priority 4 â€” Nice to have: Espanso package for roxabi developer prompts**

Maintain an Espanso package distributing the prompt templates used in roxabi development (bootstrap, spec, review prompts). This makes them available in Cursor, ChatGPT, and other tools outside Claude Code.

- Potential issue: "Create espanso package for roxabi developer prompt templates"

**Priority 5 â€” Reference: Trigger naming taxonomy**

The `:categoryAction` trigger naming convention (`:featureCreate`, `:bugFinder`, `:testUnit`) is a clean taxonomy pattern worth adopting for roxabi's skill naming if the skill count grows significantly.

## What's next?

- Create issue: "Define parseable SKILL.md format and auto-generate skill registry" â€” high value, ties into the CLAUDE.md skill documentation already in place
- Create issue: "Automate patch-version bump + GitHub Release in CI for library packages" â€” straightforward to implement once package publishing is needed
- Create issue: "Document local-only Claude Code skill extension pattern" â€” small docs change with high DX impact
- Optionally: clone the Espanso package pattern for roxabi developer prompts as a separate standalone repo
