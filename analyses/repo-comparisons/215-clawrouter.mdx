---
title: "Brainstorm: ClawRouter Analysis"
description: Analysis of BlockRunAI/ClawRouter for epic #163
type: brainstorm
---

## Context

**GitHub sub-issue:** [#215](https://github.com/roxabi/boilerplate/issues/215)
**Repository:** [BlockRunAI/ClawRouter](https://github.com/BlockRunAI/ClawRouter)
**Stars / Activity:** 2,654 stars, last commit 2026-02-17

## Summary Table

| Axis | Rating | One-liner |
|------|--------|-----------|
| What it does | ðŸŸ¡ | Agent-native LLM router, entirely different problem domain from roxabi |
| How it works | ðŸŸ¢ | 14-dimension local classifier + x402 micropayments is genuinely novel |
| Architecture | ðŸŸ¢ | Clean layered proxy architecture with well-separated concerns |
| File structure | ðŸŸ¡ | Flat single-package layout; simpler than roxabi but appropriate for scope |
| Tech stack | ðŸŸ¡ | TypeScript + tsup + Prettier/ESLint; comparable quality, different choices |
| DX | ðŸŸ¢ | One-line install, zero API keys, self-funded wallet â€” extremely low friction |
| Testing | ðŸ”´ | Ad-hoc .mjs scripts at root, no coverage enforcement, test files scattered |
| CI/CD | ðŸ”´ | Single `ci.yml` with no deployment stage, no preview branches, no secrets management |
| Documentation | ðŸŸ¢ | Thorough README, dedicated architecture doc, vs-competitor doc, troubleshooting |
| Unique ideas | ðŸŸ¢ | x402 per-request USDC payments, local 14-dim routing, `openclaw.security.json` |

## Detailed Analysis

### 1. What It Does ðŸŸ¡

ClawRouter is an **agent-native LLM router** that sits as a local HTTP proxy between an AI agent (specifically OpenClaw) and LLM providers. It solves a specific infrastructure problem: routing every LLM request to the cheapest model capable of handling it, while paying per-request using USDC micropayments instead of API keys.

**Value proposition:**
- 30+ models (OpenAI, Anthropic, Google, DeepSeek, xAI) through a single wallet
- Claims 74â€“100% cost savings depending on routing profile (auto / eco / premium / free)
- Eliminates API key management â€” authentication is cryptographic (EIP-712 USDC on Base L2)

**Target audience:** AI agent builders who want to reduce inference costs at scale without managing per-provider API keys.

**Rating rationale:** This is a different domain from roxabi (SaaS boilerplate vs LLM router), so the comparison is lateral. Rating is ðŸŸ¡ â€” it does not compete with roxabi but presents interesting infrastructure patterns worth understanding.

---

### 2. How It Works ðŸŸ¢

The core mechanic is a **two-stage local classifier** running entirely client-side in under 1ms:

1. **Stage 1 â€” Rule-based scorer (`router/rules.ts`)**: A 14-dimension weighted scoring system (token count, reasoning keywords, code presence, agentic task markers, multi-step patterns, question complexity, etc.) classifies each request into SIMPLE / MEDIUM / COMPLEX / REASONING. Handles ~70â€“80% of requests.

2. **Stage 2 â€” LLM fallback classifier (`router/llm-classifier.ts`)**: When Stage 1 is ambiguous (confidence < 0.7), it routes to the cheapest available model (~$0.00003) with an in-memory cache keyed by SHA-256 hash of the prompt. Triggered for ~20â€“30% of requests.

3. **Payment flow (x402)**: The proxy intercepts HTTP 402 responses from the BlockRun API, signs an EIP-712 USDC transfer from the local wallet using `viem`, and retries the request with the signed `X-PAYMENT` header. After the first payment to a given endpoint, the system caches payment details and pre-signs future payments to skip the 402 round-trip (~200ms savings).

4. **Reliability features**: SSE heartbeat every 2s prevents upstream timeouts during payment; SHA-256 request deduplication prevents double-charging on client retries (30s TTL); fallback chain cycles through models on 4xx/5xx provider errors.

**Rating rationale:** The combination of pure-local routing (no external classifier API calls) + cryptographic micropayments is architecturally elegant and genuinely well-executed. Clearly better than anything roxabi has today in the AI-infra space.

---

### 3. Architecture & Layers ðŸŸ¢

ClawRouter follows a clean pipeline/proxy architecture:

```
OpenClaw Client
    â†“
Dedup Cache (SHA-256, 30s TTL)
    â†“
Router (14-dim rules â†’ LLM fallback)
    â†“
Balance Monitor (USDC check, 1-min cache + optimistic deduction)
    â†“
SSE Heartbeat (prevents streaming timeout)
    â†“
x402 Payment (EIP-712 signing, pre-auth cache)
    â†“
BlockRun API â†’ Provider (OpenAI / Anthropic / Google / ...)
```

Layers are well separated: `proxy.ts` orchestrates the flow; `router/` handles classification; `x402.ts` handles payments; `balance.ts` handles wallet state; `dedup.ts` handles idempotency. There is no cross-layer leakage â€” each module has a single clear job.

The `openclaw.plugin.json` and `openclaw.security.json` define a plugin contract with the host application (OpenClaw), which is an interesting pattern for distributing infrastructure extensions with explicit security disclosures.

**Rating rationale:** For its scope (single-package proxy), the architecture is unusually well-structured. Layered pipeline, explicit error types, in-memory caching strategies. Compares favorably to roxabi's modular monorepo â€” though both address different complexity levels.

---

### 4. File / Project Structure ðŸŸ¡

```
ClawRouter/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ router/           # classifier, selector, config, types
â”‚   â”œâ”€â”€ index.ts          # plugin entry + OpenClaw integration
â”‚   â”œâ”€â”€ proxy.ts          # core HTTP proxy + SSE
â”‚   â”œâ”€â”€ x402.ts           # EIP-712 payment signing
â”‚   â”œâ”€â”€ balance.ts        # USDC balance monitoring
â”‚   â”œâ”€â”€ dedup.ts          # request deduplication
â”‚   â”œâ”€â”€ models.ts         # 30+ model definitions with pricing
â”‚   â””â”€â”€ ...               # logger, errors, retry, session, stats
â”œâ”€â”€ test/                 # integration/resilience tests (.ts files)
â”œâ”€â”€ skills/clawrouter/    # SKILL.md for OpenClaw plugin system
â”œâ”€â”€ docs/                 # architecture.md, configuration.md, etc.
â”œâ”€â”€ package.json          # single-package, npm, tsup build
â”œâ”€â”€ openclaw.plugin.json  # plugin manifest
â”œâ”€â”€ openclaw.security.json # security disclosure for plugin host
â””â”€â”€ blockrun-clawrouter-0.8.25.tgz # pre-built tarball committed to repo (anti-pattern)
```

**Observations:**
- Flat `src/` layout with a `router/` subdirectory â€” clean and navigable
- Test files are scattered: a `test/` directory contains TypeScript tests, but the root contains several `.mjs` test scripts (`final-test.mjs`, `test-routing-changes.mjs`, etc.) and some test files live in `src/` (`journal.test.ts`, `response-cache.*.test.ts`)
- A pre-built `.tgz` is committed to the repo â€” a clear anti-pattern for source repos (binary artifacts should be published to npm)
- `skills/` directory mirrors roxabi's `.claude/skills/` concept

**Rating rationale:** Structure is ðŸŸ¡ â€” appropriate for a single-package library but the test file sprawl and committed binary are weaknesses. Not better or worse than roxabi in this respect, just differently scoped.

---

### 5. Tech Stack & Tooling ðŸŸ¡

| Dimension | ClawRouter | roxabi_boilerplate |
|-----------|-----------|-------------------|
| Runtime | Node.js â‰¥20 | Bun â‰¥1.3.9 |
| Language | TypeScript 5.7 | TypeScript 5.x (strict) |
| Build | tsup (esbuild-based) | Vite / TanStack Start / NestJS |
| Linter | ESLint 9 (flat config) | Biome |
| Formatter | Prettier | Biome |
| Package manager | npm (package-lock.json) | Bun |
| Monorepo | None (single package) | TurboRepo |
| Test runner | Vitest | Vitest |
| Key runtime dep | viem (EVM wallet) | (various) |

ClawRouter uses ESLint + Prettier where roxabi uses Biome (which replaces both). The choice of `tsup` for building a library is excellent â€” it's the standard for TypeScript library builds. The use of `viem` for EIP-712 signing is idiomatic for the Web3 stack.

**Rating rationale:** Stack quality is comparable. roxabi is ahead on tooling consolidation (Biome vs ESLint+Prettier dual setup). No clear winner overall â€” ðŸŸ¡.

---

### 6. Developer Experience (DX) ðŸŸ¢

ClawRouter's DX story is exceptional for its target use case:

```bash
# Full install flow
curl -fsSL https://blockrun.ai/ClawRouter-update | bash
openclaw gateway restart
# Fund $5 USDC â†’ done. No API keys, no accounts, no config.
```

- **Zero-configuration start**: wallet auto-generated on first run and saved to `~/.openclaw/blockrun/wallet.key`
- **Routing is transparent**: smart routing enabled by default, no user action required
- **4 pre-built profiles** (`auto`, `eco`, `premium`, `free`) cover all common use cases
- **Telegram demo** in README shows the experience end-to-end
- **Plugin system** (`openclaw.plugin.json` + `skills/clawrouter/SKILL.md`) means the router is discoverable and usable from within the agent itself

For developers embedding ClawRouter as a library, the `openclaw.security.json` explicitly documents what the plugin does with wallet keys â€” a trust pattern that reduces friction when security-conscious users evaluate the tool.

**Rating rationale:** The zero-API-key, auto-funded wallet approach is a step-change improvement over traditional developer tooling DX. Clearly better than roxabi's initial setup friction (docker, env vars, db branch). ðŸŸ¢ for innovation in onboarding model.

---

### 7. Testing Strategy ðŸ”´

Testing is the weakest area of the repo:

- **No unit tests** for the core routing logic (`router/rules.ts`, `router/llm-classifier.ts`) â€” the most critical code in the project
- **Vitest** is configured, but only `response-cache.*.test.ts` and `journal.test.ts` live in `src/`
- **Integration/resilience tests** in `test/` (`resilience-errors.ts`, `resilience-stability.ts`, `resilience-lifecycle.ts`) are TypeScript scripts run with `npx tsx`, not vitest â€” so no coverage, no CI integration
- **Ad-hoc .mjs scripts** at the project root (`final-test.mjs`, `test-routing-changes.mjs`, `test-profiles.mjs`) appear to be manual smoke tests
- **No coverage enforcement** â€” `vitest run` in CI does not gate on coverage thresholds
- **Docker-based install tests** (`test/Dockerfile.install-test`) are separate from the main CI pipeline and not run automatically

The CI pipeline (`ci.yml`) runs `npm run build` but does NOT run `npm test`. Testing is effectively absent from the automated gate.

**Rating rationale:** roxabi has a full testing setup (Vitest with coverage via Lefthook pre-push, Playwright for e2e, structured test directories). ClawRouter's testing is disorganized and not enforced. ðŸ”´ â€” roxabi clearly does this better.

---

### 8. CI/CD Pipelines ðŸ”´

The single workflow (`ci.yml`) is minimal:

```yaml
jobs:
  check:
    steps:
      - checkout
      - setup Node 20
      - npm ci
      - prettier --check
      - eslint src/
      - tsc --noEmit
      - npm run build
```

**Missing entirely:**
- No test execution in CI (tests are not run)
- No deployment stage (package is published manually / via tarball committed to repo)
- No branch protection rules visible in the config
- No preview deploy pipeline
- No secrets management patterns
- No staging/production environment split
- No automated npm publish on tag/release

**Rating rationale:** roxabi has a full CD pipeline with Vercel preview deployments, Neon DB branching per PR, staging â†’ main promotion flow, and pre-push hooks enforcing lint + typecheck + coverage. ClawRouter's CI is a basic format/lint/build check with no deployment automation. ðŸ”´ â€” roxabi is significantly more mature here.

---

### 9. Documentation Quality ðŸŸ¢

ClawRouter's documentation is high quality relative to its scope:

- **README** (20KB): thorough quick-start, routing profile table, model catalog with pricing, savings breakdown, architecture diagram, feature list â€” professional open-source quality
- **`docs/architecture.md`**: detailed ASCII diagrams for request flow, routing engine internals, payment system, and all optimization patterns â€” with code snippets
- **`docs/configuration.md`**: covers all config options and scoring weights
- **`docs/features.md`**: dedicated feature reference
- **`docs/vs-openrouter.md`**: honest competitor comparison with links to actual GitHub issues that justify the design decisions
- **`docs/troubleshooting.md`**: common issues and solutions
- **`skills/clawrouter/SKILL.md`**: discoverable skill definition for OpenClaw

The `vs-openrouter.md` is particularly notable: it uses real OpenClaw issue numbers to justify every design choice in ClawRouter. This is a strong practice â€” design decisions are anchored to real-world evidence.

**Rating rationale:** Documentation depth and quality exceed most comparably-sized open-source projects. The architecture doc and competitor comparison are genuinely useful. ðŸŸ¢ for documentation practices.

---

### 10. Unique / Novel Ideas ðŸŸ¢

Several patterns in ClawRouter are genuinely novel or worth adopting:

**1. `openclaw.security.json` â€” Explicit plugin security disclosure**
A structured JSON file that documents exactly what sensitive data a plugin accesses, why, and what happens to it (network transmission: false). This is a pattern for plugin ecosystems that reduces user anxiety and builds trust without requiring a full security audit. Directly applicable to roxabi's plugin/extension model.

**2. x402 per-request micropayments via EIP-712 + USDC**
Rather than API keys (shared secrets), authentication is cryptographic: each request is paid for with a signed USDC transfer on Base L2. The payment cache skips the 402 round-trip for known endpoints. This removes the "key leak to every provider" problem. For SaaS products, this pattern could replace subscription billing with metered Web3 payments.

**3. SSE heartbeat pattern for preventing proxy timeouts**
Sending `": heartbeat\n\n"` comments every 2 seconds while waiting for an async operation (payment signing) keeps the SSE stream alive without sending actual data. This is an underused pattern in streaming proxies.

**4. Optimistic balance deduction**
After a successful payment, the in-memory balance cache is immediately decremented by the estimated amount rather than waiting for the next RPC call. This avoids over-spending on parallel requests without adding RPC latency.

**5. Competitor analysis anchored to real issues**
The `vs-openrouter.md` document links every claimed advantage to a real GitHub issue in the competitor's tracker. This is a compelling open-source communication pattern: concrete, verifiable, and user-focused.

**6. `openclaw.plugin.json` â€” Plugin manifest with schema validation**
A declarative plugin manifest with a `configSchema` (JSON Schema) and `uiHints` for sensitive fields. Useful for plugin discovery and auto-generating configuration UIs.

---

### 11. What They Do Better Than roxabi_boilerplate

**a) Onboarding / DX**
ClawRouter's zero-API-key, auto-wallet onboarding is conceptually ahead of roxabi's current setup (docker + .env + db:branch:create). While these serve different purposes, the philosophy of "fund and go" vs "configure to go" is worth internalizing.

Relevant file: `src/auth.ts` (wallet auto-generation), `scripts/install.sh` (the one-liner)

**b) Architecture documentation**
`docs/architecture.md` provides a complete technical narrative with ASCII diagrams, code snippets, and flow explanations. roxabi has architecture docs but they are higher-level. ClawRouter's level of detail is a model to follow for documenting runtime behavior.

**c) Competitor comparison with evidence**
`docs/vs-openrouter.md` uses real issue links to justify design decisions. roxabi has no equivalent â€” decisions are documented in ADRs but without systematic competitive grounding.

**d) Plugin security disclosure pattern**
`openclaw.security.json` is a novel, useful idea. roxabi has no equivalent pattern for communicating what Claude Code hooks or MCP plugins do with sensitive data.

---

### 12. What They Do Better Than 2ndBrain

2ndBrain is a Python personal productivity system (Claude Code + Google Workspace + Telegram bot). The comparison with ClawRouter is largely orthogonal, but:

**a) Type safety in configuration**
ClawRouter uses JSON Schema (`configSchema` in `openclaw.plugin.json`) for plugin configuration validation. 2ndBrain uses Python dicts and `.env` files with no validation layer.

**b) Documentation of security surface**
`openclaw.security.json` explicitly documents what data the plugin accesses and why. 2ndBrain handles OAuth tokens and API keys with no equivalent transparency document.

**c) Published library pattern**
ClawRouter is designed as an npm package with proper `exports`, `types`, and `bin` fields. 2ndBrain is a script-based project with no distribution story.

**Note:** These are not areas where ClawRouter and roxabi overlap â€” 2ndBrain is a personal tool, ClawRouter is an npm library. The comparisons are thematic rather than direct.

---

### 13. Key Takeaways

**1. (Must-have) `openclaw.security.json` pattern for plugins and hooks**
roxabi ships `.claude/settings.json` hooks (Biome auto-format, security warn) that run arbitrary code. Adding a `claude.security.json` or similar structured disclosure document listing what each hook does, what files it touches, and what commands it runs would improve trust and auditability. Low effort, high value.

**2. (Must-have) Architecture docs with runtime flow diagrams**
ClawRouter's `docs/architecture.md` â€” combining ASCII architecture diagrams, request-flow pseudocode, and optimization explanations â€” is a template roxabi should adopt for documenting how the API and web app interact at runtime (middleware chain, auth flow, WebSocket lifecycle, etc.).

**3. (Nice-to-have) SSE heartbeat pattern in the API layer**
For any streaming endpoints in the NestJS API, proactively sending SSE comment heartbeats during async operations (DB queries, AI calls) prevents proxy/load-balancer timeouts. Directly applicable to any future AI streaming endpoint in roxabi.

**4. (Nice-to-have) Optimistic cache deduction for metered resources**
The balance monitor's optimistic deduction pattern (decrement in-memory cache immediately after use, re-sync on next read) is applicable to any rate-limited or metered resource in roxabi (API rate limits, token budgets, plan quota).

**5. (Inspiration) Competitor comparison anchored to real issues**
For future ADRs or design decisions in roxabi, adopt the pattern of linking to real-world evidence (GitHub issues, CVEs, benchmarks) rather than abstract arguments. Makes ADRs more compelling and easier to revisit.

**Priority:** Items 1 and 2 are actionable improvements to roxabi's documentation and meta-tooling. Items 3 and 4 are applicable when AI streaming features are built. Item 5 is a process improvement for ADR writing.

**Potential issues to create:**
- "Add claude.security.json / hooks disclosure document" (Tier S)
- "Add runtime architecture diagram for API request flow" (Tier S)
- "SSE heartbeat middleware for streaming AI endpoints" (Tier F-lite, when AI streaming is built)

## What's next?

- Create a `claude.security.json` (or equivalent in `.claude/`) documenting what each hook in `.claude/settings.json` does and what filesystem access it requires
- Add a runtime flow diagram to `docs/architecture/` modeled on ClawRouter's `docs/architecture.md` â€” specifically documenting the NestJS middleware chain, auth flow, and Fastify request lifecycle
- When AI streaming endpoints are added to the API, implement the SSE heartbeat pattern from `proxy.ts`
- Reference the competitor-comparison-with-evidence approach in future ADR writing guidelines
