---
title: "RBAC (Roles and Permissions)"
description: Analysis of Role-Based Access Control design for multi-tenant B2B SaaS
---

## Context

Roxabi needs fine-grained access control for its multi-tenant B2B platform. The current system has:

- **Global user roles** (`user | admin | superadmin`) stored on the `users` table
- **Organization membership** via the `members` table with a basic `role` column (currently just `'member'`)
- **Multi-tenant RLS** (issue #21) providing row-level tenant isolation
- **AuthGuard** with `@Roles()` and `@RequireOrg()` decorators

This is insufficient for production B2B use cases. Organizations need to control what their members can do — read-only viewers, editors, billing managers, etc. Custom roles per tenant are a requirement.

**Dependencies**: #19 (Auth — done), #21 (Multi-tenant RLS — done)
**Blocks**: Admin panel

## Questions Explored

1. How should platform-level administration relate to tenant-level roles?
2. Should permissions use inheritance, flat lists, or composable groups?
3. How do roles work across multiple organizations?
4. What role does the organization creator get?
5. How does the frontend consume permissions?
6. What is the initial permission scope?

## Analysis

### Platform Super-Admin vs Tenant Roles

**Decision: Two-layer system.**

- **Platform super-admin** (`superadmin` on `users.role`) transcends tenant boundaries. Can access all organizations, manage the platform itself, and bypass tenant-scoped restrictions.
- **Tenant roles** (on `members.role` or via a new role assignment table) are scoped per organization. Each org defines what its members can do.

This maps cleanly to the existing schema: `users.role` handles platform level, `members` handles org level. The `superadmin` global role already exists in the `Role` type.

### Flat Permission Model

**Decision: Each role explicitly lists its permissions. No inheritance.**

Trade-offs considered:

| Model | Verdict |
|-------|---------|
| Hierarchical (rank-based) | Rejected — too rigid. Can't express "Billing Manager has billing perms but not all Admin perms." |
| Composable (groups) | Deferred — adds complexity. Can layer on later if custom role creation becomes cumbersome. |
| **Flat (explicit)** | **Chosen** — simplest to implement, debug, and audit. Custom role creation = pick permissions from a list. |

A role is a named collection of permissions. Permissions are `resource:action` strings. Example:

```
Role "Admin" → ["users:read", "users:write", "users:delete", "members:read", "members:write", ...]
Role "Viewer" → ["users:read", "members:read", "organizations:read"]
```

### Per-Organization Roles

**Decision: Different roles per organization.**

A user can be Admin in Org A and Viewer in Org B. This is the standard B2B SaaS pattern and maps directly to the existing `members` table — one row per user-org pair.

The session's `activeOrganizationId` determines which org context is active, and the role is resolved from the corresponding membership record.

### Owner Role

**Decision: Transferable Owner role.**

- Organization creator gets the **Owner** role automatically.
- Ownership can be transferred to another Admin.
- At least one Owner must exist at all times (enforced by the API).
- Owner has all permissions plus org-level administrative actions (delete org, transfer ownership).

### Default Roles

Four built-in roles ship with every organization:

| Role | Purpose | Deletable? |
|------|---------|-----------|
| **Owner** | Full control + org administration (delete, transfer). At least one required. | No |
| **Admin** | Full operational permissions. Can manage members and roles. | No |
| **Member** | Standard access. Can read and write business data. | No |
| **Viewer** | Read-only access. | No |

Default roles cannot be deleted but their permissions can be customized per tenant (except Owner, which always has all permissions).

### Custom Roles

Tenants can create custom roles by selecting permissions from the available set. Custom roles:

- Have a tenant-scoped name and description
- Are stored per organization (tenant_id scoped via RLS)
- Can be assigned to members like any default role
- Can be deleted (members with deleted role fall back to Viewer or are unassigned — TBD in spec)

### Permission Scope (Initial)

Permissions follow the `resource:action` pattern. Initial resources cover existing entities only:

| Resource | Actions | Notes |
|----------|---------|-------|
| `users` | `read`, `write`, `delete` | View/edit/remove users within org context |
| `organizations` | `read`, `write` | View/edit org settings. No `delete` at member level (Owner only). |
| `members` | `read`, `write`, `delete` | View/invite/remove org members |
| `invitations` | `read`, `write`, `delete` | View/send/revoke invitations |

Future resources (`settings`, `audit`, `billing`, etc.) will be added as those features are built. The system is designed to be extensible — adding a resource is just adding new `resource:action` strings.

### Frontend Permission Delivery

**Decision: Permissions resolved server-side, included in session.**

When the session is fetched (Better Auth), the API resolves the user's role for the active organization, expands it to a flat `string[]` of permissions, and includes it in the session response.

```typescript
// Session response includes:
{
  user: { id, email, role /* global */ },
  session: { activeOrganizationId },
  permissions: ["users:read", "users:write", "members:read", ...] // resolved for active org
}
```

Frontend reads `session.permissions` directly. No extra API calls, no static mapping to maintain. When the user switches organizations, the session refreshes and permissions update.

### Database Schema Direction

New tables needed (alongside existing `users`, `organizations`, `members`):

1. **`roles`** — Role definitions per tenant
   - `id`, `name`, `slug`, `description`, `is_default`, `tenant_id`, timestamps
   - Default roles are seeded per org on creation

2. **`permissions`** — Permission definitions (global, not tenant-scoped)
   - `id`, `resource`, `action`, `description`
   - Seeded from a master list. Not editable by tenants.

3. **`role_permissions`** — Many-to-many join
   - `role_id`, `permission_id`

4. **`members.role` column** — Changes from free-text `'member'` to FK referencing `roles.id`
   - Or: add a `role_id` column to `members`, keep `role` for backward compat during migration

### Integration with Existing Systems

- **AuthGuard**: Add a `@Permissions('resource:action')` decorator alongside existing `@Roles()`. The guard resolves the user's org-level permissions and checks.
- **TenantInterceptor**: Already sets org context. Permission resolution happens after tenant context is established.
- **RLS**: Role and role_permissions tables are tenant-scoped via `tenant_id`. Permissions table is global (no tenant_id).
- **Better Auth**: Organization plugin manages membership. RBAC layer reads membership to resolve role → permissions.

### Super-Admin Bypass

Platform `superadmin` users bypass permission checks entirely. Implementation options:

1. **Guard-level bypass**: If `user.role === 'superadmin'`, skip permission checks (simplest)
2. **RLS bypass**: Use a separate Postgres role without RLS restrictions (documented in #21 analysis as future work)

For MVP, option 1 (guard-level bypass) is sufficient. Option 2 can be added later for database-level super-admin queries.

## Conclusions

1. **Two-layer model**: Global roles (`superadmin`) for platform, tenant-scoped roles for organizations
2. **Flat permissions**: Explicit permission lists per role, no inheritance — simplest for MVP and custom roles
3. **Per-org roles**: Standard B2B pattern, maps to existing `members` table
4. **Owner + Admin + Member + Viewer** as non-deletable defaults, with custom role support
5. **Permissions in session**: Server-side resolution, zero frontend overhead
6. **Existing entities only**: `users`, `organizations`, `members`, `invitations` — extensible by design
7. **Guard-level enforcement**: New `@Permissions()` decorator, super-admin bypass at guard level

## Next Steps

- Create a spec (`specs/24-rbac.mdx`) with detailed schema, API design, migration plan, and guard implementation
- Define the exact permission matrix for each default role
- Design the role management API (CRUD for custom roles)
- Plan the migration path for `members.role` (free text → FK)
- Consider UI components for role/permission management (blocked by Admin panel)
